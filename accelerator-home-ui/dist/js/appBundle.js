/**
 * App version: 3.7 19/07/22
 * SDK version: 4.8.3
 * CLI version: 2.9.1
 * 
 * Generated: Fri, 11 Nov 2022 14:47:00 GMT
 */

var APP_accelerator_home_ui = (function () {
  'use strict';

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const settings = {};
  const subscribers = {};
  const initSettings = (appSettings, platformSettings) => {
    settings['app'] = appSettings;
    settings['platform'] = platformSettings;
    settings['user'] = {};
  };
  const publish = (key, value) => {
    subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value));
  };
  const dotGrab = function () {
    let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let key = arguments.length > 1 ? arguments[1] : undefined;
    if (obj === null) return undefined;
    const keys = key.split('.');
    for (let i = 0; i < keys.length; i++) {
      obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {};
    }
    return typeof obj === 'object' && obj !== null ? Object.keys(obj).length ? obj : undefined : obj;
  };
  var Settings = {
    get(type, key) {
      let fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      const val = dotGrab(settings[type], key);
      return val !== undefined ? val : fallback;
    },
    has(type, key) {
      return !!this.get(type, key);
    },
    set(key, value) {
      settings['user'][key] = value;
      publish(key, value);
    },
    subscribe(key, callback) {
      subscribers[key] = subscribers[key] || [];
      subscribers[key].push(callback);
    },
    unsubscribe(key, callback) {
      if (callback) {
        const index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback);
        index > -1 && subscribers[key].splice(index, 1);
      } else {
        if (key in subscribers) {
          subscribers[key] = [];
        }
      }
    },
    clearSubscribers() {
      for (const key of Object.getOwnPropertyNames(subscribers)) {
        delete subscribers[key];
      }
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const prepLog = (type, args) => {
    const colors = {
      Info: 'green',
      Debug: 'gray',
      Warn: 'orange',
      Error: 'red'
    };
    args = Array.from(args);
    return ['%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type), 'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px', args];
  };
  var Log = {
    info() {
      Settings.get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments));
    },
    debug() {
      Settings.get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments));
    },
    error() {
      Settings.get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments));
    },
    warn() {
      Settings.get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments));
    }
  };

  var executeAsPromise = (function (method) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let result;
    if (method && typeof method === 'function') {
      try {
        result = method.apply(context, args);
      } catch (e) {
        result = e;
      }
    } else {
      result = method;
    }

    // if it looks like a duck .. ehm ... promise and talks like a promise, let's assume it's a promise
    if (result !== null && typeof result === 'object' && result.then && typeof result.then === 'function') {
      return result;
    }
    // otherwise make it into a promise
    else {
      return new Promise((resolve, reject) => {
        if (result instanceof Error) {
          reject(result);
        } else {
          resolve(result);
        }
      });
    }
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let sendMetric = (type, event, params) => {
    Log.info('Sending metric', type, event, params);
  };
  const initMetrics = config => {
    sendMetric = config.sendMetric;
  };

  // available metric per category
  const metrics$1 = {
    app: ['launch', 'loaded', 'ready', 'close'],
    page: ['view', 'leave'],
    user: ['click', 'input'],
    media: ['abort', 'canplay', 'ended', 'pause', 'play',
    // with some videos there occur almost constant suspend events ... should investigate
    // 'suspend',
    'volumechange', 'waiting', 'seeking', 'seeked']
  };

  // error metric function (added to each category)
  const errorMetric = function (type, message, code, visible) {
    let params = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    params = {
      params,
      ...{
        message,
        code,
        visible
      }
    };
    sendMetric(type, 'error', params);
  };
  const Metric = function (type, events) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return events.reduce((obj, event) => {
      obj[event] = function (name) {
        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        params = {
          ...options,
          ...(name ? {
            name
          } : {}),
          ...params
        };
        sendMetric(type, event, params);
      };
      return obj;
    }, {
      error(message, code, params) {
        errorMetric(type, message, code, params);
      },
      event(name, params) {
        sendMetric(type, name, params);
      }
    });
  };
  const Metrics = types => {
    return Object.keys(types).reduce((obj, type) => {
      // media metric works a bit different!
      // it's a function that accepts a url and returns an object with the available metrics
      // url is automatically passed as a param in every metric
      type === 'media' ? obj[type] = url => Metric(type, types[type], {
        url
      }) : obj[type] = Metric(type, types[type]);
      return obj;
    }, {
      error: errorMetric,
      event: sendMetric
    });
  };
  var Metrics$1 = Metrics(metrics$1);

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var events$1 = {
    abort: 'Abort',
    canplay: 'CanPlay',
    canplaythrough: 'CanPlayThrough',
    durationchange: 'DurationChange',
    emptied: 'Emptied',
    encrypted: 'Encrypted',
    ended: 'Ended',
    error: 'Error',
    interruptbegin: 'InterruptBegin',
    interruptend: 'InterruptEnd',
    loadeddata: 'LoadedData',
    loadedmetadata: 'LoadedMetadata',
    loadstart: 'LoadStart',
    pause: 'Pause',
    play: 'Play',
    playing: 'Playing',
    progress: 'Progress',
    ratechange: 'Ratechange',
    seeked: 'Seeked',
    seeking: 'Seeking',
    stalled: 'Stalled',
    // suspend: 'Suspend', // this one is called a looooot for some videos
    timeupdate: 'TimeUpdate',
    volumechange: 'VolumeChange',
    waiting: 'Waiting'
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var autoSetupMixin = (function (sourceObject) {
    let setup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
    let ready = false;
    const doSetup = () => {
      if (ready === false) {
        setup();
        ready = true;
      }
    };
    return Object.keys(sourceObject).reduce((obj, key) => {
      if (typeof sourceObject[key] === 'function') {
        obj[key] = function () {
          doSetup();
          return sourceObject[key].apply(sourceObject, arguments);
        };
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === 'function') {
        obj.__defineGetter__(key, function () {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject);
        });
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === 'function') {
        obj.__defineSetter__(key, function () {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(sourceObject, arguments);
        });
      } else {
        obj[key] = sourceObject[key];
      }
      return obj;
    }, {});
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let timeout$1 = null;
  var easeExecution = ((cb, delay) => {
    clearTimeout(timeout$1);
    timeout$1 = setTimeout(() => {
      cb();
    }, delay);
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let basePath;
  let proxyUrl;
  const initUtils = config => {
    basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config.path || '/'));
    if (config.proxyUrl) {
      proxyUrl = ensureUrlWithProtocol(config.proxyUrl);
    }
  };
  var Utils = {
    asset(relPath) {
      return basePath + relPath;
    },
    proxyUrl(url) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return proxyUrl ? proxyUrl + '?' + makeQueryString(url, options) : url;
    },
    makeQueryString() {
      return makeQueryString(...arguments);
    },
    // since imageworkers don't work without protocol
    ensureUrlWithProtocol() {
      return ensureUrlWithProtocol(...arguments);
    }
  };
  const ensureUrlWithProtocol = url => {
    if (/^\/\//.test(url)) {
      return window.location.protocol + url;
    }
    if (!/^(?:https?:)/i.test(url)) {
      return window.location.origin + url;
    }
    return url;
  };
  const makeFullStaticPath = function () {
    let pathname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';
    let path = arguments.length > 1 ? arguments[1] : undefined;
    // ensure path has traling slash
    path = path.charAt(path.length - 1) !== '/' ? path + '/' : path;

    // if path is URL, we assume it's already the full static path, so we just return it
    if (/^(?:https?:)?(?:\/\/)/.test(path)) {
      return path;
    }
    if (path.charAt(0) === '/') {
      return path;
    } else {
      // cleanup the pathname (i.e. remove possible index.html)
      pathname = cleanUpPathName(pathname);

      // remove possible leading dot from path
      path = path.charAt(0) === '.' ? path.substr(1) : path;
      // ensure path has leading slash
      path = path.charAt(0) !== '/' ? '/' + path : path;
      return pathname + path;
    }
  };
  const cleanUpPathName = pathname => {
    if (pathname.slice(-1) === '/') return pathname.slice(0, -1);
    const parts = pathname.split('/');
    if (parts[parts.length - 1].indexOf('.') > -1) parts.pop();
    return parts.join('/');
  };
  const makeQueryString = function (url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'url';
    // add operator as an option
    options.operator = 'metrological'; // Todo: make this configurable (via url?)
    // add type (= url or qr) as an option, with url as the value
    options[type] = url;
    return Object.keys(options).map(key => {
      return encodeURIComponent(key) + '=' + encodeURIComponent('' + options[key]);
    }).join('&');
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const initProfile = config => {
    config.getInfo;
    config.setInfo;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var lng$1 = window.lng;

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const events = ['timeupdate', 'error', 'ended', 'loadeddata', 'canplay', 'play', 'playing', 'pause', 'loadstart', 'seeking', 'seeked', 'encrypted'];
  let mediaUrl$1 = url => url;
  const initMediaPlayer = config => {
    if (config.mediaUrl) {
      mediaUrl$1 = config.mediaUrl;
    }
  };
  class Mediaplayer extends lng$1.Component {
    _construct() {
      this._skipRenderToTexture = false;
      this._metrics = null;
      this._textureMode = Settings.get('platform', 'textureMode') || false;
      Log.info('Texture mode: ' + this._textureMode);
      console.warn(["The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.", "Please consider using the new 'VideoPlayer'-plugin instead.", 'https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer'].join('\n\n'));
    }
    static _template() {
      return {
        Video: {
          VideoWrap: {
            VideoTexture: {
              visible: false,
              pivot: 0.5,
              texture: {
                type: lng$1.textures.StaticTexture,
                options: {}
              }
            }
          }
        }
      };
    }
    set skipRenderToTexture(v) {
      this._skipRenderToTexture = v;
    }
    get textureMode() {
      return this._textureMode;
    }
    get videoView() {
      return this.tag('Video');
    }
    _init() {
      //re-use videotag if already there
      const videoEls = document.getElementsByTagName('video');
      if (videoEls && videoEls.length > 0) this.videoEl = videoEls[0];else {
        this.videoEl = document.createElement('video');
        this.videoEl.setAttribute('id', 'video-player');
        this.videoEl.style.position = 'absolute';
        this.videoEl.style.zIndex = '1';
        this.videoEl.style.display = 'none';
        this.videoEl.setAttribute('width', '100%');
        this.videoEl.setAttribute('height', '100%');
        this.videoEl.style.visibility = this.textureMode ? 'hidden' : 'visible';
        document.body.appendChild(this.videoEl);
      }
      if (this.textureMode && !this._skipRenderToTexture) {
        this._createVideoTexture();
      }
      this.eventHandlers = [];
    }
    _registerListeners() {
      events.forEach(event => {
        const handler = e => {
          if (this._metrics && this._metrics[event] && typeof this._metrics[event] === 'function') {
            this._metrics[event]({
              currentTime: this.videoEl.currentTime
            });
          }
          this.fire(event, {
            videoElement: this.videoEl,
            event: e
          });
        };
        this.eventHandlers.push(handler);
        this.videoEl.addEventListener(event, handler);
      });
    }
    _deregisterListeners() {
      Log.info('Deregistering event listeners MediaPlayer');
      events.forEach((event, index) => {
        this.videoEl.removeEventListener(event, this.eventHandlers[index]);
      });
      this.eventHandlers = [];
    }
    _attach() {
      this._registerListeners();
    }
    _detach() {
      this._deregisterListeners();
      this.close();
    }
    _createVideoTexture() {
      const stage = this.stage;
      const gl = stage.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.videoTexture.options = {
        source: glTexture,
        w: this.videoEl.width,
        h: this.videoEl.height
      };
    }
    _startUpdatingVideoTexture() {
      if (this.textureMode && !this._skipRenderToTexture) {
        const stage = this.stage;
        if (!this._updateVideoTexture) {
          this._updateVideoTexture = () => {
            if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
              const gl = stage.gl;
              const currentTime = new Date().getTime();

              // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
              // We'll fallback to fixed 30fps in this case.
              const frameCount = this.videoEl.webkitDecodedFrameCount;
              const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
              if (mustUpdate) {
                this._lastTime = currentTime;
                this._lastFrame = frameCount;
                try {
                  gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                  this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                  this.videoTextureView.visible = true;
                  this.videoTexture.options.w = this.videoEl.videoWidth;
                  this.videoTexture.options.h = this.videoEl.videoHeight;
                  const expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h;
                  const realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight;
                  if (expectedAspectRatio > realAspectRatio) {
                    this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio;
                    this.videoTextureView.scaleY = 1;
                  } else {
                    this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio;
                    this.videoTextureView.scaleX = 1;
                  }
                } catch (e) {
                  Log.error('texImage2d video', e);
                  this._stopUpdatingVideoTexture();
                  this.videoTextureView.visible = false;
                }
                this.videoTexture.source.forceRenderUpdate();
              }
            }
          };
        }
        if (!this._updatingVideoTexture) {
          stage.on('frameStart', this._updateVideoTexture);
          this._updatingVideoTexture = true;
        }
      }
    }
    _stopUpdatingVideoTexture() {
      if (this.textureMode) {
        const stage = this.stage;
        stage.removeListener('frameStart', this._updateVideoTexture);
        this._updatingVideoTexture = false;
        this.videoTextureView.visible = false;
        if (this.videoTexture.options.source) {
          const gl = stage.gl;
          gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
      }
    }
    updateSettings() {
      let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // The Component that 'consumes' the media player.
      this._consumer = settings.consumer;
      if (this._consumer && this._consumer.getMediaplayerSettings) {
        // Allow consumer to add settings.
        settings = Object.assign(settings, this._consumer.getMediaplayerSettings());
      }
      if (!lng$1.Utils.equalValues(this._stream, settings.stream)) {
        if (settings.stream && settings.stream.keySystem) {
          navigator.requestMediaKeySystemAccess(settings.stream.keySystem.id, settings.stream.keySystem.config).then(keySystemAccess => {
            return keySystemAccess.createMediaKeys();
          }).then(createdMediaKeys => {
            return this.videoEl.setMediaKeys(createdMediaKeys);
          }).then(() => {
            if (settings.stream && settings.stream.src) this.open(settings.stream.src);
          }).catch(() => {
            console.error('Failed to set up MediaKeys');
          });
        } else if (settings.stream && settings.stream.src) {
          // This is here to be backwards compatible, will be removed
          // in future sdk release
          if (Settings.get('app', 'hls')) {
            if (!window.Hls) {
              window.Hls = class Hls {
                static isSupported() {
                  console.warn('hls-light not included');
                  return false;
                }
              };
            }
            if (window.Hls.isSupported()) {
              if (!this._hls) this._hls = new window.Hls({
                liveDurationInfinity: true
              });
              this._hls.loadSource(settings.stream.src);
              this._hls.attachMedia(this.videoEl);
              this.videoEl.style.display = 'block';
            }
          } else {
            this.open(settings.stream.src);
          }
        } else {
          this.close();
        }
        this._stream = settings.stream;
      }
      this._setHide(settings.hide);
      this._setVideoArea(settings.videoPos);
    }
    _setHide(hide) {
      if (this.textureMode) {
        this.tag('Video').setSmooth('alpha', hide ? 0 : 1);
      } else {
        this.videoEl.style.visibility = hide ? 'hidden' : 'visible';
      }
    }
    open(url) {
      let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        hide: false,
        videoPosition: null
      };
      // prep the media url to play depending on platform (mediaPlayerplugin)
      url = mediaUrl$1(url);
      this._metrics = Metrics$1.media(url);
      Log.info('Playing stream', url);
      if (this.application.noVideo) {
        Log.info('noVideo option set, so ignoring: ' + url);
        return;
      }
      // close the video when opening same url as current (effectively reloading)
      if (this.videoEl.getAttribute('src') === url) {
        this.close();
      }
      this.videoEl.setAttribute('src', url);

      // force hide, then force show (in next tick!)
      // (fixes comcast playback rollover issue)
      this.videoEl.style.visibility = 'hidden';
      this.videoEl.style.display = 'none';
      setTimeout(() => {
        this.videoEl.style.display = 'block';
        this.videoEl.style.visibility = 'visible';
      });
      this._setHide(settings.hide);
      this._setVideoArea(settings.videoPosition || [0, 0, 1920, 1080]);
    }
    close() {
      // We need to pause first in order to stop sound.
      this.videoEl.pause();
      this.videoEl.removeAttribute('src');

      // force load to reset everything without errors
      this.videoEl.load();
      this._clearSrc();
      this.videoEl.style.display = 'none';
    }
    playPause() {
      if (this.isPlaying()) {
        this.doPause();
      } else {
        this.doPlay();
      }
    }
    get muted() {
      return this.videoEl.muted;
    }
    set muted(v) {
      this.videoEl.muted = v;
    }
    get loop() {
      return this.videoEl.loop;
    }
    set loop(v) {
      this.videoEl.loop = v;
    }
    isPlaying() {
      return this._getState() === 'Playing';
    }
    doPlay() {
      this.videoEl.play();
    }
    doPause() {
      this.videoEl.pause();
    }
    reload() {
      var url = this.videoEl.getAttribute('src');
      this.close();
      this.videoEl.src = url;
    }
    getPosition() {
      return Promise.resolve(this.videoEl.currentTime);
    }
    setPosition(pos) {
      this.videoEl.currentTime = pos;
    }
    getDuration() {
      return Promise.resolve(this.videoEl.duration);
    }
    seek(time) {
      let absolute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (absolute) {
        this.videoEl.currentTime = time;
      } else {
        this.videoEl.currentTime += time;
      }
    }
    get videoTextureView() {
      return this.tag('Video').tag('VideoTexture');
    }
    get videoTexture() {
      return this.videoTextureView.texture;
    }
    _setVideoArea(videoPos) {
      if (lng$1.Utils.equalValues(this._videoPos, videoPos)) {
        return;
      }
      this._videoPos = videoPos;
      if (this.textureMode) {
        this.videoTextureView.patch({
          smooth: {
            x: videoPos[0],
            y: videoPos[1],
            w: videoPos[2] - videoPos[0],
            h: videoPos[3] - videoPos[1]
          }
        });
      } else {
        const precision = this.stage.getRenderPrecision();
        this.videoEl.style.left = Math.round(videoPos[0] * precision) + 'px';
        this.videoEl.style.top = Math.round(videoPos[1] * precision) + 'px';
        this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * precision) + 'px';
        this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * precision) + 'px';
      }
    }
    _fireConsumer(event, args) {
      if (this._consumer) {
        this._consumer.fire(event, args);
      }
    }
    _equalInitData(buf1, buf2) {
      if (!buf1 || !buf2) return false;
      if (buf1.byteLength != buf2.byteLength) return false;
      const dv1 = new Int8Array(buf1);
      const dv2 = new Int8Array(buf2);
      for (let i = 0; i != buf1.byteLength; i++) if (dv1[i] != dv2[i]) return false;
      return true;
    }
    error(args) {
      this._fireConsumer('$mediaplayerError', args);
      this._setState('');
      return '';
    }
    loadeddata(args) {
      this._fireConsumer('$mediaplayerLoadedData', args);
    }
    play(args) {
      this._fireConsumer('$mediaplayerPlay', args);
    }
    playing(args) {
      this._fireConsumer('$mediaplayerPlaying', args);
      this._setState('Playing');
    }
    canplay(args) {
      this.videoEl.play();
      this._fireConsumer('$mediaplayerStart', args);
    }
    loadstart(args) {
      this._fireConsumer('$mediaplayerLoad', args);
    }
    seeked() {
      this._fireConsumer('$mediaplayerSeeked', {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1
      });
    }
    seeking() {
      this._fireConsumer('$mediaplayerSeeking', {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1
      });
    }
    durationchange(args) {
      this._fireConsumer('$mediaplayerDurationChange', args);
    }
    encrypted(args) {
      const video = args.videoElement;
      const event = args.event;
      // FIXME: Double encrypted events need to be properly filtered by Gstreamer
      if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
        this._previousInitData = event.initData;
        this._fireConsumer('$mediaplayerEncrypted', args);
      }
    }
    static _states() {
      return [class Playing extends this {
        $enter() {
          this._startUpdatingVideoTexture();
        }
        $exit() {
          this._stopUpdatingVideoTexture();
        }
        timeupdate() {
          this._fireConsumer('$mediaplayerProgress', {
            currentTime: this.videoEl.currentTime,
            duration: this.videoEl.duration || 1
          });
        }
        ended(args) {
          this._fireConsumer('$mediaplayerEnded', args);
          this._setState('');
        }
        pause(args) {
          this._fireConsumer('$mediaplayerPause', args);
          this._setState('Playing.Paused');
        }
        _clearSrc() {
          this._fireConsumer('$mediaplayerStop', {});
          this._setState('');
        }
        static _states() {
          return [class Paused extends this {}];
        }
      }];
    }
  }

  class localCookie {
    constructor(e) {
      return e = e || {}, this.forceCookies = e.forceCookies || !1, !0 === this._checkIfLocalStorageWorks() && !0 !== e.forceCookies ? {
        getItem: this._getItemLocalStorage,
        setItem: this._setItemLocalStorage,
        removeItem: this._removeItemLocalStorage,
        clear: this._clearLocalStorage,
        keys: this._getLocalStorageKeys
      } : {
        getItem: this._getItemCookie,
        setItem: this._setItemCookie,
        removeItem: this._removeItemCookie,
        clear: this._clearCookies,
        keys: this._getCookieKeys
      };
    }
    _checkIfLocalStorageWorks() {
      if ("undefined" == typeof localStorage) return !1;
      try {
        return localStorage.setItem("feature_test", "yes"), "yes" === localStorage.getItem("feature_test") && (localStorage.removeItem("feature_test"), !0);
      } catch (e) {
        return !1;
      }
    }
    _getItemLocalStorage(e) {
      return window.localStorage.getItem(e);
    }
    _setItemLocalStorage(e, t) {
      return window.localStorage.setItem(e, t);
    }
    _removeItemLocalStorage(e) {
      return window.localStorage.removeItem(e);
    }
    _clearLocalStorage() {
      return window.localStorage.clear();
    }
    _getLocalStorageKeys() {
      return Object.keys(window.localStorage);
    }
    _getItemCookie(e) {
      var t = document.cookie.match(RegExp("(?:^|;\\s*)" + function (e) {
        return e.replace(/([.*+?\^${}()|\[\]\/\\])/g, "\\$1");
      }(e) + "=([^;]*)"));
      return t && "" === t[1] && (t[1] = null), t ? t[1] : null;
    }
    _setItemCookie(e, t) {
      var o = new Date(),
        r = new Date(o.getTime() + 15768e7);
      document.cookie = "".concat(e, "=").concat(t, "; expires=").concat(r.toUTCString(), ";");
    }
    _removeItemCookie(e) {
      document.cookie = "".concat(e, "=;Max-Age=-99999999;");
    }
    _clearCookies() {
      document.cookie.split(";").forEach(e => {
        document.cookie = e.replace(/^ +/, "").replace(/=.*/, "=;expires=Max-Age=-99999999");
      });
    }
    _getCookieKeys() {
      return document.cookie.split(";").map(e => e.split("=")[0]);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let namespace;
  let lc;
  const initStorage = () => {
    namespace = Settings.get('platform', 'id');
    // todo: pass options (for example to force the use of cookies)
    lc = new localCookie();
  };
  const namespacedKey = key => namespace ? [namespace, key].join('.') : key;
  var Storage = {
    get(key) {
      try {
        return JSON.parse(lc.getItem(namespacedKey(key)));
      } catch (e) {
        return null;
      }
    },
    set(key, value) {
      try {
        lc.setItem(namespacedKey(key), JSON.stringify(value));
        return true;
      } catch (e) {
        return false;
      }
    },
    remove(key) {
      lc.removeItem(namespacedKey(key));
    },
    clear() {
      if (namespace) {
        lc.keys().forEach(key => {
          // remove the item if in the namespace
          key.indexOf(namespace + '.') === 0 ? lc.removeItem(key) : null;
        });
      } else {
        lc.clear();
      }
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g;
  const isWildcard = /^[!*$]$/;
  const hasLookupId = /\/:\w+?@@([0-9]+?)@@/;
  const isNamedGroup = /^\/:/;

  /**
   * Test if a route is part regular expressed
   * and replace it for a simple character
   * @param route
   * @returns {*}
   */
  const stripRegex = function (route) {
    let char = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'R';
    // if route is part regular expressed we replace
    // the regular expression for a character to
    // simplify floor calculation and backtracking
    if (hasRegex.test(route)) {
      route = route.replace(hasRegex, char);
    }
    return route;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Create a local request register
   * @param flags
   * @returns {Map<any, any>}
   */
  const createRegister = flags => {
    const reg = new Map()
    // store user defined and router
    // defined flags in register
    ;
    [...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach(key => {
      reg.set(key, flags[key]);
    });
    return reg;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Request {
    constructor() {
      let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      let navArgs = arguments.length > 1 ? arguments[1] : undefined;
      let storeCaller = arguments.length > 2 ? arguments[2] : undefined;
      /**
       * Hash we navigate to
       * @type {string}
       * @private
       */
      this._hash = hash;

      /**
       * Do we store previous hash in history
       * @type {boolean}
       * @private
       */
      this._storeCaller = storeCaller;

      /**
       * Request and navigate data
       * @type {Map}
       * @private
       */
      this._register = new Map();

      /**
       * Flag if the instance is created due to
       * this request
       * @type {boolean}
       * @private
       */
      this._isCreated = false;

      /**
       * Flag if the instance is shared between
       * previous and current request
       * @type {boolean}
       * @private
       */
      this._isSharedInstance = false;

      /**
       * Flag if the request has been cancelled
       * @type {boolean}
       * @private
       */
      this._cancelled = false;

      /**
       * if instance is shared between requests we copy state object
       * from instance before the new request overrides state
       * @type {null}
       * @private
       */
      this._copiedHistoryState = null;

      // if there are arguments attached to navigate()
      // we store them in new request
      if (isObject(navArgs)) {
        this._register = createRegister(navArgs);
      } else if (isBoolean(navArgs)) {
        // if second navigate() argument is explicitly
        // set to false we prevent the calling page
        // from ending up in history
        this._storeCaller = navArgs;
      }
      // @todo: remove because we can simply check
      // ._storeCaller property
      this._register.set(symbols.store, this._storeCaller);
    }
    cancel() {
      Log.debug('[router]:', "cancelled ".concat(this._hash));
      this._cancelled = true;
    }
    get url() {
      return this._hash;
    }
    get register() {
      return this._register;
    }
    get hash() {
      return this._hash;
    }
    set hash(args) {
      this._hash = args;
    }
    get route() {
      return this._route;
    }
    set route(args) {
      this._route = args;
    }
    get provider() {
      return this._provider;
    }
    set provider(args) {
      this._provider = args;
    }
    get providerType() {
      return this._providerType;
    }
    set providerType(args) {
      this._providerType = args;
    }
    set page(args) {
      this._page = args;
    }
    get page() {
      return this._page;
    }
    set isCreated(args) {
      this._isCreated = args;
    }
    get isCreated() {
      return this._isCreated;
    }
    get isSharedInstance() {
      return this._isSharedInstance;
    }
    set isSharedInstance(args) {
      this._isSharedInstance = args;
    }
    get isCancelled() {
      return this._cancelled;
    }
    set copiedHistoryState(v) {
      this._copiedHistoryState = v;
    }
    get copiedHistoryState() {
      return this._copiedHistoryState;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Route {
    constructor() {
      let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // keep backwards compatible
      let type = ['on', 'before', 'after'].reduce((acc, type) => {
        return isFunction(config[type]) ? type : acc;
      }, undefined);
      this._cfg = config;
      if (type) {
        this._provider = {
          type,
          request: config[type]
        };
      }
    }
    get path() {
      return this._cfg.path;
    }
    get component() {
      return this._cfg.component;
    }
    get options() {
      return this._cfg.options;
    }
    get widgets() {
      return this._cfg.widgets;
    }
    get cache() {
      return this._cfg.cache;
    }
    get hook() {
      return this._cfg.hook;
    }
    get beforeNavigate() {
      return this._cfg.beforeNavigate;
    }
    get provider() {
      return this._provider;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Simple route length calculation
   * @param route {string}
   * @returns {number} - floor
   */
  const getFloor = route => {
    return stripRegex(route).split('/').length;
  };

  /**
   * return all stored routes that live on the same floor
   * @param floor
   * @returns {Array}
   */
  const getRoutesByFloor = floor => {
    const matches = [];
    // simple filter of level candidates
    for (let [route] of routes$1.entries()) {
      if (getFloor(route) === floor) {
        matches.push(route);
      }
    }
    return matches;
  };

  /**
   * return a matching route by provided hash
   * hash: home/browse/12 will match:
   * route: home/browse/:categoryId
   * @param hash {string}
   * @returns {boolean|{}} - route
   */
  const getRouteByHash = hash => {
    // @todo: clean up on handleHash
    hash = hash.replace(/^#/, '');
    const getUrlParts = /(\/?:?[^/]+)/g;
    // grab possible candidates from stored routes
    const candidates = getRoutesByFloor(getFloor(hash));
    // break hash down in chunks
    const hashParts = hash.match(getUrlParts) || [];

    // to simplify the route matching and prevent look around
    // in our getUrlParts regex we get the regex part from
    // route candidate and store them so that we can reference
    // them when we perform the actual regex against hash
    let regexStore = [];
    let matches = candidates.filter(route => {
      let isMatching = true;
      // replace regex in route with lookup id => @@{storeId}@@
      if (hasRegex.test(route)) {
        const regMatches = route.match(hasRegex);
        if (regMatches && regMatches.length) {
          route = regMatches.reduce((fullRoute, regex) => {
            const lookupId = regexStore.length;
            fullRoute = fullRoute.replace(regex, "@@".concat(lookupId, "@@"));
            regexStore.push(regex.substring(1, regex.length - 1));
            return fullRoute;
          }, route);
        }
      }
      const routeParts = route.match(getUrlParts) || [];
      for (let i = 0, j = routeParts.length; i < j; i++) {
        const routePart = routeParts[i];
        const hashPart = hashParts[i];

        // Since we support catch-all and regex driven name groups
        // we first test for regex lookup id and see if the regex
        // matches the value from the hash
        if (hasLookupId.test(routePart)) {
          const routeMatches = hasLookupId.exec(routePart);
          const storeId = routeMatches[1];
          const routeRegex = regexStore[storeId];

          // split regex and modifiers so we can use both
          // to create a new RegExp
          // eslint-disable-next-line
          const regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex);
          if (regMatches && regMatches.length) {
            const expression = regMatches[1];
            const modifiers = regMatches[2];
            const regex = new RegExp("^/".concat(expression, "$"), modifiers);
            if (!regex.test(hashPart)) {
              isMatching = false;
            }
          }
        } else if (isNamedGroup.test(routePart)) {
          // we kindly skip namedGroups because this is dynamic
          // we only need to the static and regex drive parts
          continue;
        } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
          isMatching = false;
        }
      }
      return isMatching;
    });
    if (matches.length) {
      if (matches.indexOf(hash) !== -1) {
        const match = matches[matches.indexOf(hash)];
        return routes$1.get(match);
      } else {
        // we give prio to static routes over dynamic
        matches = matches.sort(a => {
          return isNamedGroup.test(a) ? -1 : 1;
        });
        // would be strange if this fails
        // but still we test
        if (routeExists(matches[0])) {
          return routes$1.get(matches[0]);
        }
      }
    }
    return false;
  };
  const getValuesFromHash = function () {
    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let path = arguments.length > 1 ? arguments[1] : undefined;
    // replace the regex definition from the route because
    // we already did the matching part
    path = stripRegex(path, '');
    const getUrlParts = /(\/?:?[\w%\s:.-]+)/g;
    const hashParts = hash.match(getUrlParts) || [];
    const routeParts = path.match(getUrlParts) || [];
    const getNamedGroup = /^\/:([\w-]+)\/?/;
    return routeParts.reduce((storage, value, index) => {
      const match = getNamedGroup.exec(value);
      if (match && match.length) {
        storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, '')));
      }
      return storage;
    }, new Map());
  };
  const getOption = (stack, prop) => {
    // eslint-disable-next-line
    if (stack && stack.hasOwnProperty(prop)) {
      return stack[prop];
    }
    // we explicitly return undefined since we're testing
    // for explicit test values
  };

  /**
   * create and return new Route instance
   * @param config
   */
  const createRoute = config => {
    // we need to provide a bit of additional logic
    // for the bootComponent
    if (config.path === '$') {
      let options = {
        preventStorage: true
      };
      if (isObject(config.options)) {
        options = {
          ...config.options,
          ...options
        };
      }
      config.options = options;
      // if configured add reference to bootRequest
      // as router after provider
      if (bootRequest) {
        config.after = bootRequest;
      }
    }
    return new Route(config);
  };

  /**
   * Create a new Router request object
   * @param url
   * @param args
   * @param store
   * @returns {*}
   */
  const createRequest = (url, args, store) => {
    return new Request(url, args, store);
  };
  const getHashByName = obj => {
    if (!obj.to && !obj.name) {
      return false;
    }
    const route = getRouteByName(obj.to || obj.name);
    const hasDynamicGroup = /\/:([\w-]+)\/?/;
    let hash = route;

    // if route contains dynamic group
    // we replace them with the provided params
    if (hasDynamicGroup.test(route)) {
      if (obj.params) {
        const keys = Object.keys(obj.params);
        hash = keys.reduce((acc, key) => {
          return acc.replace(":".concat(key), obj.params[key]);
        }, route);
      }
      if (obj.query) {
        return "".concat(hash).concat(objectToQueryString(obj.query));
      }
    }
    return hash;
  };
  const getRouteByName = name => {
    for (let [path, route] of routes$1.entries()) {
      if (route.name === name) {
        return path;
      }
    }
    return false;
  };
  const keepActivePageAlive = (route, request) => {
    if (isString(route)) {
      const routes = getRoutes();
      if (routes.has(route)) {
        route = routes.get(route);
      } else {
        return false;
      }
    }
    const register = request.register;
    const routeOptions = route.options;
    if (register.has('keepAlive')) {
      return register.get('keepAlive');
    } else if (routeOptions && routeOptions.keepAlive) {
      return routeOptions.keepAlive;
    }
    return false;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var emit$1 = (function (page) {
    let events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!isArray(events)) {
      events = [events];
    }
    events.forEach(e => {
      const event = "_on".concat(ucfirst(e));
      if (isFunction(page[event])) {
        page[event](params);
      }
    });
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let activeWidget = null;
  const getReferences = () => {
    if (!widgetsHost) {
      return;
    }
    return widgetsHost.get().reduce((storage, widget) => {
      const key = widget.ref.toLowerCase();
      storage[key] = widget;
      return storage;
    }, {});
  };

  /**
   * update the visibility of the available widgets
   * for the current page / route
   * @param page
   */
  const updateWidgets = (widgets, page) => {
    // force lowercase lookup
    const configured = (widgets || []).map(ref => ref.toLowerCase());
    widgetsHost.forEach(widget => {
      widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1;
      if (widget.visible) {
        emit$1(widget, ['activated'], page);
      }
    });
    if (app.state === 'Widgets' && activeWidget && !activeWidget.visible) {
      app._setState('');
    }
  };
  const getWidgetByName = name => {
    name = ucfirst(name);
    return widgetsHost.getByRef(name) || false;
  };

  /**
   * delegate app focus to a on-screen widget
   * @param name - {string}
   */
  const focusWidget = name => {
    const widget = getWidgetByName(name);
    if (widget) {
      setActiveWidget(widget);

      // if app is already in 'Widgets' state we can assume that
      // focus has been delegated from one widget to another so
      // we need to set the new widget reference and trigger a
      // new focus calculation of Lightning's focuspath
      if (app.state === 'Widgets') {
        app.reload(activeWidget);
      } else {
        app._setState('Widgets', [activeWidget]);
      }
    }
  };
  const restoreFocus = () => {
    activeWidget = null;
    app._setState('');
  };
  const getActiveWidget = () => {
    return activeWidget;
  };
  const setActiveWidget = instance => {
    activeWidget = instance;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const createComponent = (stage, type) => {
    return stage.c({
      type,
      visible: false,
      widgets: getReferences()
    });
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Simple flat array that holds the visited hashes + state Object
   * so the router can navigate back to them
   * @type {Array}
   */
  let history = [];
  const updateHistory = request => {
    const hash = getActiveHash();
    if (!hash) {
      return;
    }

    // navigate storage flag
    const register = request.register;
    const forceNavigateStore = register.get(symbols.store);

    // test preventStorage on route configuration
    const activeRoute = getRouteByHash(hash);
    const preventStorage = getOption(activeRoute.options, 'preventStorage');

    // we give prio to navigate storage flag
    let store = isBoolean(forceNavigateStore) ? forceNavigateStore : !preventStorage;
    if (store) {
      const toStore = hash.replace(/^\//, '');
      const location = locationInHistory(toStore);
      const stateObject = getStateObject(getActivePage(), request);
      const routerConfig = getRouterConfig();

      // store hash if it's not a part of history or flag for
      // storage of same hash is true
      if (location === -1 || routerConfig.get('storeSameHash')) {
        history.push({
          hash: toStore,
          state: stateObject
        });
      } else {
        // if we visit the same route we want to sync history
        const prev = history.splice(location, 1)[0];
        history.push({
          hash: prev.hash,
          state: stateObject
        });
      }
    }
  };
  const locationInHistory = hash => {
    for (let i = 0; i < history.length; i++) {
      if (history[i].hash === hash) {
        return i;
      }
    }
    return -1;
  };
  const getHistoryState = hash => {
    let state = null;
    if (history.length) {
      // if no hash is provided we get the last
      // pushed history record
      if (!hash) {
        const record = history[history.length - 1];
        // could be null
        state = record.state;
      } else {
        if (locationInHistory(hash) !== -1) {
          const record = history[locationInHistory(hash)];
          state = record.state;
        }
      }
    }
    return state;
  };
  const replaceHistoryState = function () {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let hash = arguments.length > 1 ? arguments[1] : undefined;
    if (!history.length) {
      return;
    }
    const location = hash ? locationInHistory(hash) : history.length - 1;
    if (location !== -1 && isObject(state)) {
      history[location].state = state;
    }
  };
  const getStateObject = (page, request) => {
    // if the new request shared instance with the
    // previous request we used the copied state object
    if (request.isSharedInstance) {
      if (request.copiedHistoryState) {
        return request.copiedHistoryState;
      }
    } else if (page && isFunction(page.historyState)) {
      return page.historyState();
    }
    return null;
  };
  const getHistory = () => {
    return history.slice(0);
  };
  const setHistory = function () {
    let arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    if (isArray(arr)) {
      history = arr;
    }
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === 'object';
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function (element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
      return target.propertyIsEnumerable(symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }

  // Protects from prototype poisoning and unexpected merging up the prototype chain.
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
  }

  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function (key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function (key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error('first argument should be an array');
    }
    return array.reduce(function (prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  var cjs = deepmerge_1;

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let warned = false;
  const deprecated = function () {
    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (force === true || warned === false) {
      console.warn(["The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.", "Please consider using the new 'Language'-plugin instead.", 'https://rdkcentral.github.io/Lightning-SDK/#/plugins/language'].join('\n\n'));
    }
    warned = true;
  };
  class Locale {
    constructor() {
      this.__enabled = false;
    }

    /**
     * Loads translation object from external json file.
     *
     * @param {String} path Path to resource.
     * @return {Promise}
     */
    async load(path) {
      if (!this.__enabled) {
        return;
      }
      await fetch(path).then(resp => resp.json()).then(resp => {
        this.loadFromObject(resp);
      });
    }

    /**
     * Sets language used by module.
     *
     * @param {String} lang
     */
    setLanguage(lang) {
      deprecated();
      this.__enabled = true;
      this.language = lang;
    }

    /**
     * Returns reference to translation object for current language.
     *
     * @return {Object}
     */
    get tr() {
      deprecated(true);
      return this.__trObj[this.language];
    }

    /**
     * Loads translation object from existing object (binds existing object).
     *
     * @param {Object} trObj
     */
    loadFromObject(trObj) {
      deprecated();
      const fallbackLanguage = 'en';
      if (Object.keys(trObj).indexOf(this.language) === -1) {
        Log.warn('No translations found for: ' + this.language);
        if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
          Log.warn('Using fallback language: ' + fallbackLanguage);
          this.language = fallbackLanguage;
        } else {
          const error = 'No translations found for fallback language: ' + fallbackLanguage;
          Log.error(error);
          throw Error(error);
        }
      }
      this.__trObj = trObj;
      for (const lang of Object.values(this.__trObj)) {
        for (const str of Object.keys(lang)) {
          lang[str] = new LocalizedString(lang[str]);
        }
      }
    }
  }

  /**
   * Extended string class used for localization.
   */
  class LocalizedString extends String {
    /**
     * Returns formatted LocalizedString.
     * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
     *
     * E.g.:
     * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
     * A and B and A
     *
     * @param  {...any} args List of arguments for placeholders.
     */
    format() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const sub = args.reduce((string, arg, index) => string.split("{".concat(index, "}")).join(arg), this);
      return new LocalizedString(sub);
    }
  }
  var Locale$1 = new Locale();

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class VersionLabel extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        color: 0xbb0078ac,
        h: 40,
        w: 100,
        x: w => w - 50,
        y: h => h - 50,
        mount: 1,
        Text: {
          w: w => w,
          h: h => h,
          y: 5,
          x: 20,
          text: {
            fontSize: 22,
            lineHeight: 26
          }
        }
      };
    }
    _firstActive() {
      this.tag('Text').text = "APP - v".concat(this.version, "\nSDK - v").concat(this.sdkVersion);
      this.tag('Text').loadTexture();
      this.w = this.tag('Text').renderWidth + 40;
      this.h = this.tag('Text').renderHeight + 5;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class FpsIndicator extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        color: 0xffffffff,
        texture: lng$1.Tools.getRoundRect(80, 80, 40),
        h: 80,
        w: 80,
        x: 100,
        y: 100,
        mount: 1,
        Background: {
          x: 3,
          y: 3,
          texture: lng$1.Tools.getRoundRect(72, 72, 36),
          color: 0xff008000
        },
        Counter: {
          w: w => w,
          h: h => h,
          y: 10,
          text: {
            fontSize: 32,
            textAlign: 'center'
          }
        },
        Text: {
          w: w => w,
          h: h => h,
          y: 48,
          text: {
            fontSize: 15,
            textAlign: 'center',
            text: 'FPS'
          }
        }
      };
    }
    _setup() {
      this.config = {
        ...{
          log: false,
          interval: 500,
          threshold: 1
        },
        ...Settings.get('platform', 'showFps')
      };
      this.fps = 0;
      this.lastFps = this.fps - this.config.threshold;
      const fpsCalculator = () => {
        this.fps = ~~(1 / this.stage.dt);
      };
      this.stage.on('frameStart', fpsCalculator);
      this.stage.off('framestart', fpsCalculator);
      this.interval = setInterval(this.showFps.bind(this), this.config.interval);
    }
    _firstActive() {
      this.showFps();
    }
    _detach() {
      clearInterval(this.interval);
    }
    showFps() {
      if (Math.abs(this.lastFps - this.fps) <= this.config.threshold) return;
      this.lastFps = this.fps;
      // green
      let bgColor = 0xff008000;
      // orange
      if (this.fps <= 40 && this.fps > 20) bgColor = 0xffffa500;
      // red
      else if (this.fps <= 20) bgColor = 0xffff0000;
      this.tag('Background').setSmooth('color', bgColor);
      this.tag('Counter').text = "".concat(this.fps);
      this.config.log && Log.info('FPS', this.fps);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let meta = {};
  let translations = {};
  let language$1 = null;
  let dictionary = null;
  const initLanguage = function (file) {
    let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return new Promise((resolve, reject) => {
      fetch(file).then(response => response.json()).then(json => {
        setTranslations(json);
        // set language (directly or in a promise)
        typeof language === 'object' && 'then' in language && typeof language.then === 'function' ? language.then(lang => setLanguage(lang).then(resolve).catch(reject)).catch(e => {
          Log.error(e);
          reject(e);
        }) : setLanguage(language).then(resolve).catch(reject);
      }).catch(() => {
        const error = 'Language file ' + file + ' not found';
        Log.error(error);
        reject(error);
      });
    });
  };
  const setTranslations = obj => {
    if ('meta' in obj) {
      meta = {
        ...obj.meta
      };
      delete obj.meta;
    }
    translations = obj;
  };
  const getLanguage = () => {
    return language$1;
  };
  const setLanguage = lng => {
    language$1 = null;
    dictionary = null;
    return new Promise((resolve, reject) => {
      if (lng in translations) {
        language$1 = lng;
      } else {
        if ('map' in meta && lng in meta.map && meta.map[lng] in translations) {
          language$1 = meta.map[lng];
        } else if ('default' in meta && meta.default in translations) {
          const error = 'Translations for Language ' + language$1 + ' not found. Using default language ' + meta.default;
          Log.warn(error);
          language$1 = meta.default;
        } else {
          const error = 'Translations for Language ' + language$1 + ' not found.';
          Log.error(error);
          reject(error);
        }
      }
      if (language$1) {
        Log.info('Setting language to', language$1);
        const translationsObj = translations[language$1];
        if (typeof translationsObj === 'object') {
          dictionary = translationsObj;
          resolve();
        } else if (typeof translationsObj === 'string') {
          const url = Utils.asset(translationsObj);
          fetch(url).then(response => response.json()).then(json => {
            // save the translations for this language (to prevent loading twice)
            translations[language$1] = json;
            dictionary = json;
            resolve();
          }).catch(e => {
            const error = 'Error while fetching ' + url;
            Log.error(error, e);
            reject(error);
          });
        }
      }
    });
  };
  var Language = {
    translate(key) {
      let replacements = [...arguments].slice(1);

      // no replacements so just translated string
      if (replacements.length === 0) {
        return dictionary && dictionary[key] || key;
      } else {
        if (replacements.length === 1 && typeof replacements[0] === 'object') {
          replacements = replacements.pop();
        }
        return Object.keys(
        // maps array input to an object {0: 'item1', 1: 'item2'}
        Array.isArray(replacements) ? Object.assign({}, replacements) : replacements).reduce((text, replacementKey) => {
          return text.replace(new RegExp('{\\s?' + replacementKey + '\\s?}', 'g'), replacements[replacementKey]);
        }, dictionary && dictionary[key] || key);
      }
    },
    translations(obj) {
      setTranslations(obj);
    },
    set(language) {
      return setLanguage(language);
    },
    get() {
      return getLanguage();
    },
    available() {
      const languageKeys = Object.keys(translations);
      return languageKeys.map(key => ({
        code: key,
        name: meta.names && meta.names[key] || key
      }));
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const registry = {
    eventListeners: [],
    timeouts: [],
    intervals: [],
    targets: []
  };
  var Registry = {
    // Timeouts
    setTimeout(cb, timeout) {
      for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        params[_key - 2] = arguments[_key];
      }
      const timeoutId = setTimeout(() => {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
        cb.apply(null, params);
      }, timeout, params);
      Log.info('Set Timeout', 'ID: ' + timeoutId);
      registry.timeouts.push(timeoutId);
      return timeoutId;
    },
    clearTimeout(timeoutId) {
      if (registry.timeouts.indexOf(timeoutId) > -1) {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
        Log.info('Clear Timeout', 'ID: ' + timeoutId);
        clearTimeout(timeoutId);
      } else {
        Log.error('Clear Timeout', 'ID ' + timeoutId + ' not found');
      }
    },
    clearTimeouts() {
      registry.timeouts.forEach(timeoutId => {
        this.clearTimeout(timeoutId);
      });
    },
    // Intervals
    setInterval(cb, interval) {
      for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        params[_key2 - 2] = arguments[_key2];
      }
      const intervalId = setInterval(() => {
        registry.intervals.filter(id => id !== intervalId);
        cb.apply(null, params);
      }, interval, params);
      Log.info('Set Interval', 'ID: ' + intervalId);
      registry.intervals.push(intervalId);
      return intervalId;
    },
    clearInterval(intervalId) {
      if (registry.intervals.indexOf(intervalId) > -1) {
        registry.intervals = registry.intervals.filter(id => id !== intervalId);
        Log.info('Clear Interval', 'ID: ' + intervalId);
        clearInterval(intervalId);
      } else {
        Log.error('Clear Interval', 'ID ' + intervalId + ' not found');
      }
    },
    clearIntervals() {
      registry.intervals.forEach(intervalId => {
        this.clearInterval(intervalId);
      });
    },
    // Event listeners
    addEventListener(target, event, handler) {
      target.addEventListener(event, handler);
      const targetIndex = registry.targets.indexOf(target) > -1 ? registry.targets.indexOf(target) : registry.targets.push(target) - 1;
      registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {};
      registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || [];
      registry.eventListeners[targetIndex][event].push(handler);
      Log.info('Add eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler.toString());
    },
    removeEventListener(target, event, handler) {
      const targetIndex = registry.targets.indexOf(target);
      if (targetIndex > -1 && registry.eventListeners[targetIndex] && registry.eventListeners[targetIndex][event] && registry.eventListeners[targetIndex][event].indexOf(handler) > -1) {
        registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event].filter(fn => fn !== handler);
        Log.info('Remove eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler.toString());
        target.removeEventListener(event, handler);
      } else {
        Log.error('Remove eventListener', 'Not found', 'Target', target, 'Event: ' + event, 'Handler', handler.toString());
      }
    },
    // if `event` is omitted, removes all registered event listeners for target
    // if `target` is also omitted, removes all registered event listeners
    removeEventListeners(target, event) {
      if (target && event) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          registry.eventListeners[targetIndex][event].forEach(handler => {
            this.removeEventListener(target, event, handler);
          });
        }
      } else if (target) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          Object.keys(registry.eventListeners[targetIndex]).forEach(_event => {
            this.removeEventListeners(target, _event);
          });
        }
      } else {
        Object.keys(registry.eventListeners).forEach(targetIndex => {
          this.removeEventListeners(registry.targets[targetIndex]);
        });
      }
    },
    // Clear everything (to be called upon app close for proper cleanup)
    clear() {
      this.clearTimeouts();
      this.clearIntervals();
      this.removeEventListeners();
      registry.eventListeners = [];
      registry.timeouts = [];
      registry.intervals = [];
      registry.targets = [];
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const isObject$1 = v => {
    return typeof v === 'object' && v !== null;
  };
  const isString$1 = v => {
    return typeof v === 'string';
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let colors = {
    white: '#ffffff',
    black: '#000000',
    red: '#ff0000',
    green: '#00ff00',
    blue: '#0000ff',
    yellow: '#feff00',
    cyan: '#00feff',
    magenta: '#ff00ff'
  };
  const normalizedColors = {
    //store for normalized colors
  };
  const addColors = (colorsToAdd, value) => {
    if (isObject$1(colorsToAdd)) {
      // clean up normalizedColors if they exist in the to be added colors
      Object.keys(colorsToAdd).forEach(color => cleanUpNormalizedColors(color));
      colors = Object.assign({}, colors, colorsToAdd);
    } else if (isString$1(colorsToAdd) && value) {
      cleanUpNormalizedColors(colorsToAdd);
      colors[colorsToAdd] = value;
    }
  };
  const cleanUpNormalizedColors = color => {
    for (let c in normalizedColors) {
      if (c.indexOf(color) > -1) {
        delete normalizedColors[c];
      }
    }
  };
  const initColors = file => {
    return new Promise((resolve, reject) => {
      if (typeof file === 'object') {
        addColors(file);
        return resolve();
      }
      fetch(file).then(response => response.json()).then(json => {
        addColors(json);
        return resolve();
      }).catch(() => {
        const error = 'Colors file ' + file + ' not found';
        Log.error(error);
        return reject(error);
      });
    });
  };

  var name = "@lightningjs/sdk";
  var version = "4.8.3";
  var license = "Apache-2.0";
  var scripts = {
  	postinstall: "node ./scripts/postinstall.js",
  	lint: "eslint '**/*.js'",
  	release: "npm publish --access public"
  };
  var husky = {
  	hooks: {
  		"pre-commit": "lint-staged"
  	}
  };
  var dependencies = {
  	"@babel/polyfill": "^7.11.5",
  	"@lightningjs/core": "*",
  	"@michieljs/execute-as-promise": "^1.0.0",
  	deepmerge: "^4.2.2",
  	localCookie: "github:WebPlatformForEmbedded/localCookie",
  	shelljs: "^0.8.5",
  	"url-polyfill": "^1.1.10",
  	"whatwg-fetch": "^3.0.0"
  };
  var devDependencies = {
  	"@babel/core": "^7.11.6",
  	"@babel/plugin-transform-parameters": "^7.10.5 ",
  	"@babel/plugin-transform-spread": "^7.11.0",
  	"@babel/preset-env": "^7.11.5",
  	"babel-eslint": "^10.1.0",
  	eslint: "^7.10.0",
  	"eslint-config-prettier": "^6.12.0",
  	"eslint-plugin-prettier": "^3.1.4",
  	husky: "^4.3.0",
  	"lint-staged": "^10.4.0",
  	prettier: "^1.19.1",
  	rollup: "^1.32.1",
  	"rollup-plugin-babel": "^4.4.0"
  };
  var repository = {
  	type: "git",
  	url: "git@github.com:rdkcentral/Lightning-SDK.git"
  };
  var bugs = {
  	url: "https://github.com/rdkcentral/Lightning-SDK/issues"
  };
  var packageInfo = {
  	name: name,
  	version: version,
  	license: license,
  	scripts: scripts,
  	"lint-staged": {
  	"*.js": [
  		"eslint --fix"
  	],
  	"src/startApp.js": [
  		"rollup -c ./rollup.config.js"
  	]
  },
  	husky: husky,
  	dependencies: dependencies,
  	devDependencies: devDependencies,
  	repository: repository,
  	bugs: bugs
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let AppInstance;
  const defaultOptions$1 = {
    stage: {
      w: 1920,
      h: 1080,
      clearColor: 0x00000000,
      canvas2d: false
    },
    debug: false,
    defaultFontFace: 'RobotoRegular',
    keys: {
      8: 'Back',
      13: 'Enter',
      27: 'Menu',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      174: 'ChannelDown',
      175: 'ChannelUp',
      178: 'Stop',
      250: 'PlayPause',
      191: 'Search',
      // Use "/" for keyboard
      409: 'Search'
    }
  };
  const customFontFaces = [];
  const fontLoader = (fonts, store) => new Promise((resolve, reject) => {
    fonts.map(_ref => {
      let {
        family,
        url,
        urls,
        descriptors
      } = _ref;
      return () => {
        const src = urls ? urls.map(url => {
          return 'url(' + url + ')';
        }) : 'url(' + url + ')';
        const fontFace = new FontFace(family, src, descriptors || {});
        store.push(fontFace);
        Log.info('Loading font', family);
        document.fonts.add(fontFace);
        return fontFace.load();
      };
    }).reduce((promise, method) => {
      return promise.then(() => method());
    }, Promise.resolve(null)).then(resolve).catch(reject);
  });
  function Application (App, appData, platformSettings) {
    const {
      width,
      height
    } = platformSettings;
    if (width && height) {
      defaultOptions$1.stage['w'] = width;
      defaultOptions$1.stage['h'] = height;
      defaultOptions$1.stage['precision'] = width / 1920;
    }

    // support for 720p browser
    if (!width && !height && window.innerHeight === 720) {
      defaultOptions$1.stage['w'] = 1280;
      defaultOptions$1.stage['h'] = 720;
      defaultOptions$1.stage['precision'] = 1280 / 1920;
    }
    return class Application extends lng$1.Application {
      constructor(options) {
        const config = cjs(defaultOptions$1, options);
        // Deepmerge breaks HTMLCanvasElement, so restore the passed in canvas.
        if (options.stage.canvas) {
          config.stage.canvas = options.stage.canvas;
        }
        super(config);
        this.config = config;
      }
      static _template() {
        return {
          w: 1920,
          h: 1080
        };
      }
      _setup() {
        Promise.all([this.loadFonts(App.config && App.config.fonts || App.getFonts && App.getFonts() || []),
        // to be deprecated
        Locale$1.load(App.config && App.config.locale || App.getLocale && App.getLocale()), App.language && this.loadLanguage(App.language()), App.colors && this.loadColors(App.colors())]).then(() => {
          Metrics$1.app.loaded();
          AppInstance = this.stage.c({
            ref: 'App',
            type: App,
            zIndex: 1,
            forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps
          });
          this.childList.a(AppInstance);
          this._refocus();
          Log.info('App version', this.config.version);
          Log.info('SDK version', packageInfo.version);
          if (platformSettings.showVersion) {
            this.childList.a({
              ref: 'VersionLabel',
              type: VersionLabel,
              version: this.config.version,
              sdkVersion: packageInfo.version,
              zIndex: 1
            });
          }
          if (platformSettings.showFps) {
            this.childList.a({
              ref: 'FpsCounter',
              type: FpsIndicator,
              zIndex: 1
            });
          }
          super._setup();
        }).catch(console.error);
      }
      _handleBack() {
        this.closeApp();
      }
      _handleExit() {
        this.closeApp();
      }
      closeApp() {
        Log.info('Signaling App Close');
        if (platformSettings.onClose && typeof platformSettings.onClose === 'function') {
          platformSettings.onClose(...arguments);
        } else {
          this.close();
        }
      }
      close() {
        Log.info('Closing App');
        Settings.clearSubscribers();
        Registry.clear();
        this.childList.remove(this.tag('App'));
        this.cleanupFonts();
        // force texture garbage collect
        this.stage.gc();
        this.destroy();
      }
      loadFonts(fonts) {
        return platformSettings.fontLoader && typeof platformSettings.fontLoader === 'function' ? platformSettings.fontLoader(fonts, customFontFaces) : fontLoader(fonts, customFontFaces);
      }
      cleanupFonts() {
        if ('delete' in document.fonts) {
          customFontFaces.forEach(fontFace => {
            Log.info('Removing font', fontFace.family);
            document.fonts.delete(fontFace);
          });
        } else {
          Log.info('No support for removing manually-added fonts');
        }
      }
      loadLanguage(config) {
        let file = Utils.asset('translations.json');
        let language = config;
        if (typeof language === 'object') {
          language = config.language || null;
          file = config.file || file;
        }
        return initLanguage(file, language);
      }
      loadColors(config) {
        let file = Utils.asset('colors.json');
        if (config && (typeof config === 'string' || typeof config === 'object')) {
          file = config;
        }
        return initColors(file);
      }
      set focus(v) {
        this._focussed = v;
        this._refocus();
      }
      _getFocused() {
        return this._focussed || this.tag('App');
      }
    };
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @type {Lightning.Application}
   */
  let application;

  /**
   * Actual instance of the app
   * @type {Lightning.Component}
   */
  let app;

  /**
   * Component that hosts all routed pages
   * @type {Lightning.Component}
   */
  let pagesHost;

  /**
   * @type {Lightning.Stage}
   */
  let stage;

  /**
   * Platform driven Router configuration
   * @type {Map<string>}
   */
  let routerConfig;

  /**
   * Component that hosts all attached widgets
   * @type {Lightning.Component}
   */
  let widgetsHost;

  /**
   * Hash we point the browser to when we boot the app
   * and there is no deep-link provided
   * @type {string|Function}
   */
  let rootHash;

  /**
   * Boot request will fire before app start
   * can be used to execute some global logic
   * and can be configured
   */
  let bootRequest;

  /**
   * Flag if we need to update the browser location hash.
   * Router can work without.
   * @type {boolean}
   */
  let updateHash = true;

  /**
   * Will be called before a route starts, can be overridden
   * via routes config
   * @param from - route we came from
   * @param to - route we navigate to
   * @returns {Promise<*>}
   */
  // eslint-disable-next-line
  let beforeEachRoute = async (from, to) => {
    return true;
  };

  /**
   *  * Will be called after a navigate successfully resolved,
   * can be overridden via routes config
   */
  let afterEachRoute = () => {};

  /**
   * All configured routes
   * @type {Map<string, object>}
   */
  let routes$1 = new Map();

  /**
   * Store all page components per route
   * @type {Map<string, object>}
   */
  let components = new Map();

  /**
   * Flag if router has been initialised
   * @type {boolean}
   */
  let initialised = false;

  /**
   * Current page being rendered on screen
   * @type {null}
   */
  let activePage = null;
  let activeHash;
  let activeRoute;

  /**
   *  During the process of a navigation request a new
   *  request can start, to prevent unwanted behaviour
   *  the navigate()-method stores the last accepted hash
   *  so we can invalidate any prior requests
   */
  let lastAcceptedHash;

  /**
   * With on()-data providing behaviour the Router forced the App
   * in a Loading state. When the data-provider resolves we want to
   * change the state back to where we came from
   */
  let previousState;
  const mixin = app => {
    // by default the Router Baseclass provides the component
    // reference in which we store our pages
    if (app.pages) {
      pagesHost = app.pages.childList;
    }
    // if the app is using widgets we grab refs
    // and hide all the widgets
    if (app.widgets && app.widgets.children) {
      widgetsHost = app.widgets.childList;
      // hide all widgets on boot
      widgetsHost.forEach(w => w.visible = false);
    }
    app._handleBack = e => {
      step(-1);
      e.preventDefault();
    };
  };
  const bootRouter = (config, instance) => {
    let {
      appInstance,
      routes
    } = config;

    // if instance is provided and it's and Lightning Component instance
    if (instance && isPage(instance)) {
      app = instance;
    }
    if (!app) {
      app = appInstance || AppInstance;
    }
    application = app.application;
    pagesHost = application.childList;
    stage = app.stage;
    routerConfig = getConfigMap();
    mixin(app);
    if (isArray(routes)) {
      setup(config);
    } else if (isFunction(routes)) {
      console.warn('[Router]: Calling Router.route() directly is deprecated.');
      console.warn('Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    }
  };
  const setup = config => {
    if (!initialised) {
      init(config);
    }
    config.routes.forEach(r => {
      const path = cleanHash(r.path);
      if (!routeExists(path)) {
        const route = createRoute(r);
        routes$1.set(path, route);
        // if route has a configured component property
        // we store it in a different map to simplify
        // the creating and destroying per route
        if (route.component) {
          let type = route.component;
          if (isComponentConstructor(type)) {
            if (!routerConfig.get('lazyCreate')) {
              type = createComponent(stage, type);
              pagesHost.a(type);
            }
          }
          components.set(path, type);
        }
      } else {
        console.error("".concat(path, " already exists in routes configuration"));
      }
    });
  };
  const init = config => {
    rootHash = config.root;
    if (isFunction(config.boot)) {
      bootRequest = config.boot;
    }
    if (isBoolean(config.updateHash)) {
      updateHash = config.updateHash;
    }
    if (isFunction(config.beforeEachRoute)) {
      beforeEachRoute = config.beforeEachRoute;
    }
    if (isFunction(config.afterEachRoute)) {
      afterEachRoute = config.afterEachRoute;
    }
    if (config.bootComponent) {
      console.warn('[Router]: Boot Component is now available as a special router: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration?id=special-routes');
      console.warn('[Router]: setting { bootComponent } property will be deprecated in a future release');
      if (isPage(config.bootComponent)) {
        config.routes.push({
          path: '$',
          component: config.bootComponent,
          // we try to assign the bootRequest as after data-provider
          // so it will behave as any other component
          after: bootRequest || null,
          options: {
            preventStorage: true
          }
        });
      } else {
        console.error("[Router]: ".concat(config.bootComponent, " is not a valid boot component"));
      }
    }
    initialised = true;
  };
  const storeComponent = (route, type) => {
    if (components.has(route)) {
      components.set(route, type);
    }
  };
  const getComponent = route => {
    if (components.has(route)) {
      return components.get(route);
    }
    return null;
  };
  /**
   * Test if router needs to update browser location hash
   * @returns {boolean}
   */
  const mustUpdateLocationHash = () => {
    if (!routerConfig || !routerConfig.size) {
      return false;
    }
    // we need support to either turn change hash off
    // per platform or per app
    const updateConfig = routerConfig.get('updateHash');
    return !(isBoolean(updateConfig) && !updateConfig || isBoolean(updateHash) && !updateHash);
  };

  /**
   * Will be called when a new navigate() request has completed
   * and has not been expired due to it's async nature
   * @param request
   */
  const onRequestResolved = request => {
    const hash = request.hash;
    const route = request.route;
    const register = request.register;
    const page = request.page;

    // clean up history if modifier is set
    if (getOption(route.options, 'clearHistory')) {
      setHistory([]);
    } else if (hash && !isWildcard.test(route.path)) {
      updateHistory(request);
    }

    // we only update the stackLocation if a route
    // is not expired before it resolves
    storeComponent(route.path, page);
    if (request.isSharedInstance || !request.isCreated) {
      emit$1(page, 'changed');
    } else if (request.isCreated) {
      emit$1(page, 'mounted');
    }

    // only update widgets if we have a host
    if (widgetsHost) {
      updateWidgets(route.widgets, page);
    }

    // we want to clean up if there is an
    // active page that is not being shared
    // between current and previous route
    if (getActivePage() && !request.isSharedInstance) {
      cleanUp(activePage, request);
    }

    // provide history object to active page
    if (register.get(symbols.historyState) && isFunction(page.historyState)) {
      page.historyState(register.get(symbols.historyState));
    }
    setActivePage(page);
    activeHash = request.hash;
    activeRoute = route.path;

    // cleanup all cancelled requests
    for (let request of navigateQueue.values()) {
      if (request.isCancelled && request.hash) {
        navigateQueue.delete(request.hash);
      }
    }
    afterEachRoute(request);
    Log.info('[route]:', route.path);
    Log.info('[hash]:', hash);
  };
  const cleanUp = (page, request) => {
    const route = activeRoute;
    const register = request.register;
    const lazyDestroy = routerConfig.get('lazyDestroy');
    const destroyOnBack = routerConfig.get('destroyOnHistoryBack');
    const keepAlive = register.get('keepAlive');
    const isFromHistory = register.get(symbols.backtrack);
    let doCleanup = false;

    // if this request is executed due to a step back in history
    // and we have configured to destroy active page when we go back
    // in history or lazyDestory is enabled
    if (isFromHistory && (destroyOnBack || lazyDestroy)) {
      doCleanup = true;
    }

    // clean up if lazyDestroy is enabled and the keepAlive flag
    // in navigation register is false
    if (lazyDestroy && !keepAlive) {
      doCleanup = true;
    }

    // if the current and new request share the same route blueprint
    if (activeRoute === request.route.path) {
      doCleanup = true;
    }
    if (doCleanup) {
      // grab original class constructor if
      // statemachine routed else store constructor
      storeComponent(route, page._routedType || page.constructor);

      // actual remove of page from memory
      pagesHost.remove(page);

      // force texture gc() if configured
      // so we can cleanup textures in the same tick
      if (routerConfig.get('gcOnUnload')) {
        stage.gc();
      }
    } else {
      // If we're not removing the page we need to
      // reset it's properties
      page.patch({
        x: 0,
        y: 0,
        scale: 1,
        alpha: 1,
        visible: false
      });
    }
  };
  const getActiveHash = () => {
    return activeHash;
  };
  const setActivePage = page => {
    activePage = page;
  };
  const getActivePage = () => {
    return activePage;
  };
  const getActiveRoute = () => {
    return activeRoute;
  };
  const getLastHash = () => {
    return lastAcceptedHash;
  };
  const setLastHash = hash => {
    lastAcceptedHash = hash;
  };
  const getPreviousState = () => {
    return previousState;
  };
  const routeExists = key => {
    return routes$1.has(key);
  };
  const getRootHash = () => {
    return rootHash;
  };
  const getBootRequest = () => {
    return bootRequest;
  };
  const getRouterConfig = () => {
    return routerConfig;
  };
  const getRoutes = () => {
    return routes$1;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const isFunction = v => {
    return typeof v === 'function';
  };
  const isObject = v => {
    return typeof v === 'object' && v !== null;
  };
  const isBoolean = v => {
    return typeof v === 'boolean';
  };
  const isPage = v => {
    if (v instanceof lng$1.Element || isComponentConstructor(v)) {
      return true;
    }
    return false;
  };
  const isComponentConstructor = type => {
    return type.prototype && 'isComponent' in type.prototype;
  };
  const isArray = v => {
    return Array.isArray(v);
  };
  const ucfirst = v => {
    return "".concat(v.charAt(0).toUpperCase()).concat(v.slice(1));
  };
  const isString = v => {
    return typeof v === 'string';
  };
  const isPromise = method => {
    let result;
    if (isFunction(method)) {
      try {
        result = method.apply(null);
      } catch (e) {
        result = e;
      }
    } else {
      result = method;
    }
    return isObject(result) && isFunction(result.then);
  };
  const cleanHash = function () {
    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return hash.replace(/^#/, '').replace(/\/+$/, '');
  };
  const getConfigMap = () => {
    const routerSettings = Settings.get('platform', 'router');
    const isObj = isObject(routerSettings);
    return ['backtrack', 'gcOnUnload', 'destroyOnHistoryBack', 'lazyCreate', 'lazyDestroy', 'reuseInstance', 'autoRestoreRemote', 'numberNavigation', 'updateHash', 'storeSameHash'].reduce((config, key) => {
      config.set(key, isObj ? routerSettings[key] : Settings.get('platform', key));
      return config;
    }, new Map());
  };
  const getQueryStringParams = function () {
    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getActiveHash();
    const resumeHash = getResumeHash();
    if ((hash === '$' || !hash) && resumeHash) {
      if (isString(resumeHash)) {
        hash = resumeHash;
      }
    }
    let parse = '';
    const getQuery = /([?&].*)/;
    const matches = getQuery.exec(hash);
    const params = {};
    if (document.location && document.location.search) {
      parse = document.location.search;
    }
    if (matches && matches.length) {
      let hashParams = matches[1];
      if (parse) {
        // if location.search is not empty we
        // remove the leading ? to create a
        // valid string
        hashParams = hashParams.replace(/^\?/, '');
        // we parse hash params last so they we can always
        // override search params with hash params
        parse = "".concat(parse, "&").concat(hashParams);
      } else {
        parse = hashParams;
      }
    }
    if (parse) {
      const urlParams = new URLSearchParams(parse);
      for (const [key, value] of urlParams.entries()) {
        params[key] = value;
      }
      return params;
    } else {
      return false;
    }
  };
  const objectToQueryString = obj => {
    if (!isObject(obj)) {
      return '';
    }
    return '?' + Object.keys(obj).map(key => {
      return "".concat(key, "=").concat(obj[key]);
    }).join('&');
  };
  const symbols = {
    route: Symbol('route'),
    hash: Symbol('hash'),
    store: Symbol('store'),
    fromHistory: Symbol('fromHistory'),
    expires: Symbol('expires'),
    resume: Symbol('resume'),
    backtrack: Symbol('backtrack'),
    historyState: Symbol('historyState'),
    queryParams: Symbol('queryParams')
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const dataHooks = {
    on: request => {
      app.state || '';
      app._setState('Loading');
      return execProvider(request);
    },
    before: request => {
      return execProvider(request);
    },
    after: request => {
      try {
        execProvider(request, true);
      } catch (e) {
        // for now we fail silently
      }
      return Promise.resolve();
    }
  };
  const execProvider = (request, emitProvided) => {
    const route = request.route;
    const provider = route.provider;
    const expires = route.cache ? route.cache * 1000 : 0;
    const params = addPersistData(request);
    return provider.request(request.page, {
      ...params
    }).then(() => {
      request.page[symbols.expires] = Date.now() + expires;
      if (emitProvided) {
        emit$1(request.page, 'dataProvided');
      }
    }).catch(e => {
      request.page[symbols.expires] = Date.now();
      throw e;
    });
  };
  const addPersistData = _ref => {
    let {
      page,
      route,
      hash,
      register = new Map()
    } = _ref;
    const urlValues = getValuesFromHash(hash, route.path);
    const queryParams = getQueryStringParams(hash);
    const pageData = new Map([...urlValues, ...register]);
    const params = {};

    // make dynamic url data available to the page
    // as instance properties
    for (let [name, value] of pageData) {
      params[name] = value;
    }
    if (queryParams) {
      params[symbols.queryParams] = queryParams;
    }

    // check navigation register for persistent data
    if (register.size) {
      const obj = {};
      for (let [k, v] of register) {
        obj[k] = v;
      }
      page.persist = obj;
    }

    // make url data and persist data available
    // via params property
    page.params = params;
    emit$1(page, ['urlParams'], params);
    return params;
  };

  /**
   * Test if page passed cache-time
   * @param page
   * @returns {boolean}
   */
  const isPageExpired = page => {
    if (!page[symbols.expires]) {
      return false;
    }
    const expires = page[symbols.expires];
    const now = Date.now();
    return now >= expires;
  };
  const hasProvider = path => {
    if (routeExists(path)) {
      const record = routes$1.get(path);
      return !!record.provider;
    }
    return false;
  };
  const getProvider = route => {
    // @todo: fix, route already is passed in
    if (routeExists(route.path)) {
      const {
        provider
      } = routes$1.get(route.path);
      return {
        type: provider.type,
        provider: provider.request
      };
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const fade = (i, o) => {
    return new Promise(resolve => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, {
            duration: 0.5,
            delay: 0.1
          }]
        }
      });
      // resolve on y finish
      i.transition('alpha').on('finish', () => {
        if (o) {
          o.visible = false;
        }
        resolve();
      });
    });
  };
  const crossFade = (i, o) => {
    return new Promise(resolve => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, {
            duration: 0.5,
            delay: 0.1
          }]
        }
      });
      if (o) {
        o.patch({
          smooth: {
            alpha: [0, {
              duration: 0.5,
              delay: 0.3
            }]
          }
        });
      }
      // resolve on y finish
      i.transition('alpha').on('finish', () => {
        resolve();
      });
    });
  };
  const moveOnAxes = (axis, direction, i, o) => {
    const bounds = axis === 'x' ? 1920 : 1080;
    return new Promise(resolve => {
      i.patch({
        ["".concat(axis)]: direction ? bounds * -1 : bounds,
        visible: true,
        smooth: {
          ["".concat(axis)]: [0, {
            duration: 0.4,
            delay: 0.2
          }]
        }
      });
      // out is optional
      if (o) {
        o.patch({
          ["".concat(axis)]: 0,
          smooth: {
            ["".concat(axis)]: [direction ? bounds : bounds * -1, {
              duration: 0.4,
              delay: 0.2
            }]
          }
        });
      }
      // resolve on y finish
      i.transition(axis).on('finish', () => {
        resolve();
      });
    });
  };
  const up = (i, o) => {
    return moveOnAxes('y', 0, i, o);
  };
  const down = (i, o) => {
    return moveOnAxes('y', 1, i, o);
  };
  const left = (i, o) => {
    return moveOnAxes('x', 0, i, o);
  };
  const right = (i, o) => {
    return moveOnAxes('x', 1, i, o);
  };
  var Transitions = {
    fade,
    crossFade,
    up,
    down,
    left,
    right
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * execute transition between new / old page and
   * toggle the defined widgets
   * @todo: platform override default transition
   * @param pageIn
   * @param pageOut
   */
  const executeTransition = function (pageIn) {
    let pageOut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const transition = pageIn.pageTransition || pageIn.easing;
    const hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition);
    const transitionsDisabled = getRouterConfig().get('disableTransitions');
    if (pageIn.easing) {
      console.warn('easing() method is deprecated and will be removed. Use pageTransition()');
    }

    // default behaviour is a visibility toggle
    if (!hasCustomTransitions || transitionsDisabled) {
      pageIn.visible = true;
      if (pageOut) {
        pageOut.visible = false;
      }
      return Promise.resolve();
    }
    if (transition) {
      let type;
      try {
        type = transition.call(pageIn, pageIn, pageOut);
      } catch (e) {
        type = 'crossFade';
      }
      if (isPromise(type)) {
        return type;
      }
      if (isString(type)) {
        const fn = Transitions[type];
        if (fn) {
          return fn(pageIn, pageOut);
        }
      }

      // keep backwards compatible for now
      if (pageIn.smoothIn) {
        // provide a smooth function that resolves itself
        // on transition finish
        const smooth = function (p, v) {
          let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          return new Promise(resolve => {
            pageIn.visible = true;
            pageIn.setSmooth(p, v, args);
            pageIn.transition(p).on('finish', () => {
              resolve();
            });
          });
        };
        return pageIn.smoothIn({
          pageIn,
          smooth
        });
      }
    }
    return Transitions.crossFade(pageIn, pageOut);
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * The actual loading of the component
   * */
  const load = async request => {
    let expired = false;
    try {
      request = await loader$4(request);
      if (request && !request.isCancelled) {
        // in case of on() providing we need to reset
        // app state;
        if (app.state === 'Loading') {
          if (getPreviousState() === 'Widgets') ; else {
            app._setState('');
          }
        }
        // Do page transition if instance
        // is not shared between the routes
        if (!request.isSharedInstance && !request.isCancelled) {
          await executeTransition(request.page, getActivePage());
        }
      } else {
        expired = true;
      }
      // on expired we only cleanup
      if (expired || request.isCancelled) {
        Log.debug('[router]:', "Rejected ".concat(request.hash, " because route to ").concat(getLastHash(), " started"));
        if (request.isCreated && !request.isSharedInstance) {
          // remove from render-tree
          pagesHost.remove(request.page);
        }
      } else {
        onRequestResolved(request);
        // resolve promise
        return request.page;
      }
    } catch (request) {
      if (!request.route) {
        console.error(request);
      } else if (!expired) {
        // @todo: revisit
        const {
          route
        } = request;
        // clean up history if modifier is set
        if (getOption(route.options, 'clearHistory')) {
          setHistory([]);
        } else if (!isWildcard.test(route.path)) {
          updateHistory(request);
        }
        if (request.isCreated && !request.isSharedInstance) {
          // remove from render-tree
          pagesHost.remove(request.page);
        }
        handleError(request);
      }
    }
  };
  const loader$4 = async request => {
    const route = request.route;
    const hash = request.hash;
    const register = request.register;

    // todo: grab from Route instance
    let type = getComponent(route.path);
    let isConstruct = isComponentConstructor(type);
    let provide = false;

    // if it's an instance bt we're not coming back from
    // history we test if we can re-use this instance
    if (!isConstruct && !register.get(symbols.backtrack)) {
      if (!mustReuse(route)) {
        type = type.constructor;
        isConstruct = true;
      }
    }

    // If page is Lightning Component instance
    if (!isConstruct) {
      request.page = type;
      // if we have have a data route for current page
      if (hasProvider(route.path)) {
        if (isPageExpired(type) || type[symbols.hash] !== hash) {
          provide = true;
        }
      }
      let currentRoute = getActivePage() && getActivePage()[symbols.route];
      // if the new route is equal to the current route it means that both
      // route share the Component instance and stack location / since this case
      // is conflicting with the way before() and after() loading works we flag it,
      // and check platform settings in we want to re-use instance
      if (route.path === currentRoute) {
        request.isSharedInstance = true;
        // since we're re-using the instance we must attach
        // historyState to the request to prevent it from
        // being overridden.
        if (isFunction(request.page.historyState)) {
          request.copiedHistoryState = request.page.historyState();
        }
      }
    } else {
      request.page = createComponent(stage, type);
      pagesHost.a(request.page);
      // test if need to request data provider
      if (hasProvider(route.path)) {
        provide = true;
      }
      request.isCreated = true;
    }

    // we store hash and route as properties on the page instance
    // that way we can easily calculate new behaviour on page reload
    request.page[symbols.hash] = hash;
    request.page[symbols.route] = route.path;
    try {
      if (provide) {
        // extract attached data-provider for route
        // we're processing
        const {
          type: loadType,
          provider
        } = getProvider(route);

        // update running request
        request.provider = provider;
        request.providerType = loadType;
        await dataHooks[loadType](request);

        // we early exit if the current request is expired
        if (hash !== getLastHash()) {
          return false;
        } else {
          if (request.providerType !== 'after') {
            emit$1(request.page, 'dataProvided');
          }
          // resolve promise
          return request;
        }
      } else {
        addPersistData(request);
        return request;
      }
    } catch (e) {
      request.error = e;
      return Promise.reject(request);
    }
  };
  const handleError = request => {
    if (request && request.error) {
      console.error(request.error);
    } else if (request) {
      Log.error(request);
    }
    if (request.page && routeExists('!')) {
      navigate('!', {
        request
      }, false);
    }
  };
  const mustReuse = route => {
    const opt = getOption(route.options, 'reuseInstance');
    const config = routerConfig.get('reuseInstance');

    // route always has final decision
    if (isBoolean(opt)) {
      return opt;
    }
    return !(isBoolean(config) && config === false);
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class RoutedApp extends lng$1.Component {
    static _template() {
      return {
        Pages: {
          forceZIndexContext: true
        },
        /**
         * This is a default Loading page that will be made visible
         * during data-provider on() you CAN override in child-class
         */
        Loading: {
          rect: true,
          w: 1920,
          h: 1080,
          color: 0xff000000,
          visible: false,
          zIndex: 99,
          Label: {
            mount: 0.5,
            x: 960,
            y: 540,
            text: {
              text: 'Loading..'
            }
          }
        }
      };
    }
    static _states() {
      return [class Loading extends this {
        $enter() {
          this.tag('Loading').visible = true;
        }
        $exit() {
          this.tag('Loading').visible = false;
        }
      }, class Widgets extends this {
        $enter(args, widget) {
          // store widget reference
          this._widget = widget;

          // since it's possible that this behaviour
          // is non-remote driven we force a recalculation
          // of the focuspath
          this._refocus();
        }
        _getFocused() {
          // we delegate focus to selected widget
          // so it can consume remotecontrol presses
          return this._widget;
        }

        // if we want to widget to widget focus delegation
        reload(widget) {
          this._widget = widget;
          this._refocus();
        }
        _handleKey() {
          const restoreFocus = routerConfig.get('autoRestoreRemote');
          /**
           * The Router used to delegate focus back to the page instance on
           * every unhandled key. This is barely usefull in any situation
           * so for now we offer the option to explicity turn that behaviour off
           * so we don't don't introduce a breaking change.
           */
          if (!isBoolean(restoreFocus) || restoreFocus === true) {
            Router.focusPage();
          }
        }
      }];
    }

    /**
     * Return location where pages need to be stored
     */
    get pages() {
      return this.tag('Pages');
    }

    /**
     * Tell router where widgets are stored
     */
    get widgets() {
      return this.tag('Widgets');
    }

    /**
     * we MUST register _handleBack method so the Router
     * can override it
     * @private
     */
    _handleBack() {}

    /**
     * We MUST return Router.activePage() so the new Page
     * can listen to the remote-control.
     */
    _getFocused() {
      return Router.getActivePage();
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /*
  rouThor ==[x]
   */
  let navigateQueue = new Map();
  let forcedHash = '';
  let resumeHash = '';

  /**
   * Start routing the app
   * @param config - route config object
   * @param instance - instance of the app
   */
  const startRouter = (config, instance) => {
    bootRouter(config, instance);
    registerListener();
    start();
  };

  // start translating url
  const start = () => {
    let hash = (getHash() || '').replace(/^#/, '');
    const bootKey = '$';
    const params = getQueryStringParams(hash);
    const bootRequest = getBootRequest();
    const rootHash = getRootHash();
    const isDirectLoad = hash.indexOf(bootKey) !== -1;

    // prevent direct reload of wildcard routes
    // expect bootComponent
    if (isWildcard.test(hash) && hash !== bootKey) {
      hash = '';
    }

    // store resume point for manual resume
    resumeHash = isDirectLoad ? rootHash : hash || rootHash;
    const ready = () => {
      if (!hash && rootHash) {
        if (isString(rootHash)) {
          navigate(rootHash);
        } else if (isFunction(rootHash)) {
          rootHash().then(res => {
            if (isObject(res)) {
              navigate(res.path, res.params);
            } else {
              navigate(res);
            }
          });
        }
      } else {
        queue(hash);
        handleHashChange().then(() => {
          app._refocus();
        }).catch(e => {
          console.error(e);
        });
      }
    };
    if (routeExists(bootKey)) {
      if (hash && !isDirectLoad) {
        if (!getRouteByHash(hash)) {
          navigate('*', {
            failedHash: hash
          });
          return;
        }
      }
      navigate(bootKey, {
        resume: resumeHash,
        reload: bootKey === hash
      }, false);
    } else if (isFunction(bootRequest)) {
      bootRequest(params).then(() => {
        ready();
      }).catch(e => {
        handleBootError(e);
      });
    } else {
      ready();
    }
  };
  const handleBootError = e => {
    if (routeExists('!')) {
      navigate('!', {
        request: {
          error: e
        }
      });
    } else {
      console.error(e);
    }
  };

  /**
   * start a new request
   * @param url
   * @param args
   * @param store
   */
  const navigate = function (url) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let store = arguments.length > 2 ? arguments[2] : undefined;
    if (isObject(url)) {
      url = getHashByName(url);
      if (!url) {
        return;
      }
    }
    let hash = getHash();
    if (!mustUpdateLocationHash() && forcedHash) {
      hash = forcedHash;
    }
    if (hash.replace(/^#/, '') !== url) {
      // push request in the queue
      queue(url, args, store);
      setHash(url);
      if (!mustUpdateLocationHash()) {
        forcedHash = url;
        handleHashChange(url).then(() => {
          app._refocus();
        }).catch(e => {
          console.error(e);
        });
      }
    } else if (args.reload) {
      // push request in the queue
      queue(url, args, store);
      handleHashChange(url).then(() => {
        app._refocus();
      }).catch(e => {
        console.error(e);
      });
    }
  };
  const queue = function (hash) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let store = arguments.length > 2 ? arguments[2] : undefined;
    hash = cleanHash(hash);
    if (!navigateQueue.has(hash)) {
      for (let request of navigateQueue.values()) {
        request.cancel();
      }
      const request = createRequest(hash, args, store);
      navigateQueue.set(decodeURIComponent(hash), request);
      return request;
    }
    return false;
  };

  /**
   * Handle change of hash
   * @param override
   * @returns {Promise<void>}
   */
  const handleHashChange = async override => {
    const hash = cleanHash(override || getHash());
    const queueId = decodeURIComponent(hash);
    let request = navigateQueue.get(queueId);

    // handle hash updated manually
    if (!request && !navigateQueue.size) {
      request = queue(hash);
    }
    const route = getRouteByHash(hash);
    if (!route) {
      if (routeExists('*')) {
        navigate('*', {
          failedHash: hash
        });
      } else {
        console.error("Unable to navigate to: ".concat(hash));
      }
      return;
    }

    // update current processed request
    request.hash = hash;
    request.route = route;
    let result = await beforeEachRoute(getActiveHash(), request);

    // test if a local hook is configured for the route
    if (result && route.beforeNavigate) {
      result = await route.beforeNavigate(getActiveHash(), request);
    }
    if (isBoolean(result)) {
      // only if resolve value is explicitly true
      // we continue the current route request
      if (result) {
        return resolveHashChange(request);
      }
    } else {
      // if navigation guard didn't return true
      // we cancel the current request
      request.cancel();
      navigateQueue.delete(queueId);
      if (isString(result)) {
        navigate(result);
      } else if (isObject(result)) {
        let store = true;
        if (isBoolean(result.store)) {
          store = result.store;
        }
        navigate(result.path, result.params, store);
      }
    }
  };

  /**
   * Continue processing the hash change if not blocked
   * by global or local hook
   * @param request - {}
   */
  const resolveHashChange = request => {
    const hash = request.hash;
    const route = request.route;
    const queueId = decodeURIComponent(hash);
    // store last requested hash so we can
    // prevent a route that resolved later
    // from displaying itself
    setLastHash(hash);
    if (route.path) {
      const component = getComponent(route.path);
      // if a hook is provided for the current route
      if (isFunction(route.hook)) {
        const urlParams = getValuesFromHash(hash, route.path);
        const params = {};
        for (const key of urlParams.keys()) {
          params[key] = urlParams.get(key);
        }
        route.hook(app, {
          ...params
        });
      }
      // if there is a component attached to the route
      if (component) {
        // force page to root state to prevent shared state issues
        const activePage = getActivePage();
        if (activePage) {
          const keepAlive = keepActivePageAlive(getActiveRoute(), request);
          if (activePage && route.path === getActiveRoute() && !keepAlive) {
            activePage._setState('');
          }
        }
        if (isPage(component)) {
          load(request).then(() => {
            app._refocus();
            navigateQueue.delete(queueId);
          });
        } else {
          // of the component is not a constructor
          // or a Component instance we can assume
          // that it's a dynamic import
          component().then(contents => {
            return contents.default;
          }).then(module => {
            storeComponent(route.path, module);
            return load(request);
          }).then(() => {
            app._refocus();
            navigateQueue.delete(queueId);
          });
        }
      } else {
        navigateQueue.delete(queueId);
      }
    }
  };

  /**
   * Directional step in history
   * @param level
   */
  const step = function () {
    let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (!level || isNaN(level)) {
      return false;
    }
    const history = getHistory();
    // for now we only support negative numbers
    level = Math.abs(level);

    // we can't step back past the amount
    // of history entries
    if (level > history.length) {
      if (isFunction(app._handleAppClose)) {
        return app._handleAppClose();
      }
      return app.application.closeApp();
    } else if (history.length) {
      // for now we only support history back
      const route = history.splice(history.length - level, level)[0];
      // store changed history
      setHistory(history);
      return navigate(route.hash, {
        [symbols.backtrack]: true,
        [symbols.historyState]: route.state
      }, false);
    } else if (routerConfig.get('backtrack')) {
      const hashLastPart = /(\/:?[\w%\s-]+)$/;
      let hash = stripRegex(getHash());
      let floor = getFloor(hash);

      // test if we got deep-linked
      if (floor > 1) {
        while (floor--) {
          // strip of last part
          hash = hash.replace(hashLastPart, '');
          // if we have a configured route
          // we navigate to it
          if (getRouteByHash(hash)) {
            return navigate(hash, {
              [symbols.backtrack]: true
            }, false);
          }
        }
      }
    }
    return false;
  };

  /**
   * Resume Router's page loading process after
   * the BootComponent became visible;
   */
  const resume = () => {
    if (isString(resumeHash)) {
      navigate(resumeHash, false);
      resumeHash = '';
    } else if (isFunction(resumeHash)) {
      resumeHash().then(res => {
        resumeHash = '';
        if (isObject(res)) {
          navigate(res.path, res.params);
        } else {
          navigate(res);
        }
      });
    } else {
      console.warn('[Router]: resume() called but no hash found');
    }
  };

  /**
   * Force reload active hash
   */
  const reload = () => {
    if (!isNavigating()) {
      const hash = getActiveHash();
      navigate(hash, {
        reload: true
      }, false);
    }
  };

  /**
   * Query if the Router is still processing a Request
   * @returns {boolean}
   */
  const isNavigating = () => {
    if (navigateQueue.size) {
      let isProcessing = false;
      for (let request of navigateQueue.values()) {
        if (!request.isCancelled) {
          isProcessing = true;
        }
      }
      return isProcessing;
    }
    return false;
  };
  const getResumeHash = () => {
    return resumeHash;
  };

  /**
   * By default we return the location hash
   * @returns {string}
   */
  let getHash = () => {
    return document.location.hash;
  };

  /**
   * Update location hash
   * @param url
   */
  let setHash = url => {
    document.location.hash = url;
  };

  /**
   * This can be called from the platform / bootstrapper to override
   * the default getting and setting of the hash
   * @param config
   */
  const initRouter = config => {
    if (config.getHash) {
      getHash = config.getHash;
    }
    if (config.setHash) {
      setHash = config.setHash;
    }
  };

  /**
   * On hash change we start processing
   */
  const registerListener = () => {
    Registry.addEventListener(window, 'hashchange', async () => {
      if (mustUpdateLocationHash()) {
        try {
          await handleHashChange();
        } catch (e) {
          console.error(e);
        }
      }
    });
  };

  /**
   * Navigate to root hash
   */
  const root = () => {
    const rootHash = getRootHash();
    if (isString(rootHash)) {
      navigate(rootHash);
    } else if (isFunction(rootHash)) {
      rootHash().then(res => {
        if (isObject(res)) {
          navigate(res.path, res.params);
        } else {
          navigate(res);
        }
      });
    }
  };

  // export API
  var Router = {
    startRouter,
    navigate,
    resume,
    step,
    go: step,
    back: step.bind(null, -1),
    activePage: getActivePage,
    getActivePage() {
      // warning
      return getActivePage();
    },
    getActiveRoute,
    getActiveHash,
    focusWidget,
    getActiveWidget,
    restoreFocus,
    isNavigating,
    getHistory,
    setHistory,
    getHistoryState,
    replaceHistoryState,
    getQueryStringParams,
    reload,
    symbols,
    App: RoutedApp,
    // keep backwards compatible
    focusPage: restoreFocus,
    root: root,
    /**
     * Deprecated api methods
     */
    setupRoutes() {
      console.warn('Router: setupRoutes is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    on() {
      console.warn('Router.on() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    before() {
      console.warn('Router.before() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    after() {
      console.warn('Router.after() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const defaultChannels = [{
    number: 1,
    name: 'Metro News 1',
    description: 'New York Cable News Channel',
    entitled: true,
    program: {
      title: 'The Morning Show',
      description: "New York's best morning show",
      startTime: new Date(new Date() - 60 * 5 * 1000).toUTCString(),
      // started 5 minutes ago
      duration: 60 * 30,
      // 30 minutes
      ageRating: 0
    }
  }, {
    number: 2,
    name: 'MTV',
    description: 'Music Television',
    entitled: true,
    program: {
      title: 'Beavis and Butthead',
      description: 'American adult animated sitcom created by Mike Judge',
      startTime: new Date(new Date() - 60 * 20 * 1000).toUTCString(),
      // started 20 minutes ago
      duration: 60 * 45,
      // 45 minutes
      ageRating: 18
    }
  }, {
    number: 3,
    name: 'NBC',
    description: 'NBC TV Network',
    entitled: false,
    program: {
      title: 'The Tonight Show Starring Jimmy Fallon',
      description: 'Late-night talk show hosted by Jimmy Fallon on NBC',
      startTime: new Date(new Date() - 60 * 10 * 1000).toUTCString(),
      // started 10 minutes ago
      duration: 60 * 60,
      // 1 hour
      ageRating: 10
    }
  }];
  const channels = () => Settings.get('platform', 'tv', defaultChannels);
  const randomChannel = () => channels()[~~(channels.length * Math.random())];

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let currentChannel;
  const callbacks = {};
  const emit = function (event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    callbacks[event] && callbacks[event].forEach(cb => {
      cb.apply(null, args);
    });
  };

  // local mock methods
  let methods = {
    getChannel() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        if (currentChannel) {
          const channel = {
            ...currentChannel
          };
          delete channel.program;
          resolve(channel);
        } else {
          reject('No channel found');
        }
      });
    },
    getProgram() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        currentChannel.program ? resolve(currentChannel.program) : reject('No program found');
      });
    },
    setChannel(number) {
      return new Promise((resolve, reject) => {
        if (number) {
          const newChannel = channels().find(c => c.number === number);
          if (newChannel) {
            currentChannel = newChannel;
            const channel = {
              ...currentChannel
            };
            delete channel.program;
            emit('channelChange', channel);
            resolve(channel);
          } else {
            reject('Channel not found');
          }
        } else {
          reject('No channel number supplied');
        }
      });
    }
  };
  const initTV = config => {
    methods = {};
    if (config.getChannel && typeof config.getChannel === 'function') {
      methods.getChannel = config.getChannel;
    }
    if (config.getProgram && typeof config.getProgram === 'function') {
      methods.getProgram = config.getProgram;
    }
    if (config.setChannel && typeof config.setChannel === 'function') {
      methods.setChannel = config.setChannel;
    }
    if (config.emit && typeof config.emit === 'function') {
      config.emit(emit);
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const initPurchase = config => {
    if (config.billingUrl) config.billingUrl;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class PinInput extends lng$1.Component {
    static _template() {
      return {
        w: 120,
        h: 150,
        rect: true,
        color: 0xff949393,
        alpha: 0.5,
        shader: {
          type: lng$1.shaders.RoundedRectangle,
          radius: 10
        },
        Nr: {
          w: w => w,
          y: 24,
          text: {
            text: '',
            textColor: 0xff333333,
            fontSize: 80,
            textAlign: 'center',
            verticalAlign: 'middle'
          }
        }
      };
    }
    set index(v) {
      this.x = v * (120 + 24);
    }
    set nr(v) {
      this._timeout && clearTimeout(this._timeout);
      if (v) {
        this.setSmooth('alpha', 1);
      } else {
        this.setSmooth('alpha', 0.5);
      }
      this.tag('Nr').patch({
        text: {
          text: v && v.toString() || '',
          fontSize: v === '*' ? 120 : 80
        }
      });
      if (v && v !== '*') {
        this._timeout = setTimeout(() => {
          this._timeout = null;
          this.nr = '*';
        }, 750);
      }
    }
  }
  class PinDialog extends lng$1.Component {
    static _template() {
      return {
        zIndex: 1,
        w: w => w,
        h: h => h,
        rect: true,
        color: 0xdd000000,
        alpha: 0.000001,
        Dialog: {
          w: 648,
          h: 320,
          y: h => (h - 320) / 2,
          x: w => (w - 648) / 2,
          rect: true,
          color: 0xdd333333,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 10
          },
          Info: {
            y: 24,
            x: 48,
            text: {
              text: 'Please enter your PIN',
              fontSize: 32
            }
          },
          Msg: {
            y: 260,
            x: 48,
            text: {
              text: '',
              fontSize: 28,
              textColor: 0xffffffff
            }
          },
          Code: {
            x: 48,
            y: 96
          }
        }
      };
    }
    _init() {
      const children = [];
      for (let i = 0; i < 4; i++) {
        children.push({
          type: PinInput,
          index: i
        });
      }
      this.tag('Code').children = children;
    }
    get pin() {
      if (!this._pin) this._pin = '';
      return this._pin;
    }
    set pin(v) {
      if (v.length <= 4) {
        const maskedPin = new Array(Math.max(v.length - 1, 0)).fill('*', 0, v.length - 1);
        v.length && maskedPin.push(v.length > this._pin.length ? v.slice(-1) : '*');
        for (let i = 0; i < 4; i++) {
          this.tag('Code').children[i].nr = maskedPin[i] || '';
        }
        this._pin = v;
      }
    }
    get msg() {
      if (!this._msg) this._msg = '';
      return this._msg;
    }
    set msg(v) {
      this._timeout && clearTimeout(this._timeout);
      this._msg = v;
      if (this._msg) {
        this.tag('Msg').text = this._msg;
        this.tag('Info').setSmooth('alpha', 0.5);
        this.tag('Code').setSmooth('alpha', 0.5);
      } else {
        this.tag('Msg').text = '';
        this.tag('Info').setSmooth('alpha', 1);
        this.tag('Code').setSmooth('alpha', 1);
      }
      this._timeout = setTimeout(() => {
        this.msg = '';
      }, 2000);
    }
    _firstActive() {
      this.setSmooth('alpha', 1);
    }
    _handleKey(event) {
      if (this.msg) {
        this.msg = false;
      } else {
        const val = parseInt(event.key);
        if (val > -1) {
          this.pin += val;
        }
      }
    }
    _handleBack() {
      if (this.msg) {
        this.msg = false;
      } else {
        if (this.pin.length) {
          this.pin = this.pin.slice(0, this.pin.length - 1);
        } else {
          Pin.hide();
          this.resolve(false);
        }
      }
    }
    _handleEnter() {
      if (this.msg) {
        this.msg = false;
      } else {
        Pin.submit(this.pin).then(val => {
          this.msg = 'Unlocking ...';
          setTimeout(() => {
            Pin.hide();
          }, 1000);
          this.resolve(val);
        }).catch(e => {
          this.msg = e;
          this.reject(e);
        });
      }
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // only used during local development
  let unlocked = false;
  const contextItems = ['purchase', 'parental'];
  let submit = (pin, context) => {
    return new Promise((resolve, reject) => {
      if (pin.toString() === Settings.get('platform', 'pin', '0000').toString()) {
        unlocked = true;
        resolve(unlocked);
      } else {
        reject('Incorrect pin');
      }
    });
  };
  let check = context => {
    return new Promise(resolve => {
      resolve(unlocked);
    });
  };
  const initPin = config => {
    if (config.submit && typeof config.submit === 'function') {
      submit = config.submit;
    }
    if (config.check && typeof config.check === 'function') {
      check = config.check;
    }
  };
  let pinDialog = null;
  const contextCheck = context => {
    if (context === undefined) {
      Log.info('Please provide context explicitly');
      return contextItems[0];
    } else if (!contextItems.includes(context)) {
      Log.warn('Incorrect context provided');
      return false;
    }
    return context;
  };

  // Public API
  var Pin = {
    show() {
      return new Promise((resolve, reject) => {
        pinDialog = ApplicationInstance.stage.c({
          ref: 'PinDialog',
          type: PinDialog,
          resolve,
          reject
        });
        ApplicationInstance.childList.a(pinDialog);
        ApplicationInstance.focus = pinDialog;
      });
    },
    hide() {
      ApplicationInstance.focus = null;
      ApplicationInstance.children = ApplicationInstance.children.map(child => child !== pinDialog && child);
      pinDialog = null;
    },
    submit(pin, context) {
      return new Promise((resolve, reject) => {
        try {
          context = contextCheck(context);
          if (context) {
            submit(pin, context).then(resolve).catch(reject);
          } else {
            reject('Incorrect Context provided');
          }
        } catch (e) {
          reject(e);
        }
      });
    },
    unlocked(context) {
      return new Promise((resolve, reject) => {
        try {
          context = contextCheck(context);
          if (context) {
            check(context).then(resolve).catch(reject);
          } else {
            reject('Incorrect Context provided');
          }
        } catch (e) {
          reject(e);
        }
      });
    },
    locked(context) {
      return new Promise((resolve, reject) => {
        try {
          context = contextCheck(context);
          if (context) {
            check(context).then(unlocked => resolve(!!!unlocked)).catch(reject);
          } else {
            reject('Incorrect Context provided');
          }
        } catch (e) {
          reject(e);
        }
      });
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let ApplicationInstance;
  var Launch = ((App, appSettings, platformSettings, appData) => {
    initSettings(appSettings, platformSettings);
    initUtils(platformSettings);
    initStorage();
    // Initialize plugins
    if (platformSettings.plugins) {
      platformSettings.plugins.profile && initProfile(platformSettings.plugins.profile);
      platformSettings.plugins.metrics && initMetrics(platformSettings.plugins.metrics);
      platformSettings.plugins.mediaPlayer && initMediaPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.mediaPlayer && initVideoPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.ads && initAds(platformSettings.plugins.ads);
      platformSettings.plugins.router && initRouter(platformSettings.plugins.router);
      platformSettings.plugins.tv && initTV(platformSettings.plugins.tv);
      platformSettings.plugins.purchase && initPurchase(platformSettings.plugins.purchase);
      platformSettings.plugins.pin && initPin(platformSettings.plugins.pin);
    }
    const app = Application(App, appData, platformSettings);
    ApplicationInstance = new app(appSettings);
    return ApplicationInstance;
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class VideoTexture extends lng$1.Component {
    static _template() {
      return {
        Video: {
          alpha: 1,
          visible: false,
          pivot: 0.5,
          texture: {
            type: lng$1.textures.StaticTexture,
            options: {}
          }
        }
      };
    }
    set videoEl(v) {
      this._videoEl = v;
    }
    get videoEl() {
      return this._videoEl;
    }
    get videoView() {
      return this.tag('Video');
    }
    get videoTexture() {
      return this.videoView.texture;
    }
    get isVisible() {
      return this.videoView.alpha === 1 && this.videoView.visible === true;
    }
    _init() {
      this._createVideoTexture();
    }
    _createVideoTexture() {
      const stage = this.stage;
      const gl = stage.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.videoTexture.options = {
        source: glTexture,
        w: this.videoEl.width,
        h: this.videoEl.height
      };
      this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision();
      this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision();
    }
    start() {
      const stage = this.stage;
      this._lastTime = 0;
      if (!this._updateVideoTexture) {
        this._updateVideoTexture = () => {
          if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
            const gl = stage.gl;
            const currentTime = new Date().getTime();
            const getVideoPlaybackQuality = this.videoEl.getVideoPlaybackQuality();

            // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
            // We'll fallback to fixed 30fps in this case.
            // As 'webkitDecodedFrameCount' is about to deprecate, check for the 'totalVideoFrames'
            const frameCount = getVideoPlaybackQuality ? getVideoPlaybackQuality.totalVideoFrames : this.videoEl.webkitDecodedFrameCount;
            const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
            if (mustUpdate) {
              this._lastTime = currentTime;
              this._lastFrame = frameCount;
              try {
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                this.videoView.visible = true;
                this.videoTexture.options.w = this.videoEl.width;
                this.videoTexture.options.h = this.videoEl.height;
                const expectedAspectRatio = this.videoView.w / this.videoView.h;
                const realAspectRatio = this.videoEl.width / this.videoEl.height;
                if (expectedAspectRatio > realAspectRatio) {
                  this.videoView.scaleX = realAspectRatio / expectedAspectRatio;
                  this.videoView.scaleY = 1;
                } else {
                  this.videoView.scaleY = expectedAspectRatio / realAspectRatio;
                  this.videoView.scaleX = 1;
                }
              } catch (e) {
                Log.error('texImage2d video', e);
                this.stop();
              }
              this.videoTexture.source.forceRenderUpdate();
            }
          }
        };
      }
      if (!this._updatingVideoTexture) {
        stage.on('frameStart', this._updateVideoTexture);
        this._updatingVideoTexture = true;
      }
    }
    stop() {
      const stage = this.stage;
      stage.removeListener('frameStart', this._updateVideoTexture);
      this._updatingVideoTexture = false;
      this.videoView.visible = false;
      if (this.videoTexture.options.source) {
        const gl = stage.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
    }
    position(top, left) {
      this.videoView.patch({
        smooth: {
          x: left,
          y: top
        }
      });
    }
    size(width, height) {
      this.videoView.patch({
        smooth: {
          w: width,
          h: height
        }
      });
    }
    show() {
      this.videoView.setSmooth('alpha', 1);
    }
    hide() {
      this.videoView.setSmooth('alpha', 0);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let mediaUrl = url => url;
  let videoEl;
  let videoTexture;
  let metrics;
  let consumer$1;
  let precision = 1;
  let textureMode = false;
  const initVideoPlayer = config => {
    if (config.mediaUrl) {
      mediaUrl = config.mediaUrl;
    }
  };

  // todo: add this in a 'Registry' plugin
  // to be able to always clean this up on app close
  let eventHandlers = {};
  const state$1 = {
    adsEnabled: false,
    playing: false,
    _playingAds: false,
    get playingAds() {
      return this._playingAds;
    },
    set playingAds(val) {
      if (this._playingAds !== val) {
        this._playingAds = val;
        fireOnConsumer$1(val === true ? 'AdStart' : 'AdEnd');
      }
    },
    skipTime: false,
    playAfterSeek: null
  };
  const hooks = {
    play() {
      state$1.playing = true;
    },
    pause() {
      state$1.playing = false;
    },
    seeked() {
      state$1.playAfterSeek === true && videoPlayerPlugin.play();
      state$1.playAfterSeek = null;
    },
    abort() {
      deregisterEventListeners();
    }
  };
  const withPrecision = val => Math.round(precision * val) + 'px';
  const fireOnConsumer$1 = (event, args) => {
    if (consumer$1) {
      consumer$1.fire('$videoPlayer' + event, args, videoEl.currentTime);
      consumer$1.fire('$videoPlayerEvent', event, args, videoEl.currentTime);
    }
  };
  const fireHook = (event, args) => {
    hooks[event] && typeof hooks[event] === 'function' && hooks[event].call(null, event, args);
  };
  let customLoader = null;
  let customUnloader = null;
  const loader$3 = (url, videoEl, config) => {
    return customLoader && typeof customLoader === 'function' ? customLoader(url, videoEl, config) : new Promise(resolve => {
      url = mediaUrl(url);
      videoEl.setAttribute('src', url);
      videoEl.load();
      resolve();
    });
  };
  const unloader = videoEl => {
    return customUnloader && typeof customUnloader === 'function' ? customUnloader(videoEl) : new Promise(resolve => {
      videoEl.removeAttribute('src');
      videoEl.load();
      resolve();
    });
  };
  const setupVideoTag = () => {
    const videoEls = document.getElementsByTagName('video');
    if (videoEls && videoEls.length) {
      return videoEls[0];
    } else {
      const videoEl = document.createElement('video');
      const platformSettingsWidth = Settings.get('platform', 'width') ? Settings.get('platform', 'width') : 1920;
      const platformSettingsHeight = Settings.get('platform', 'height') ? Settings.get('platform', 'height') : 1080;
      videoEl.setAttribute('id', 'video-player');
      videoEl.setAttribute('width', withPrecision(platformSettingsWidth));
      videoEl.setAttribute('height', withPrecision(platformSettingsHeight));
      videoEl.style.position = 'absolute';
      videoEl.style.zIndex = '1';
      videoEl.style.display = 'none';
      videoEl.style.visibility = 'hidden';
      videoEl.style.top = withPrecision(0);
      videoEl.style.left = withPrecision(0);
      videoEl.style.width = withPrecision(platformSettingsWidth);
      videoEl.style.height = withPrecision(platformSettingsHeight);
      document.body.appendChild(videoEl);
      return videoEl;
    }
  };
  const setUpVideoTexture = () => {
    if (!ApplicationInstance.tag('VideoTexture')) {
      const el = ApplicationInstance.stage.c({
        type: VideoTexture,
        ref: 'VideoTexture',
        zIndex: 0,
        videoEl
      });
      ApplicationInstance.childList.addAt(el, 0);
    }
    return ApplicationInstance.tag('VideoTexture');
  };
  const registerEventListeners = () => {
    Log.info('VideoPlayer', 'Registering event listeners');
    Object.keys(events$1).forEach(event => {
      const handler = e => {
        // Fire a metric for each event (if it exists on the metrics object)
        if (metrics && metrics[event] && typeof metrics[event] === 'function') {
          metrics[event]({
            currentTime: videoEl.currentTime
          });
        }
        // fire an internal hook
        fireHook(event, {
          videoElement: videoEl,
          event: e
        });

        // fire the event (with human friendly event name) to the consumer of the VideoPlayer
        fireOnConsumer$1(events$1[event], {
          videoElement: videoEl,
          event: e
        });
      };
      eventHandlers[event] = handler;
      videoEl.addEventListener(event, handler);
    });
  };
  const deregisterEventListeners = () => {
    Log.info('VideoPlayer', 'Deregistering event listeners');
    Object.keys(eventHandlers).forEach(event => {
      videoEl.removeEventListener(event, eventHandlers[event]);
    });
    eventHandlers = {};
  };
  const videoPlayerPlugin = {
    consumer(component) {
      consumer$1 = component;
    },
    loader(loaderFn) {
      customLoader = loaderFn;
    },
    unloader(unloaderFn) {
      customUnloader = unloaderFn;
    },
    position() {
      let top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      videoEl.style.left = withPrecision(left);
      videoEl.style.top = withPrecision(top);
      if (textureMode === true) {
        videoTexture.position(top, left);
      }
    },
    size() {
      let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1920;
      let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1080;
      videoEl.style.width = withPrecision(width);
      videoEl.style.height = withPrecision(height);
      videoEl.width = parseFloat(videoEl.style.width);
      videoEl.height = parseFloat(videoEl.style.height);
      if (textureMode === true) {
        videoTexture.size(width, height);
      }
    },
    area() {
      let top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1920;
      let bottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1080;
      let left = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      this.position(top, left);
      this.size(right - left, bottom - top);
    },
    open(url) {
      let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this.canInteract) return;
      metrics = Metrics$1.media(url);
      this.hide();
      deregisterEventListeners();
      if (this.src == url) {
        this.clear().then(this.open(url, config));
      } else {
        const adConfig = {
          enabled: state$1.adsEnabled,
          duration: 300
        };
        if (config.videoId) {
          adConfig.caid = config.videoId;
        }
        Ads.get(adConfig, consumer$1).then(ads => {
          state$1.playingAds = true;
          ads.prerolls().then(() => {
            state$1.playingAds = false;
            loader$3(url, videoEl, config).then(() => {
              registerEventListeners();
              this.show();
              this.play();
            }).catch(e => {
              fireOnConsumer$1('error', {
                videoElement: videoEl,
                event: e
              });
            });
          });
        });
      }
    },
    reload() {
      if (!this.canInteract) return;
      const url = videoEl.getAttribute('src');
      this.close();
      this.open(url);
    },
    close() {
      Ads.cancel();
      if (state$1.playingAds) {
        state$1.playingAds = false;
        Ads.stop();
        // call self in next tick
        setTimeout(() => {
          this.close();
        });
      }
      if (!this.canInteract) return;
      this.clear();
      this.hide();
      deregisterEventListeners();
    },
    clear() {
      if (!this.canInteract) return;
      // pause the video first to disable sound
      this.pause();
      if (textureMode === true) videoTexture.stop();
      return unloader(videoEl).then(() => {
        fireOnConsumer$1('Clear', {
          videoElement: videoEl
        });
      });
    },
    play() {
      if (!this.canInteract) return;
      if (textureMode === true) videoTexture.start();
      executeAsPromise(videoEl.play, null, videoEl).catch(e => {
        fireOnConsumer$1('error', {
          videoElement: videoEl,
          event: e
        });
      });
    },
    pause() {
      if (!this.canInteract) return;
      videoEl.pause();
    },
    playPause() {
      if (!this.canInteract) return;
      this.playing === true ? this.pause() : this.play();
    },
    mute() {
      let muted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!this.canInteract) return;
      videoEl.muted = muted;
    },
    loop() {
      let looped = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      videoEl.loop = looped;
    },
    seek(time) {
      if (!this.canInteract) return;
      if (!this.src) return;
      // define whether should continue to play after seek is complete (in seeked hook)
      if (state$1.playAfterSeek === null) {
        state$1.playAfterSeek = !!state$1.playing;
      }
      // pause before actually seeking
      this.pause();
      // currentTime always between 0 and the duration of the video (minus 0.1s to not set to the final frame and stall the video)
      videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1));
    },
    skip(seconds) {
      if (!this.canInteract) return;
      if (!this.src) return;
      state$1.skipTime = (state$1.skipTime || videoEl.currentTime) + seconds;
      easeExecution(() => {
        this.seek(state$1.skipTime);
        state$1.skipTime = false;
      }, 300);
    },
    show() {
      if (!this.canInteract) return;
      if (textureMode === true) {
        videoTexture.show();
      } else {
        videoEl.style.display = 'block';
        videoEl.style.visibility = 'visible';
      }
    },
    hide() {
      if (!this.canInteract) return;
      if (textureMode === true) {
        videoTexture.hide();
      } else {
        videoEl.style.display = 'none';
        videoEl.style.visibility = 'hidden';
      }
    },
    enableAds() {
      let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      state$1.adsEnabled = enabled;
    },
    /* Public getters */
    get duration() {
      return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration);
    },
    get currentTime() {
      return videoEl && videoEl.currentTime;
    },
    get muted() {
      return videoEl && videoEl.muted;
    },
    get looped() {
      return videoEl && videoEl.loop;
    },
    get src() {
      return videoEl && videoEl.getAttribute('src');
    },
    get playing() {
      return state$1.playing;
    },
    get playingAds() {
      return state$1.playingAds;
    },
    get canInteract() {
      // todo: perhaps add an extra flag wether we allow interactions (i.e. pauze, mute, etc.) during ad playback
      return state$1.playingAds === false;
    },
    get top() {
      return videoEl && parseFloat(videoEl.style.top);
    },
    get left() {
      return videoEl && parseFloat(videoEl.style.left);
    },
    get bottom() {
      return videoEl && parseFloat(videoEl.style.top - videoEl.style.height);
    },
    get right() {
      return videoEl && parseFloat(videoEl.style.left - videoEl.style.width);
    },
    get width() {
      return videoEl && parseFloat(videoEl.style.width);
    },
    get height() {
      return videoEl && parseFloat(videoEl.style.height);
    },
    get visible() {
      if (textureMode === true) {
        return videoTexture.isVisible;
      } else {
        return videoEl && videoEl.style.display === 'block';
      }
    },
    get adsEnabled() {
      return state$1.adsEnabled;
    },
    // prefixed with underscore to indicate 'semi-private'
    // because it's not recommended to interact directly with the video element
    get _videoEl() {
      return videoEl;
    },
    get _consumer() {
      return consumer$1;
    }
  };
  autoSetupMixin(videoPlayerPlugin, () => {
    precision = ApplicationInstance && ApplicationInstance.stage && ApplicationInstance.stage.getRenderPrecision() || precision;
    videoEl = setupVideoTag();
    textureMode = Settings.get('platform', 'textureMode', false);
    if (textureMode === true) {
      videoEl.setAttribute('crossorigin', 'anonymous');
      videoTexture = setUpVideoTexture();
    }
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let consumer;
  let getAds = () => {
    // todo: enable some default ads during development, maybe from the settings.json
    return Promise.resolve({
      prerolls: [],
      midrolls: [],
      postrolls: []
    });
  };
  const initAds = config => {
    if (config.getAds) {
      getAds = config.getAds;
    }
  };
  const state = {
    active: false
  };
  const playSlot = function () {
    let slot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return slot.reduce((promise, ad) => {
      return promise.then(() => {
        return playAd(ad);
      });
    }, Promise.resolve(null));
  };
  const playAd = ad => {
    return new Promise(resolve => {
      if (state.active === false) {
        Log.info('Ad', 'Skipping add due to inactive state');
        return resolve();
      }
      // is it safe to rely on videoplayer plugin already created the video tag?
      const videoEl = document.getElementsByTagName('video')[0];
      videoEl.style.display = 'block';
      videoEl.style.visibility = 'visible';
      videoEl.src = mediaUrl(ad.url);
      videoEl.load();
      let timeEvents = null;
      let timeout;
      const cleanup = () => {
        // remove all listeners
        Object.keys(handlers).forEach(handler => videoEl.removeEventListener(handler, handlers[handler]));
        resolve();
      };
      const handlers = {
        play() {
          Log.info('Ad', 'Play ad', ad.url);
          fireOnConsumer('Play', ad);
          sendBeacon(ad.callbacks, 'defaultImpression');
        },
        ended() {
          fireOnConsumer('Ended', ad);
          sendBeacon(ad.callbacks, 'complete');
          cleanup();
        },
        timeupdate() {
          if (!timeEvents && videoEl.duration) {
            // calculate when to fire the time based events (now that duration is known)
            timeEvents = {
              firstQuartile: videoEl.duration / 4,
              midPoint: videoEl.duration / 2,
              thirdQuartile: videoEl.duration / 4 * 3
            };
            Log.info('Ad', 'Calculated quartiles times', {
              timeEvents
            });
          }
          if (timeEvents && timeEvents.firstQuartile && videoEl.currentTime >= timeEvents.firstQuartile) {
            fireOnConsumer('FirstQuartile', ad);
            delete timeEvents.firstQuartile;
            sendBeacon(ad.callbacks, 'firstQuartile');
          }
          if (timeEvents && timeEvents.midPoint && videoEl.currentTime >= timeEvents.midPoint) {
            fireOnConsumer('MidPoint', ad);
            delete timeEvents.midPoint;
            sendBeacon(ad.callbacks, 'midPoint');
          }
          if (timeEvents && timeEvents.thirdQuartile && videoEl.currentTime >= timeEvents.thirdQuartile) {
            fireOnConsumer('ThirdQuartile', ad);
            delete timeEvents.thirdQuartile;
            sendBeacon(ad.callbacks, 'thirdQuartile');
          }
        },
        stalled() {
          fireOnConsumer('Stalled', ad);
          timeout = setTimeout(() => {
            cleanup();
          }, 5000); // make timeout configurable
        },

        canplay() {
          timeout && clearTimeout(timeout);
        },
        error() {
          fireOnConsumer('Error', ad);
          cleanup();
        },
        // this doesn't work reliably on sky box, moved logic to timeUpdate event
        // loadedmetadata() {
        //   // calculate when to fire the time based events (now that duration is known)
        //   timeEvents = {
        //     firstQuartile: videoEl.duration / 4,
        //     midPoint: videoEl.duration / 2,
        //     thirdQuartile: (videoEl.duration / 4) * 3,
        //   }
        // },
        abort() {
          cleanup();
        }
        // todo: pause, resume, mute, unmute beacons
      };
      // add all listeners
      Object.keys(handlers).forEach(handler => videoEl.addEventListener(handler, handlers[handler]));
      videoEl.play();
    });
  };
  const sendBeacon = (callbacks, event) => {
    if (callbacks && callbacks[event]) {
      Log.info('Ad', 'Sending beacon', event, callbacks[event]);
      return callbacks[event].reduce((promise, url) => {
        return promise.then(() => fetch(url)
        // always resolve, also in case of a fetch error (so we don't block firing the rest of the beacons for this event)
        // note: for fetch failed http responses don't throw an Error :)
        .then(response => {
          if (response.status === 200) {
            fireOnConsumer('Beacon' + event + 'Sent');
          } else {
            fireOnConsumer('Beacon' + event + 'Failed' + response.status);
          }
          Promise.resolve(null);
        }).catch(() => {
          Promise.resolve(null);
        }));
      }, Promise.resolve(null));
    } else {
      Log.info('Ad', 'No callback found for ' + event);
    }
  };
  const fireOnConsumer = (event, args) => {
    if (consumer) {
      consumer.fire('$ad' + event, args);
      consumer.fire('$adEvent', event, args);
    }
  };
  var Ads = {
    get(config, videoPlayerConsumer) {
      if (config.enabled === false) {
        return Promise.resolve({
          prerolls() {
            return Promise.resolve();
          }
        });
      }
      consumer = videoPlayerConsumer;
      return new Promise(resolve => {
        Log.info('Ad', 'Starting session');
        getAds(config).then(ads => {
          Log.info('Ad', 'API result', ads);
          resolve({
            prerolls() {
              if (ads.preroll) {
                state.active = true;
                fireOnConsumer('PrerollSlotImpression', ads);
                sendBeacon(ads.preroll.callbacks, 'slotImpression');
                return playSlot(ads.preroll.ads).then(() => {
                  fireOnConsumer('PrerollSlotEnd', ads);
                  sendBeacon(ads.preroll.callbacks, 'slotEnd');
                  state.active = false;
                });
              }
              return Promise.resolve();
            },
            midrolls() {
              return Promise.resolve();
            },
            postrolls() {
              return Promise.resolve();
            }
          });
        });
      });
    },
    cancel() {
      Log.info('Ad', 'Cancel Ad');
      state.active = false;
    },
    stop() {
      Log.info('Ad', 'Stop Ad');
      state.active = false;
      // fixme: duplication
      const videoEl = document.getElementsByTagName('video')[0];
      videoEl.pause();
      videoEl.removeAttribute('src');
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ScaledImageTexture extends lng$1.textures.ImageTexture {
    constructor(stage) {
      super(stage);
      this._scalingOptions = undefined;
    }
    set options(options) {
      this.resizeMode = this._scalingOptions = options;
    }
    _getLookupId() {
      return "".concat(this._src, "-").concat(this._scalingOptions.type, "-").concat(this._scalingOptions.w, "-").concat(this._scalingOptions.h);
    }
    getNonDefaults() {
      const obj = super.getNonDefaults();
      if (this._src) {
        obj.src = this._src;
      }
      return obj;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let ws = null;
  if (typeof WebSocket !== 'undefined') {
    ws = WebSocket;
  }
  var ws_1 = ws;
  const requestsQueue = {};
  const listeners = {};
  var requestQueueResolver = data => {
    if (typeof data === 'string') {
      let regex1 = /\\\\x([0-9A-Fa-f]{2})/g;
      let regex2 = /\\x([0-9A-Fa-f]{2})/g;
      data = data.normalize().replace(regex1, '');
      data = data.normalize().replace(regex2, '');
      data = JSON.parse(data);
    }
    if (data.id) {
      const request = requestsQueue[data.id];
      if (request) {
        if ('result' in data) request.resolve(data.result);else request.reject(data.error);
        delete requestsQueue[data.id];
      } else {
        console.log('no pending request found with id ' + data.id);
      }
    }
  };
  var notificationListener = data => {
    if (typeof data === 'string') {
      let regex1 = /\\\\x([0-9A-Fa-f]{2})/g;
      let regex2 = /\\x([0-9A-Fa-f]{2})/g;
      data = data.normalize().replace(regex1, '');
      data = data.normalize().replace(regex2, '');
      data = JSON.parse(data);
    }
    if (!data.id && data.method) {
      const callbacks = listeners[data.method];
      if (callbacks && Array.isArray(callbacks) && callbacks.length) {
        callbacks.forEach(callback => {
          callback(data.params);
        });
      }
    }
  };
  const protocol = 'ws://';
  const host = 'localhost';
  const endpoint = '/jsonrpc';
  const port = 80;
  var makeWebsocketAddress = options => {
    return [options && options.protocol || protocol, options && options.host || host, ':' + (options && options.port || port), options && options.endpoint || endpoint, options && options.token ? '?token=' + options.token : null].join('');
  };
  const sockets = {};
  var connect = options => {
    return new Promise((resolve, reject) => {
      const socketAddress = makeWebsocketAddress(options);
      let socket = sockets[socketAddress];
      if (socket && socket.readyState === 1) return resolve(socket);
      if (socket && socket.readyState === 0) {
        const waitForOpen = () => {
          socket.removeEventListener('open', waitForOpen);
          resolve(socket);
        };
        return socket.addEventListener('open', waitForOpen);
      }
      if (socket == null) {
        if (options.debug) {
          console.log('Opening socket to ' + socketAddress);
        }
        socket = new ws_1(socketAddress, options && options.subprotocols || 'notification');
        sockets[socketAddress] = socket;
        socket.addEventListener('message', message => {
          if (options.debug) {
            console.log(' ');
            console.log('API REPONSE:');
            console.log(JSON.stringify(message.data, null, 2));
            console.log(' ');
          }
          requestQueueResolver(message.data);
        });
        socket.addEventListener('message', message => {
          notificationListener(message.data);
        });
        socket.addEventListener('error', () => {
          notificationListener({
            method: 'client.ThunderJS.events.error'
          });
          sockets[socketAddress] = null;
        });
        const handleConnectClosure = event => {
          sockets[socketAddress] = null;
          reject(event);
        };
        socket.addEventListener('close', handleConnectClosure);
        socket.addEventListener('open', () => {
          notificationListener({
            method: 'client.ThunderJS.events.connect'
          });
          socket.removeEventListener('close', handleConnectClosure);
          socket.addEventListener('close', () => {
            notificationListener({
              method: 'client.ThunderJS.events.disconnect'
            });
            sockets[socketAddress] = null;
          });
          resolve(socket);
        });
      } else {
        sockets[socketAddress] = null;
        reject('Socket error');
      }
    });
  };
  var makeBody = (requestId, plugin, method, params, version) => {
    if (params) {
      delete params.version;
      if (params.versionAsParameter) {
        params.version = params.versionAsParameter;
        delete params.versionAsParameter;
      }
    }
    const body = {
      jsonrpc: '2.0',
      id: requestId,
      method: [plugin, version, method].join('.')
    };
    params || params === false ? typeof params === 'object' && Object.keys(params).length === 0 ? null : body.params = params : null;
    return body;
  };
  var getVersion = (versionsConfig, plugin, params) => {
    const defaultVersion = 1;
    let version;
    if (version = params && params.version) {
      return version;
    }
    return versionsConfig ? versionsConfig[plugin] || versionsConfig.default || defaultVersion : defaultVersion;
  };
  let id = 0;
  var makeId = () => {
    id = id + 1;
    return id;
  };
  var execRequest = (options, body) => {
    return connect(options).then(connection => {
      connection.send(JSON.stringify(body));
    });
  };
  var API = options => {
    return {
      request(plugin, method, params) {
        return new Promise((resolve, reject) => {
          const requestId = makeId();
          const version = getVersion(options.versions, plugin, params);
          const body = makeBody(requestId, plugin, method, params, version);
          if (options.debug) {
            console.log(' ');
            console.log('API REQUEST:');
            console.log(JSON.stringify(body, null, 2));
            console.log(' ');
          }
          requestsQueue[requestId] = {
            body,
            resolve,
            reject
          };
          execRequest(options, body).catch(e => {
            reject(e);
          });
        });
      }
    };
  };
  var DeviceInfo = {
    freeRam(params) {
      return this.call('systeminfo', params).then(res => {
        return res.freeram;
      });
    },
    version(params) {
      return this.call('systeminfo', params).then(res => {
        return res.version;
      });
    }
  };
  var plugins = {
    DeviceInfo
  };
  function listener(plugin, event, callback, errorCallback) {
    const thunder = this;
    const index = register.call(this, plugin, event, callback, errorCallback);
    return {
      dispose() {
        const listener_id = makeListenerId(plugin, event);
        if (listeners[listener_id] === undefined) return;
        listeners[listener_id].splice(index, 1);
        if (listeners[listener_id].length === 0) {
          unregister.call(thunder, plugin, event, errorCallback);
        }
      }
    };
  }
  const makeListenerId = (plugin, event) => {
    return ['client', plugin, 'events', event].join('.');
  };
  const register = function (plugin, event, callback, errorCallback) {
    const listener_id = makeListenerId(plugin, event);
    if (!listeners[listener_id]) {
      listeners[listener_id] = [];
      if (plugin !== 'ThunderJS') {
        const method = 'register';
        const request_id = listener_id.split('.').slice(0, -1).join('.');
        const params = {
          event,
          id: request_id
        };
        this.api.request(plugin, method, params).catch(e => {
          if (typeof errorCallback === 'function') errorCallback(e.message);
        });
      }
    }
    listeners[listener_id].push(callback);
    return listeners[listener_id].length - 1;
  };
  const unregister = function (plugin, event, errorCallback) {
    const listener_id = makeListenerId(plugin, event);
    delete listeners[listener_id];
    if (plugin !== 'ThunderJS') {
      const method = 'unregister';
      const request_id = listener_id.split('.').slice(0, -1).join('.');
      const params = {
        event,
        id: request_id
      };
      this.api.request(plugin, method, params).catch(e => {
        if (typeof errorCallback === 'function') errorCallback(e.message);
      });
    }
  };
  var thunderJS = options => {
    if (options.token === undefined && typeof window !== 'undefined' && window.thunder && typeof window.thunder.token === 'function') {
      options.token = window.thunder.token();
    }
    return wrapper({
      ...thunder$f(options),
      ...plugins
    });
  };
  const resolve = (result, args) => {
    if (typeof result !== 'object' || typeof result === 'object' && (!result.then || typeof result.then !== 'function')) {
      result = new Promise((resolve, reject) => {
        result instanceof Error === false ? resolve(result) : reject(result);
      });
    }
    const cb = typeof args[args.length - 1] === 'function' ? args[args.length - 1] : null;
    if (cb) {
      result.then(res => cb(null, res)).catch(err => cb(err));
    } else {
      return result;
    }
  };
  const thunder$f = options => ({
    options,
    api: API(options),
    plugin: false,
    call() {
      const args = [...arguments];
      if (this.plugin) {
        if (args[0] !== this.plugin) {
          args.unshift(this.plugin);
        }
      }
      const plugin = args[0];
      const method = args[1];
      if (typeof this[plugin][method] == 'function') {
        return this[plugin][method](args[2]);
      }
      return this.api.request.apply(this, args);
    },
    registerPlugin(name, plugin) {
      this[name] = wrapper(Object.assign(Object.create(thunder$f), plugin, {
        plugin: name
      }));
    },
    subscribe() {},
    on() {
      const args = [...arguments];
      if (['connect', 'disconnect', 'error'].indexOf(args[0]) !== -1) {
        args.unshift('ThunderJS');
      } else {
        if (this.plugin) {
          if (args[0] !== this.plugin) {
            args.unshift(this.plugin);
          }
        }
      }
      return listener.apply(this, args);
    },
    once() {
      console.log('todo ...');
    }
  });
  const wrapper = obj => {
    return new Proxy(obj, {
      get(target, propKey) {
        const prop = target[propKey];
        if (propKey === 'api') {
          return target.api;
        }
        if (typeof prop !== 'undefined') {
          if (typeof prop === 'function') {
            if (['on', 'once', 'subscribe'].indexOf(propKey) > -1) {
              return function () {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return prop.apply(this, args);
              };
            }
            return function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              return resolve(prop.apply(this, args), args);
            };
          }
          if (typeof prop === 'object') {
            return wrapper(Object.assign(Object.create(thunder$f(target.options)), prop, {
              plugin: propKey
            }));
          }
          return prop;
        } else {
          if (target.plugin === false) {
            return wrapper(Object.assign(Object.create(thunder$f(target.options)), {}, {
              plugin: propKey
            }));
          }
          return function () {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            args.unshift(propKey);
            return target.call.apply(this, args);
          };
        }
      }
    });
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**Color constants */

  const themeOptions = {
    partnerOne: {
      hex: 0xfff58233,
      logo: 'RDKLogo.png',
      background: '0xff000000'
    },
    partnerTwo: {
      hex: 0xff91c848,
      logo: 'RDKLogo.png',
      background: '0xff000000'
    }
  };
  const language = {
    English: {
      id: 'en',
      fontSrc: 'Play/Play-Regular.ttf',
      font: 'Play'
    },
    Spanish: {
      id: 'sp',
      fontSrc: 'Play/Play-Regular.ttf',
      font: 'Play'
    }
  };
  const availableLanguages = ['English', 'Spanish'];
  const availableLanguageCodes = {
    "English": "en-US",
    "Spanish": "es-US"
  };
  var CONFIG = {
    theme: themeOptions['partnerOne'],
    language: localStorage.getItem('Language') != null && availableLanguages.includes(localStorage.getItem('Language')) ? language[localStorage.getItem('Language')] : language['English']
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Error$1 extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        w: 1920,
        h: 1080,
        color: 0xffb70606,
        InvalidText: {
          x: 960,
          y: 540,
          mount: 0.5,
          text: {
            text: 'Invalid Route',
            textColor: 0xff000000,
            fontFace: CONFIG.language.font,
            fontSize: 70,
            fontStyle: 'bold'
          },
          SubText: {
            y: 80,
            text: {
              text: 'Press OK to return home',
              textColor: 0xffffffff,
              fontFace: CONFIG.language.font,
              fontSize: 40,
              fontStyle: 'bold',
              textAlign: 'center'
            }
          }
        }
      };
    }
    _handleEnter() {
      Router.navigate('menu');
    }
    _focus() {
      console.log('focus error page');
    }

    //   set error(obj) {
    //     const { page, error } = obj
    //     console.log(page, error)

    //     const errorMessage = `
    // error while loading page: ${page.constructor.name}
    // press enter to navigate to home
    // --
    // loaded via hash: ${page[Symbol.for('hash')]}
    // resulted in route: ${page[Symbol.for('route')]}
    // --
    // ${error.toString()}`

    //     this.tag('Label').text = errorMessage
    //   }

    pageTransition() {
      return 'up';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Network {
    constructor() {
      this._events = new Map();
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS(config);
      this.callsign = 'org.rdk.Network';
    }

    /**
     * Function to activate network plugin
     */
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this._thunder.on(this.callsign, 'onIPAddressStatusChanged', notification => {
            if (this._events.has('onIPAddressStatusChanged')) {
              this._events.get('onIPAddressStatusChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onDefaultInterfaceChanged', notification => {
            if (this._events.has('onDefaultInterfaceChanged')) {
              this._events.get('onDefaultInterfaceChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onConnectionStatusChanged', notification => {
            if (this._events.has('onConnectionStatusChanged')) {
              this._events.get('onConnectionStatusChanged')(notification);
            }
          });
          console.log('Activation success');
          resolve(true);
        });
      });
    }

    /**
     *Register events and event listeners.
     * @param {string} eventId
     * @param {function} callback
     *
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Function to return the IP of the default interface.
     */
    getIP() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getStbIp').then(result => {
          if (result.success) {
            resolve(result.ip);
          }
          reject(false);
        }).catch(err => {
          reject(err);
        });
      });
    }
    /**
     * Function to return available interfaces.
     */
    getInterfaces() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getInterfaces').then(result => {
          if (result.success) {
            resolve(result.interfaces);
          }
        }).catch(err => {
          console.error("getInterfaces fail: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Function to return default interfaces.
     */
    getDefaultInterface() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getDefaultInterface').then(result => {
          if (result.success) {
            resolve(result.interface);
          }
        }).catch(err => {
          console.error("getDefaultInterface fail: ".concat(err));
          reject(err);
        });
      });
    }
    setDefaultInterface(interfaceName) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setDefaultInterface', {
          "interface": interfaceName,
          "persist": true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("setDefaultInterface fail: ".concat(err));
          reject(err);
        });
      });
    }
    getSTBIPFamily() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getSTBIPFamily').then(result => {
          //need to check
        });
      });
    }

    /**
     * Function to return IP Settings.
     */

    getIPSettings(currentInterface) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getIPSettings', {
          "interface": currentInterface
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("getIPSettings fail: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Function to set IP Settings.
     */

    setIPSettings(IPSettings) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setIPSettings', IPSettings).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("setIPSettings fail: ".concat(err));
          reject(err);
        });
      });
    }
    isConnectedToInternet() {
      return new Promise((resolve, reject) => {
        let header = new Headers();
        header.append('pragma', 'no-cache');
        header.append('cache-control', 'no-cache');
        fetch("https://apps.rdkcentral.com/rdk-apps/accelerator-home-ui/index.html", {
          method: 'GET',
          headers: header
        }).then(res => {
          if (res.status >= 200 && res.status <= 300) {
            console.log("Connected to internet");
            resolve(true);
          } else {
            console.log("No Internet Available");
            resolve(false);
          }
        }).catch(err => {
          console.log("Internet Check failed: No Internet Available");
          resolve(false); //fail of fetch method needs to be considered as no internet
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for HDMI thunder plugin apis.
   */
  class HDMIApi {
    constructor() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS(config);
      this._events = new Map();
      this.callsign = 'org.rdk.HdmiInput';
      this.resolution = {
        ResolutionUnknown: [1920, 1080],
        Resolution480I: [640, 480],
        Resolution480P: [640, 480],
        Resolution576I: [768, 576],
        Resolution576P: [768, 576],
        Resolution720P: [1280, 720],
        Resolution1080I: [1920, 1080],
        Resolution1080P: [1920, 1080],
        Resolution2160P30: [3840, 2160],
        Resolution2160P60: [3840, 2160]
      };
    }
    activate() {
      return new Promise((resolve, reject) => {
        // resolve(true)//#forTesting
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          console.log('Activated HdmiInput plugin');
          this._thunder.on(this.callsign, 'onInputStatusChanged', notification => {
            if (this._events.has('onInputStatusChanged')) {
              this._events.get('onInputStatusChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onDevicesChanged', notification => {
            if (this._events.has('onDevicesChanged')) {
              this._events.get('onDevicesChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onSignalChanged', notification => {
            if (this._events.has('onSignalChanged')) {
              this._events.get('onSignalChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'videoStreamInfoUpdate', notification => {
            if (this._events.has('videoStreamInfoUpdate')) {
              this._events.get('videoStreamInfoUpdate')(notification);
            }
          });
          if (result === null) resolve(true);else resolve(false);
        }).catch(err => {
          console.log('Failed to activate HdmiInput plugin', JSON.stringify(err));
          reject(false);
        });
      });
    }
    getHDMIDevices() {
      return new Promise((resolve, reject) => {
        // resolve([{id: 0,locator: "hdmiin://localhost/deviceid/0",connected: true,},{id: 1,locator: "hdmiin://localhost/deviceid/1",connected: false,},{id: 2,locator: "hdmiin://localhost/deviceid/2",connected: true,}]) //#forTesting
        this._thunder.call(this.callsign, 'getHDMIInputDevices').then(result => {
          resolve(result.devices);
        }).catch(err => {
          // reject(err) // #forTesting //make the api reject, instead of resolving empty array
          console.log("getHDMIDevices Error: ", JSON.stringify(err), " resolving empty array");
          resolve([]);
        });
      });
    }
    checkStatus(plugin) {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller.1', 'status@' + plugin).then(res => {
          console.log(JSON.stringify(res));
        });
      });
    }
    getDimensions() {
      return new Promise(resolve => {
        // resolve([1920, 1080])//#forTesting
        this._thunder.call('PlayerInfo', 'resolution').then(result => {
          resolve(this.resolution[result]);
        }).catch(err => {
          console.log('Failed to fetch dimensions', err);
          resolve([1920, 1080]);
        });
      });
    }
    setHDMIInput(portDetails) {
      return new Promise(async (resolve, reject) => {
        // resolve(true)//#forTesting
        if (portDetails.connected) {
          this._thunder.call(this.callsign, 'startHdmiInput', {
            portId: portDetails.id
          }).then(async result => {
            const dimension = await this.getDimensions();
            this._thunder.call(this.callsign, 'setVideoRectangle', {
              x: 0,
              y: 0,
              w: dimension[0],
              h: dimension[1]
            });
            resolve(result);
          }).catch(err => {
            reject(err);
          });
        } else {
          reject(false);
        }
      });
    }
    stopHDMIInput() {
      return new Promise((resolve, reject) => {
        // resolve(true)//#forTesting
        this._thunder.call(this.callsign, 'stopHdmiInput').then(result => {
          resolve(result);
        });
      });
    }

    /**
    *Register events and event listeners.
    * @param {string} eventId
    * @param {function} callback
    *
    */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
  }

  var App_launched_via_Netflix_Button = {
  	source_type: 3,
  	iid: "0b2a9564"
  };
  var App_launched_at_suspended_mode_at_power_on = {
  	source_type: 22,
  	iid: "ee4255bf"
  };
  var App_launched_via_DIAL_request = {
  	source_type: 12,
  	iid: "99a5fb82"
  };
  var App_launched_from_EPG_Grid = {
  	source_type: 3,
  	iid: "g5127fac"
  };
  var App_launched_via_channel_number = {
  	source_type: 3,
  	iid: "521ge753"
  };
  var App_launched_from_channel_info_bar = {
  	source_type: 3,
  	iid: "5h0x31l4"
  };
  var App_launched_via_channel_surf_option = {
  	source_type: 3,
  	iid: "5m938124"
  };
  var App_launched_via_Netflix_Icon_On_The_Apps_Section = {
  	source_type: 3,
  	iid: "513v474y"
  };
  var App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page = {
  	source_type: 3,
  	iid: "k5r7313g"
  };
  var NetflixIIDs = {
  	App_launched_via_Netflix_Button: App_launched_via_Netflix_Button,
  	App_launched_at_suspended_mode_at_power_on: App_launched_at_suspended_mode_at_power_on,
  	App_launched_via_DIAL_request: App_launched_via_DIAL_request,
  	App_launched_from_EPG_Grid: App_launched_from_EPG_Grid,
  	App_launched_via_channel_number: App_launched_via_channel_number,
  	App_launched_from_channel_info_bar: App_launched_from_channel_info_bar,
  	App_launched_via_channel_surf_option: App_launched_via_channel_surf_option,
  	App_launched_via_Netflix_Icon_On_The_Apps_Section: App_launched_via_Netflix_Icon_On_The_Apps_Section,
  	App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page: App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var activatedWeb = false;
  var activatedLightning = false;
  var activatedCobalt = false;
  var activatedAmazon = false;
  var activatedNetflix = false;
  var webUrl = '';
  var lightningUrl = '';
  const config$d = {
    host: '127.0.0.1',
    port: 9998,
    default: 1,
    versions: {
      'org.rdk.System': 2
    }
  };
  const thunder$e = thunderJS(config$d);
  /**
   * Class that contains functions which commuicates with thunder API's
   */
  class AppApi {
    constructor() {
      this.activatedForeground = false;
      this._events = new Map();
    }

    /**
     *
     * @param {string} eventId
     * @param {function} callback
     * Function to register the events for the Bluetooth plugin.
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
    fetchTimeZone() {
      return new Promise(resolve => {
        thunder$e.call('org.rdk.System', 'getTimeZones').then(result => {
          resolve(result.zoneinfo);
        }).catch(err => {
          console.log('Cannot fetch time zone', err);
          resolve({});
        });
      });
    }
    checkForInternet() {
      return new Promise((resolve, reject) => {
        let i = 0;
        var poll = () => {
          i++;
          this.getIP().then(result => {
            if (result == true) {
              resolve(result);
            } else if (i < 10) poll();else resolve(false);
          });
        };
        poll();
      });
    }
    isConnectedToInternet() {
      return new Promise((resolve, reject) => {
        let header = new Headers();
        header.append('pragma', 'no-cache');
        header.append('cache-control', 'no-cache');
        fetch("https://apps.rdkcentral.com/rdk-apps/accelerator-home-ui/index.html", {
          method: 'GET',
          headers: header
        }).then(res => {
          if (res.status >= 200 && res.status <= 300) {
            console.log("Connected to internet");
            resolve(true);
          } else {
            console.log("No Internet Available");
            resolve(false);
          }
        }).catch(err => {
          console.log("Internet Check failed: No Internet Available");
          resolve(false); //fail of fetch method needs to be considered as no internet
        });
      });
    }

    fetchApiKey() {
      return new Promise(resolve => {
        thunder$e.call('org.rdk.PersistentStore', 'getValue', {
          namespace: 'gracenote',
          key: 'apiKey'
        }).then(result => {
          resolve(result.value);
        }).catch(err => {
          resolve('');
        });
      });
    }

    /**
     * Function to launch Html app.
     * @param {String} url url of app.
     */
    getIP() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.System';
        thunder$e.Controller.activate({
          callsign: systemcCallsign
        }).then(() => {
          thunder$e.call(systemcCallsign, 'getDeviceInfo', {
            params: 'estb_ip'
          }).then(result => {
            resolve(result.success);
          }).catch(err => {
            resolve(false);
          });
        }).catch(err => {});
      });
    }
    /**
    *  Function to get timeZone
    */
    getZone() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.System';
        thunder$e.call(systemcCallsign, 'getTimeZoneDST').then(result => {
          resolve(result.timeZone);
        }).catch(err => {
          console.log('Failed to fetch Time Zone');
          resolve(undefined);
        });
      });
    }
    setZone(zone) {
      console.log(zone);
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'setTimeZoneDST', {
          timeZone: zone
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          resolve(false);
        });
      }).catch(err => {});
    }
    getPluginStatus(plugin) {
      return new Promise((resolve, reject) => {
        thunder$e.call('Controller', "status@".concat(plugin)).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }

    /**
     * Function to get resolution of the display screen.
     */
    getResolution() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getCurrentResolution', {
          "videoDisplay": "HDMI0"
        }).then(result => {
          resolve(result.resolution);
        }).catch(err => {
          resolve('NA');
        });
      });
    }
    activateDisplaySettings() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = "org.rdk.DisplaySettings";
        thunder$e.Controller.activate({
          callsign: systemcCallsign
        }).then(res => {}).catch(err => {
          console.error("error while activating the displaysettings plugin");
        });
      });
    }
    getSupportedResolutions() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.DisplaySettings';
        thunder$e.Controller.activate({
          callsign: systemcCallsign
        }).then(() => {
          thunder$e.call(systemcCallsign, 'getSupportedResolutions', {
            params: 'HDMI0'
          }).then(result => {
            resolve(result.supportedResolutions);
          }).catch(err => {
            resolve(false);
          });
        }).catch(err => {
          console.log('Display Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to set the display resolution.
     */
    setResolution(res) {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.DisplaySettings';
        thunder$e.Controller.activate({
          callsign: systemcCallsign
        }).then(() => {
          thunder$e.call(systemcCallsign, 'setCurrentResolution', {
            videoDisplay: 'HDMI0',
            resolution: res,
            persist: true
          }).then(result => {
            resolve(result.success);
          }).catch(err => {
            resolve(false);
          });
        }).catch(err => {
          console.log('Display Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get HDCP Status.
     */
    getHDCPStatus() {
      console.log("checking hdcp status");
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.HdcpProfile';
        thunder$e.Controller.activate({
          callsign: systemcCallsign
        }).then(() => {
          thunder$e.call(systemcCallsign, 'getHDCPStatus').then(result => {
            resolve(result.HDCPStatus);
            console.log("HDCP Status from AppApi.js : " + JSON.stringify(result.HDCPStatus));
          }).catch(err => {
            resolve(false);
          });
        }).catch(err => {
          console.log('Display Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get TV HDR Support.
     */
    getTvHDRSupport() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.DisplaySettings';
        thunder$e.Controller.activate({
          callsign: systemcCallsign
        }).then(() => {
          thunder$e.call(systemcCallsign, 'getTvHDRSupport').then(result => {
            resolve(result);
            console.log("HDR Support Status from AppApi.js : " + JSON.stringify(result));
          }).catch(err => {
            resolve(false);
          });
        }).catch(err => {
          console.log('Display Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get settop box HDR Support.
     */
    getSettopHDRSupport() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.DisplaySettings';
        thunder$e.Controller.activate({
          callsign: systemcCallsign
        }).then(() => {
          thunder$e.call(systemcCallsign, 'getSettopHDRSupport').then(result => {
            resolve(result);
            console.log("HDR Support Status for STB from AppApi.js : " + JSON.stringify(result));
          }).catch(err => {
            resolve(false);
          });
        }).catch(err => {
          console.log('Display Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get HDR Format in use.
     */
    getHDRSetting() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'DisplayInfo';
        thunder$e.Controller.activate({
          callsign: systemcCallsign
        }).then(() => {
          thunder$e.call(systemcCallsign, 'hdrsetting').then(result => {
            resolve(result);
            console.log("HDR format in use from AppApi.js : " + JSON.stringify(result));
          }).catch(err => {
            resolve(false);
          });
        }).catch(err => {
          console.log('Display Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get DRMs.
     */
    getDRMS() {
      console.log("calling getDDRMS");
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'OCDM';
        thunder$e.Controller.activate({
          callsign: systemcCallsign
        }).then(() => {
          thunder$e.call(systemcCallsign, 'drms').then(result => {
            resolve(result);
            console.log("supported drms from AppApi.js : " + JSON.stringify(result));
          }).catch(err => {
            resolve(false);
          });
        }).catch(err => {
          console.log('Display Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to clear cache.
     */
    clearCache() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'ResidentApp';
        thunder$e.call(systemcCallsign, 'delete', {
          path: ".cache"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          resolve(err);
        });
      });
    }

    /**
     * Function to launch All types of apps. Accepts 2 params.
     * @param {String} callsign String required callsign of the particular app.
     * @param {Object} args Object optional depending on following properties.
     *  @property {string} url: optional for youtube & netflix | required for Lightning and WebApps
     *  @property {string} launchLocation: optional | to pass Netflix IIDs or Youtube launch reason | launchLocation value is one among these values ["mainView", "dedicatedButton", "appsMenu", "epgScreen", "dial", "gracenote",]
     *  @property {boolean} preventInternetCheck: optional | true will prevent bydefault check for internet
     *  @property {boolean} preventCurrentExit: optional |  true will prevent bydefault launch of previous app
     */

    async launchApp(callsign, args) {
      Router.navigate("applauncher");
      console.log("launchApp called with: ", callsign, args);
      let url, preventInternetCheck, preventCurrentExit, launchLocation;
      if (args) {
        url = args.url;
        preventInternetCheck = args.preventInternetCheck;
        preventCurrentExit = args.preventCurrentExit;
        launchLocation = args.launchLocation;
      }
      const launchLocationKeyMapping = {
        //currently supported launch locations by the UI and mapping to corresponding reason/keys for IID
        "mainView": {
          "Cobalt": "menu",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page"
        },
        "dedicatedButton": {
          "Cobalt": "remote",
          "Netflix": "App_launched_via_Netflix_Button"
        },
        "appsMenu": {
          "Cobalt": "menu",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Section"
        },
        "epgScreen": {
          "Cobalt": "guide",
          "Netflix": "App_launched_from_EPG_Grid"
        },
        "dial": {
          "Cobalt": "dial",
          "Netflix": "App_launched_via_DIAL_request"
        },
        "gracenote": {
          "Cobalt": "launcher",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page"
        }
      };
      if (launchLocation && launchLocationKeyMapping[launchLocation]) {
        if (callsign === "Netflix" || callsign === "Cobalt") {
          launchLocation = launchLocationKeyMapping[launchLocation][callsign];
        }
      }
      console.log("launchApp getting executed with callsign: " + callsign + " | url: " + url + " | preventInternetCheck: " + preventInternetCheck + " | preventCurrentExit: " + preventCurrentExit + " | launchLocation: " + launchLocation);
      let IIDqueryString = "";
      if (callsign === "Netflix") {
        let netflixIids = await this.getNetflixIIDs();
        if (launchLocation) {
          IIDqueryString = "source_type=".concat(netflixIids[launchLocation].source_type, "&iid=").concat(netflixIids[launchLocation].iid);
          if (url) {
            IIDqueryString = "&" + IIDqueryString; //so that IIDqueryString can be appended with url later.
          }
        } else {
          console.log("launchLocation(IID) not specified while launching netflix");
        }
      }
      const availableCallsigns = ["Amazon", "Cobalt", "HtmlApp", "LightningApp", "Netflix"];
      if (!availableCallsigns.includes(callsign)) {
        Router.navigate("menu");
        return Promise.reject("Can't launch App: " + callsign + " | Error: callsign not found!");
      }
      if (!preventInternetCheck) {
        let internet = await this.isConnectedToInternet();
        if (!internet) {
          Router.navigate("menu");
          return Promise.reject("No Internet Available, can't launchApp.");
        }
      }
      const currentApp = Storage.get("applicationType"); //get it from stack if required. | current app ==="" means residentApp

      let pluginStatus, pluginState; // to check if the plugin is active, resumed, deactivated etc
      try {
        pluginStatus = await this.getPluginStatus(callsign);
        pluginState = pluginStatus[0].state;
      } catch (err) {
        console.log(err);
        Router.navigate("menu");
        return Promise.reject("PluginError: " + callsign + ": App not supported on this device | Error: " + JSON.stringify(err));
      }
      console.log(callsign + " : pluginStatus: " + JSON.stringify(pluginStatus) + " pluginState: ", JSON.stringify(pluginState));
      if (callsign === "Netflix") {
        if (pluginState === "deactivated" || pluginState === "deactivation") {
          //netflix cold launch scenario
          console.log("Netflix : ColdLaunch");
          if (Router.getActivePage().showSplashImage) {
            Router.getActivePage().showSplashImage(callsign); //to make the splash image for netflix visible
          }

          if (url) {
            try {
              console.log("Netflix ColdLaunch passing netflix url & IIDqueryString using configureApplication method:  ", url, IIDqueryString);
              await this.configureApplication("Netflix", url + IIDqueryString);
            } catch (err) {
              console.log("Netflix configureApplication error: ", err);
            }
          } else {
            try {
              console.log("Netflix ColdLaunch passing netflix IIDqueryString using configureApplication method:  ", IIDqueryString);
              await this.configureApplication("Netflix", IIDqueryString);
            } catch (err) {
              console.log("Netflix configureApplication error: ", err);
            }
          }
        } else {
          //netflix hot launch scenario
          console.log("Netflix : HotLaunch");
          if (url) {
            try {
              console.log("Netflix HotLaunch passing netflix url & IIDqueryString using systemcommand method: ", url, IIDqueryString);
              await thunder$e.call("Netflix", "systemcommand", {
                command: url + IIDqueryString
              });
            } catch (err) {
              console.log("Netflix systemcommand error: ", err);
            }
          } else {
            try {
              console.log("Netflix HotLaunch passing netflix IIDqueryString using systemcommand method: ", IIDqueryString);
              await thunder$e.call("Netflix", "systemcommand", {
                command: IIDqueryString
              });
            } catch (err) {
              console.log("Netflix systemcommand error: ", err);
            }
          }
        }
      }
      let params = {
        "callsign": callsign,
        "type": callsign
      };
      if (url && (callsign === "LightningApp" || callsign === "HtmlApp")) {
        //for lightning/htmlapp url is passed via rdkshell.launch method
        params.uri = url;
      } else if (callsign === "Cobalt") {
        let language = localStorage.getItem("Language");
        language = availableLanguageCodes[language] ? availableLanguageCodes[language] : "en-US"; //default to english US if language is not available.
        url = url ? url : "https://www.youtube.com/tv?";
        url = url === "https://www.youtube.com/tv" ? "https://www.youtube.com/tv?" : url;
        url = url + "&launch=" + launchLocation; //skipping to append launch reason to url if launchLocation is gracenote
        if (pluginState === "deactivated" || pluginState === "deactivation") {
          //for youtube cold launch | currently only urls from dial can be passed via configuration
          params.configuration = {
            //for gracenote cold launch url needs to be re formatted to youtube.com/tv/
            "language": language,
            "url": url,
            "launchtype": "launch=" + launchLocation
          };
        }
      }
      if (!preventCurrentExit && currentApp !== "") {
        //currentApp==="" means currently on residentApp | make currentApp = "residentApp" in the cache and stack
        try {
          console.log("calling exitApp with params: callsign and exitInBackground", currentApp, "true");
          await this.exitApp(currentApp, true);
        } catch (err) {
          console.log("currentApp exit failed!: launching new app...");
        }
      }
      if (currentApp === "" && callsign !== "Netflix") {
        //currentApp==="" means currently on residentApp | make currentApp = "residentApp" in the cache and stack | for netflix keep the splash screen visible till it launches
        thunder$e.call('org.rdk.RDKShell', 'setVisibility', {
          "client": "ResidentApp",
          "visible": false
        });
      }
      if (callsign === "Netflix") {
        //special case for netflix to show splash screen
        params.behind = "ResidentApp"; //to make the app launch behind resident app | app will be moved to front after first frame event is triggered
      }

      console.log("Calling launchApp with params: ", params);
      return new Promise((resolve, reject) => {
        thunder$e.call("org.rdk.RDKShell", "launch", params).then(res => {
          console.log("".concat(callsign, " : Launch results in ").concat(JSON.stringify(res)));
          if (res.success) {
            if (callsign !== "Netflix") {
              //if app is not netflix, move it to front(netflix will be moved to front from applauncherScreen.)
              thunder$e.call("org.rdk.RDKShell", "moveToFront", {
                "client": callsign,
                "callsign": callsign
              }).catch(err => {
                console.error("failed to moveToFront : ", callsign, " ERROR: ", JSON.stringify(err), " | fail reason can be since app is already in front");
              });
            }
            thunder$e.call("org.rdk.RDKShell", "setFocus", {
              "client": callsign,
              "callsign": callsign
            }).catch(err => {
              console.error("failed to setFocus : ", callsign, " ERROR: ", JSON.stringify(err));
            });
            thunder$e.call("org.rdk.RDKShell", "setVisibility", {
              "client": callsign,
              "visible": true
            }).catch(err => {
              console.error("failed to setVisibility : ", callsign, " ERROR: ", JSON.stringify(err));
            });
            if (callsign === "Netflix") {
              console.log("Netflix launched: hiding residentApp");
              thunder$e.call('org.rdk.RDKShell', 'setVisibility', {
                "client": "ResidentApp",
                "visible": false
              }); //if netflix splash screen was launched resident app was kept visible Netflix until app launched.
            }

            if (callsign === "Cobalt" && url && !params.configuration) {
              //passing url to cobalt once launched | if params.configuration exist means no need for deeplink
              console.log("Calling deeplink for cobalt with url: " + url);
              thunder$e.call(callsign, 'deeplink', url);
            }
            Storage.set("applicationType", callsign);
            resolve(res);
          } else {
            console.error("failed to launchApp(success false) : ", callsign, " ERROR: ", JSON.stringify(res));
            Router.navigate("menu");
            reject(res);
          }
        }).catch(err => {
          console.error("failed to launchApp: ", callsign, " ERROR: ", JSON.stringify(err), " | Launching residentApp back");

          //destroying the app incase it's stuck in launching | if taking care of ResidentApp as callsign, make sure to prevent destroying it
          thunder$e.call('org.rdk.RDKShell', 'destroy', {
            "callsign": callsign
          });
          this.launchResidentApp();
          Router.navigate("menu");
          reject(err);
        });
      });
    }

    /**
     * Function to launch Exit types of apps.
     * @param {String} callsign callsign of the particular app.
     * @param {boolean} exitInBackground to make the app not bring up residentApp on exit
     * @param {boolean} forceDestroy to force the app to do rdkshell.destroy instead of suspend
     */

    // exit method does not need to launch the previous app.
    async exitApp(callsign, exitInBackground, forceDestroy) {
      //test the new exit app method

      if (callsign === "") {
        //previousApp==="" means it's residentApp | change it to residentApp in cache and here
        return Promise.reject("Can't exit from ResidentApp");
      }
      if (callsign === "HDMI") {
        console.log("exit method called for hdmi");
        new HDMIApi().stopHDMIInput();
        Storage.set("_currentInputMode", {});
        if (!exitInBackground) {
          //means resident App needs to be launched
          this.launchResidentApp();
        }
        return Promise.resolve(true);
        //check for hdmi scenario
      }

      if (callsign === "LightningApp" || callsign === "HtmlApp") {
        forceDestroy = true; //html and lightning apps need not be suspended.
      }

      let pluginStatus, pluginState; // to check if the plugin is active, resumed, deactivated etc
      try {
        pluginStatus = await this.getPluginStatus(callsign);
        if (pluginStatus !== undefined) {
          pluginState = pluginStatus[0].state;
          console.log("pluginStatus: " + JSON.stringify(pluginStatus) + " pluginState: ", JSON.stringify(pluginState));
        } else {
          return Promise.reject("PluginError: " + callsign + ": App not supported on this device");
        }
      } catch (err) {
        return Promise.reject("PluginError: " + callsign + ": App not supported on this device | Error: " + JSON.stringify(err));
      }
      if (!exitInBackground) {
        //means resident App needs to be launched
        this.launchResidentApp();
      }

      //to hide the current app
      console.log("setting visibility of " + callsign + " to false");
      await thunder$e.call("org.rdk.RDKShell", "setVisibility", {
        "client": callsign,
        "visible": false
      }).catch(err => {
        console.error("failed to setVisibility : " + callsign + " ERROR: ", JSON.stringify(err));
      });
      if (forceDestroy) {
        console.log("Force Destroying the app: ", callsign);
        await thunder$e.call('org.rdk.RDKShell', 'destroy', {
          "callsign": callsign
        });
        return Promise.resolve(true);
      } else {
        console.log("Exiting from App: ", callsign, " depending on platform settings enableAppSuspended: ", Settings.get("platform", "enableAppSuspended"));
        //enableAppSuspended = true means apps will be suspended by default
        if (Settings.get("platform", "enableAppSuspended")) {
          await thunder$e.call('org.rdk.RDKShell', 'suspend', {
            "callsign": callsign
          }).catch(err => {
            console.error("Error in suspending app: ", callsign, " | trying to destroy the app");
            thunder$e.call('org.rdk.RDKShell', 'destroy', {
              "callsign": callsign
            });
          });
          return Promise.resolve(true);
        } else {
          await thunder$e.call('org.rdk.RDKShell', 'destroy', {
            "callsign": callsign
          });
          return Promise.resolve(true);
        }
      }
    }

    /**
     * Function to launch ResidentApp explicitly(incase of special scenarios)
     * Prefer using launchApp and exitApp for ALL app launch and exit scenarios.
     */

    async launchResidentApp() {
      console.log("launchResidentApp got Called: setting visibility, focus and moving to front the ResidentApp");
      await thunder$e.call("org.rdk.RDKShell", "moveToFront", {
        "client": "ResidentApp",
        "callsign": "ResidentApp"
      }).catch(err => {
        console.error("failed to moveToFront : ResidentApp ERROR: ", JSON.stringify(err), " | fail reason can be since app is already in front");
      });
      await thunder$e.call("org.rdk.RDKShell", "setFocus", {
        "client": "ResidentApp",
        "callsign": "ResidentApp"
      }).catch(err => {
        console.error("failed to setFocus : ResidentApp ERROR: ", JSON.stringify(err));
      });
      await thunder$e.call("org.rdk.RDKShell", "setVisibility", {
        "client": "ResidentApp",
        "visible": true
      }).catch(err => {
        console.error("failed to setVisibility : ResidentApp ERROR: ", JSON.stringify(err));
      });
      Storage.set("applicationType", ""); //since it's residentApp aplication type is "" | change application type to ResidentApp 
    }

    async getNetflixIIDs() {
      let defaultIIDs = NetflixIIDs;
      let data = new HomeApi().getPartnerAppsInfo();
      if (!data) {
        return defaultIIDs;
      }
      console.log("homedata: ", data);
      try {
        data = await JSON.parse(data);
        if (data != null && data.hasOwnProperty("netflix-iid-file-path")) {
          let url = data["netflix-iid-file-path"];
          console.log("Netflix : requested to fetch iids from ", url);
          const fetchResponse = await fetch(url);
          const fetchData = await fetchResponse.json();
          return fetchData;
        } else {
          console.log("Netflix IID file path not found in conf file, using deffault IIDs");
          return defaultIIDs;
        }
      } catch (err) {
        console.log("Error in fetching iid data from specified path, returning defaultIIDs | Error:", err);
        return defaultIIDs;
      }
    }
    /**
     * Function to launch Html app.
     * @param {String} url url of app.
     */
    launchWeb(url) {
      return new Promise(resolve => {
        const childCallsign = 'HtmlApp';
        if (webUrl != url) {
          thunder$e.call('org.rdk.RDKShell', 'launch', {
            callsign: childCallsign,
            type: childCallsign,
            uri: url
          }).then(res => {
            console.log("WebApp : webapp launch resulted in : ", JSON.stringify(res));
            this.setVisibility("ResidentApp", false);
            thunder$e.call('org.rdk.RDKShell', 'moveToFront', {
              client: childCallsign
            });
            resolve(true);
          }).catch(err => {
            console.error("WebApp : error while launching web : ", JSON.stringify(err));
            reject(false);
          });
        } else {
          thunder$e.call('org.rdk.RDKShell', 'moveToFront', {
            client: childCallsign
          });
          thunder$e.call('org.rdk.RDKShell', 'setFocus', {
            client: childCallsign
          });
          resolve(true);
        }
        webUrl = url;
        activatedWeb = true;
      });
    }

    /**
     * Function to launch Lightning app.
     * @param {String} url url of app.
     */
    launchLightning(url) {
      return new Promise((resolve, reject) => {
        const childCallsign = 'LightningApp';
        if (lightningUrl != url) {
          thunder$e.call('org.rdk.RDKShell', 'launch', {
            callsign: 'Lightning',
            type: childCallsign,
            uri: url
          }).then(res => {
            console.log("Lightning : launch lightning results in ", JSON.stringify(res));
            resolve(true);
          }).catch(err => {
            console.error("Lightning : error while launching lightning : ", JSON.stringify(err));
            reject(false);
          });
        } else {
          thunder$e.call('org.rdk.RDKShell', 'moveToFront', {
            client: childCallsign
          });
          thunder$e.call('org.rdk.RDKShell', 'setFocus', {
            client: childCallsign
          });
          resolve(true);
        }
        lightningUrl = url;
        activatedLightning = true;
      });
    }

    /**
     * Function to launch Cobalt app.
     * @param {String} url url of app.
     */
    launchCobalt(url) {
      return new Promise((resolve, reject) => {
        const childCallsign = 'Cobalt';
        thunder$e.call('org.rdk.RDKShell', 'launch', {
          callsign: childCallsign,
          type: childCallsign
        }).then(res => {
          if (url) {
            thunder$e.call('Cobalt', 'deeplink', url);
          }
          this.setVisibility("ResidentApp", false);
          thunder$e.call('org.rdk.RDKShell', 'moveToFront', {
            client: "Cobalt"
          }).catch(err => {
            console.error(err);
          });
          thunder$e.call("org.rdk.RDKShell", "setFocus", {
            client: childCallsign
          }).catch(err => {
            console.error(err);
          });
          Storage.set("applicationType", "Cobalt");
          console.log("Cobalt : launch cobalt results in ", JSON.stringify(res));
          resolve(true);
        }).catch(err => {
          console.error("Cobalt : error while launching cobalt : ", JSON.stringify(err));
          reject(err);
        });
        activatedCobalt = true;
      });
    }

    /*  
     *Function to launch apps in hidden mode
     */
    launchPremiumAppInSuspendMode(childCallsign) {
      return new Promise((resolve, reject) => {
        thunder$e.call("org.rdk.RDKShell", "launch", {
          callsign: childCallsign,
          type: childCallsign,
          suspend: true,
          visible: false,
          focused: false
        }).then(res => {
          if (childCallsign == "Netflix") {
            console.log("Netflix : launch netflix results in :", res);
          } else {
            console.log("Amazon : launch amazon results in :", res);
          }
          resolve(true);
        }).catch(err => {
          if (childCallsign == "Netflix") {
            console.error("Netflix : error while launching netflix :", err);
          } else {
            console.log("Amazon : error while launching amazon :", err);
          }
          reject(false);
        });
      });
    }

    /**
     * Function to launch Netflix/Amazon Prime app.
     */
    launchPremiumApp(childCallsign) {
      return new Promise((resolve, reject) => {
        thunder$e.call("org.rdk.RDKShell", "launch", {
          callsign: childCallsign,
          type: childCallsign,
          visible: true,
          focused: true
        }).then(res => {
          if (childCallsign == "Netflix") {
            console.log("Netflix : launch netflix results in :", res);
          } else {
            console.log("Amazon : launch amazon results in :", res);
          }
          this.setVisibility(childCallsign, true);
          this.zorder(childCallsign);
          Storage.set("applicationType", childCallsign);
          console.log("the current application Type : ", Storage.get("applicationType"));
          resolve(true);
        }).catch(err => {
          if (childCallsign == "Netflix") {
            console.error("Netflix : error while launching netflix :", err);
          } else {
            console.log("Amazon : error while launching amazon :", err);
          }
          reject(false);
        });
        childCallsign === 'Amazon' ? activatedAmazon = true : activatedNetflix = true;
      });
    }
    launchPremiumAppURL(childCallsign, url) {
      thunder$e.call("org.rdk.RDKShell", "launch", {
        callsign: childCallsign,
        type: childCallsign
      }).then(() => {
        thunder$e.call("org.rdk.RDKShell", "moveToFront", {
          client: childCallsign
        });
        thunder$e.call(childCallsign, 'deeplink', url);
        thunder$e.call("org.rdk.RDKShell", "setFocus", {
          client: childCallsign
        });
      }).catch(err => {});
      childCallsign === 'Amazon' ? activatedAmazon = true : activatedNetflix = true;
    }

    /**
     * Function to launch Resident app.
     * @param {String} url url of app.
     */
    launchResident(url, client) {
      return new Promise((resolve, reject) => {
        const childCallsign = client;
        thunder$e.call('org.rdk.RDKShell', 'launch', {
          callsign: childCallsign,
          type: 'ResidentApp',
          uri: url
        }).then(res => {
          console.log("ResidentApp :  launching resident app resulted in : ", JSON.stringify(res));
          resolve(true);
        }).catch(err => {
          console.error('ResidentApp : error while launching residentApp : ' + JSON.stringify(err));
          reject(false);
        });
      });
    }
    launchOverlay(url, client) {
      return new Promise(resolve => {
        const childCallsign = client;
        thunder$e.call('org.rdk.RDKShell', 'launch', {
          callsign: childCallsign,
          type: 'ResidentApp',
          uri: url
        }).then(res => {
          thunder$e.call('org.rdk.RDKShell', 'moveToFront', {
            client: childCallsign
          });
          console.log("Overlay : launched overlay : ", res);
          resolve(res);
        }).catch(err => {
          console.error("Overlay : error while launching the overlay", err);
          reject(err);
        });
      });
    }

    /**
     * Function to suspend html app.
     */
    suspendWeb() {
      webUrl = '';
      thunder$e.call('org.rdk.RDKShell', 'suspend', {
        callsign: 'HtmlApp'
      });
    }

    /**
     * Function to suspend lightning app.
     */
    suspendLightning() {
      lightningUrl = '';
      thunder$e.call('org.rdk.RDKShell', 'suspend', {
        callsign: 'Lightning'
      });
    }

    /**
     * Function to suspend Netflix/Amazon Prime app.
     */
    suspendPremiumApp(appName) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.RDKShell', 'suspend', {
          callsign: appName
        }).then(res => {
          resolve(true);
        }).catch(err => {
          resolve(false);
        });
      });
    }

    /**
     * Function to deactivate html app.
     */
    deactivateWeb() {
      thunder$e.call('org.rdk.RDKShell', 'destroy', {
        callsign: 'HtmlApp'
      });
      activatedWeb = false;
      webUrl = '';
    }

    /**
     * Function to deactivate cobalt app.
     */
    deactivateCobalt() {
      thunder$e.call('org.rdk.RDKShell', 'destroy', {
        callsign: 'Cobalt'
      });
      activatedCobalt = false;
    }
    cobaltStateChangeEvent() {
      try {
        thunder$e.on('Controller', 'statechange', notification => {
          if (this._events.has('statechange')) {
            this._events.get('statechange')(notification);
          }
        });
      } catch (e) {
        console.log('Failed to register statechange event' + e);
      }
    }
    /**
     * Function to deactivate Netflix/Amazon Prime app.
     */
    deactivateNativeApp(appName) {
      thunder$e.call('org.rdk.RDKShell', 'destroy', {
        callsign: appName
      });
      appName === 'Amazon' ? activatedAmazon = false : activatedNetflix = false;
    }

    /**
     * Function to deactivate lightning app.
     */
    deactivateLightning() {
      thunder$e.call('org.rdk.RDKShell', 'destroy', {
        callsign: 'Lightning'
      });
      activatedLightning = false;
      lightningUrl = '';
    }

    /**
     * Function to deactivate resident app.
     */
    deactivateResidentApp(client) {
      thunder$e.call('org.rdk.RDKShell', 'destroy', {
        callsign: client
      });
    }

    /**
     * Function to set visibility to client apps.
     * @param {client} client client app.
     * @param {visible} visible value of visibility.
     */
    setVisibility(client, visible) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.RDKShell', 'setVisibility', {
          client: client,
          visible: visible
        });
        if (visible) {
          thunder$e.call('org.rdk.RDKShell', 'setFocus', {
            client: client
          }).then(res => {
            resolve(true);
          }).catch(err => {
            console.log('Set focus error', JSON.stringify(err));
            reject(false);
          });
        }
      });
    }
    visibile(client, visible) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.RDKShell', 'setVisibility', {
          client: client,
          visible: visible
        });
      });
    }
    enabledisableinactivityReporting(bool) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.RDKShell', 'enableInactivityReporting', {
          "enable": bool
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting sound mode:", JSON.stringify(err, 3, null));
          reject(err);
        });
      });
    }
    setInactivityInterval(t) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.RDKShell', 'setInactivityInterval', {
          "interval": t
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(false);
        });
      });
    }
    zorder(cli) {
      thunder$e.call('org.rdk.RDKShell', 'moveToFront', {
        client: cli,
        callsign: cli
      });
    }
    setFocus(cli) {
      thunder$e.call('org.rdk.RDKShell', 'setFocus', {
        client: cli
      });
    }
    moveToBack(cli) {
      thunder$e.call('org.rdk.RDKShell', 'moveToBack', {
        client: cli
      });
    }

    /**
    * Function to set the configuration of premium apps.
    * @param {appName} Name of the application
    * @param {config_data} config_data configuration data
    */

    configureApplication(appName, config_data) {
      let plugin = 'Controller';
      let method = 'configuration@' + appName;
      return new Promise((resolve, reject) => {
        thunder$e.call(plugin, method).then(res => {
          res.querystring = config_data;
          thunder$e.call(plugin, method, res).then(resp => {
            console.log("".concat(appName, " : updating configuration with object ").concat(res, " results in ").concat(resp));
            resolve(true);
          }).catch(err => {
            reject(err); //resolve(true)
          });
        }).catch(err => {
          reject(err);
        });
      });
    }
    /**
     * Function to launch Native app.
     * @param {String} url url of app.
     */
    launchNative(url) {
      return new Promise((resolve, reject) => {
        const childCallsign = 'testApp';
        thunder$e.call('org.rdk.RDKShell', 'launchApplication', {
          client: childCallsign,
          uri: url,
          mimeType: 'application/native'
        }).then(res => {
          console.log("Native : launching native app resulted in : ", JSON.stringify(res));
          resolve(true);
        }).catch(err => {
          console.error('org.rdk.RDKShell launch ' + JSON.stringify(err));
          reject(err);
        });
      });
    }

    /**
       * Function to kill native app.
       */
    killNative() {
      thunder$e.call('org.rdk.RDKShell', 'kill', {
        callsign: 'testApp'
      });
    }
    static pluginStatus(plugin) {
      switch (plugin) {
        case 'WebApp':
          return activatedWeb;
        case 'Cobalt':
          return activatedCobalt;
        case 'Lightning':
          return activatedLightning;
        case 'Amazon':
          return activatedAmazon;
        case 'Netflix':
          return activatedNetflix;
      }
    }
    standby(value) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'setPowerState', {
          "powerState": value,
          "standbyReason": "Requested by user"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          resolve(false);
        });
      });
    }
    enableDisplaySettings() {
      return new Promise((resolve, reject) => {
        thunder$e.call('Controller', 'activate', {
          callsign: 'org.rdk.DisplaySettings'
        }).then(result => {
          console.log('Successfully enabled DisplaySettings Service');
          resolve(result);
        }).catch(err => {
          console.error('Failed to enable DisplaySettings Service', JSON.stringify(err));
          reject(err);
        });
      });
    }
    getSoundMode() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getSoundMode', {
          "audioPort": "HDMI0"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting sound mode:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    setSoundMode(mode) {
      mode = mode.startsWith("AUTO") ? "AUTO" : mode;
      console.log("mode", mode);
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'setSoundMode', {
          "audioPort": "HDMI0",
          "soundMode": mode,
          "persist": true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in setting sound mode:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getSupportedAudioModes() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getSupportedAudioModes', {
          "audioPort": "HDMI0"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting support audio sound mode:", JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }

    //Enable or disable the specified audio port based on the input audio port ID. 
    setEnableAudioPort(port) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'setEnableAudioPort', {
          "audioPort": port,
          "enable": true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting support audio sound mode:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getDRCMode() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getDRCMode', {
          "audioPort": "HDMI0"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error while getting the DRC", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    setDRCMode(DRCNum) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'setDRCMode', {
          "DRCMode": DRCNum
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error while setting the DRC", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    getZoomSetting() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getZoomSetting').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error while getting Zoom Setting", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    setZoomSetting(zoom) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'setZoomSetting', {
          "zoomSetting": zoom
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error while setting the Zoom", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    getEnableAudioPort(audioPort) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getEnableAudioPort', {
          "audioPort": audioPort
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error while getting Enabled Audio port ", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    getSupportedAudioPorts() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getSupportedAudioPorts').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error while getting S upported audio ports ", JSON.stringify(err));
          resolve(false);
        });
      });
    }

    //________________________________________________________________________________________________________________________

    //OTHER SETTINGS PAGE API

    //1. UI VOICE

    //Start a speech
    speak() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.TextToSpeech', 'speak', {
          "text": "speech_1"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in speak:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //Resume a speech
    resume() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.TextToSpeech', 'resume', {
          "speechid": 1
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in resuming:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //Pause a speech
    pause() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.TextToSpeech', 'pause', {
          "speechid": 1
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in pausing:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // 2. TTS Options
    getlistVoices() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.TextToSpeech', 'listvoices', {
          "language": "en-US"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting voices:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // 3. Sync Location
    syncLocation() {
      return new Promise((resolve, reject) => {
        thunder$e.call('LocationSync', 'sync').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in syncing location:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getLocation() {
      return new Promise((resolve, reject) => {
        thunder$e.call('LocationSync', 'location').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting location:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    // 4. Check for Firmware Update

    //Get Firmware Update Info
    getFirmwareUpdateInfo() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'getFirmwareUpdateInfo').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting firmware update info:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // Get Firmware Update State
    getFirmwareUpdateState() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'getFirmwareUpdateState').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting firmware update state:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    // Get Firmware download info
    getDownloadFirmwareInfo() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'getDownloadedFirmwareInfo').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting downloaded info:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //Get serial number
    getSerialNumber() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'getSerialNumber').then(result => {
          console.log(JSON.stringify(result, 3, null));
          resolve(result);
        }).catch(err => {
          resolve('N/A');
        });
      });
    }

    //Get system versions
    getSystemVersions() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'getSystemVersions').then(result => {
          console.log(JSON.stringify(result, 3, null));
          resolve(result);
        }).catch(err => {
          console.log("error in getting downloaded percentage:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //Update firmware
    updateFirmware() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'updateFirmware').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in firmware update:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //Get download percentage
    getFirmwareDownloadPercent() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'getFirmwareDownloadPercent').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting downloaded percentage:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // device Identification
    getDeviceIdentification() {
      return new Promise((resolve, reject) => {
        thunder$e.call('DeviceIdentification', 'deviceidentification').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting device Identification:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // 5. Device Info
    systeminfo() {
      return new Promise((resolve, reject) => {
        thunder$e.call('DeviceInfo', 'systeminfo').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting system info:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // 6. Reboot
    reboot() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'reboot', {
          "rebootReason": "FIRMWARE_FAILURE"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in reboot:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getNetflixESN() {
      return new Promise(resolve => {
        thunder$e.call('Netflix', 'esn').then(res => {
          resolve(res);
        });
      });
    }

    // get prefered standby mode

    getPreferredStandbyMode() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'getPreferredStandbyMode').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getPreferredStandbyMode:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    setPreferredStandbyMode(standbyMode) {
      console.log("setPreferredStandbyMode called : " + standbyMode);
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.System', 'setPreferredStandbyMode', {
          "standbyMode": standbyMode
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in setPreferredStandbyMode:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    registerChangeLocation() {
      var callsign = "LocationSync";
      thunder$e.call('Controller', 'activate', {
        callsign: callsign
      }).then(result => {
        thunder$e.on(callsign, "locationchange", notification => {
          console.log("location was changed and the notification = ", notification);
        });
      }).catch(err => {
        console.log(err);
      });
    }
    async sendAppState(value) {
      const state = await thunder$e.call('org.rdk.RDKShell', 'getState', {}).then(result => result.state);
      this.state = state;
      let params = {
        applicationName: value,
        state: 'stopped'
      };
      for (var i = 0; i < state.length; i++) {
        if (state[i].callsign == value) {
          if (state[i].state == 'resumed') {
            activatedCobalt = true;
            params.state = 'running';
          } else if (state[i].state == 'suspended') {
            params.state = 'suspended';
          } else {
            params.state = 'stopped';
          }
        }
      }
      if (params.state === 'stopped') {
        activatedCobalt = false;
      }
      await thunder$e.call('org.rdk.Xcast', 'onApplicationStateChanged', params).then(result => result.success);
    }
    //NETWORK INFO APIS

    //1. Get IP Setting
    getIPSetting(defaultInterface) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.Network', 'getIPSettings', {
          "interface": defaultInterface
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting network info:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //2. Get default interface
    getDefaultInterface() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.Network', 'getDefaultInterface').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting default interface:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //3. Is interface enabled
    isInterfaceEnabled() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.Network', 'isInterfaceEnabled', {
          "interface": "WIFI"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in checking the interface:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //4. Get interfaces
    getInterfaces() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.Network', 'getInterfaces').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting interfaces:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //5. getConnectedSSID
    getConnectedSSID() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.Wifi', 'getConnectedSSID').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("error in getting connected SSID:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // Volume Apis

    getConnectedAudioPorts() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getConnectedAudioPorts', {}).then(result => {
          resolve(result);
        }).catch(err => {
          console.log('audio mute error:', JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }
    getVolumeLevel(port) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getVolumeLevel', {
          audioPort: port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log('audio mute error:', JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }
    muteStatus(port) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'getMuted', {
          audioPort: port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log('audio mute error:', JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }
    setVolumeLevel(port, volume) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'setVolumeLevel', {
          audioPort: port,
          volumeLevel: volume
        }).then(result => {
          console.log('############ setVolumeLevel #############');
          console.log(JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log('error while setting current volume level', JSON.stringify(err));
          resolve(false);
        });
      });
    }
    audio_mute(audio_source, value) {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.DisplaySettings', 'setMuted', {
          audioPort: audio_source,
          muted: value
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log('audio mute error:', JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    //created only to get the required params
    getPluginStatusParams(plugin) {
      return new Promise((resolve, reject) => {
        thunder$e.call('Controller', "status@".concat(plugin)).then(result => {
          console.log("pluginstatus", result);
          let pluginParams = [result[0].callsign, result[0].state];
          resolve(pluginParams);
        }).catch(err => {
          console.log("pluginstatusErr", err);
          reject(err);
        });
      });
    }
    //activate autopairing for stack
    activateAutoPairing() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.RemoteControl', 'startPairing', {
          "netType": '1',
          "timeout": '30'
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.log(' remote autoPair plugin error:', JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var appListInfo = [{
    displayName: 'USB',
    applicationType: '',
    uri: 'USB',
    url: '/images/usb/USB_Featured_Item.jpg'
  },
  //the first item should be usb
  {
    displayName: 'Netflix',
    applicationType: 'Netflix',
    uri: '',
    url: '/images/apps/App_Netflix_454x255.png'
  }, {
    displayName: 'Amazon Prime video',
    applicationType: 'Amazon',
    uri: '',
    url: '/images/apps/App_Amazon_Prime_454x255.png'
  }, {
    displayName: 'Youtube',
    applicationType: 'Cobalt',
    uri: 'https://www.youtube.com/tv',
    url: '/images/apps/App_YouTube_454x255.png'
  }, {
    displayName: 'Peacock',
    applicationType: 'LightningApp',
    uri: 'https://tv.clients.peacocktv.com/lightning/rc/prod/browser/5dcb818/',
    url: '/images/apps/App_Peacock_454x255.png'
  }, {
    displayName: 'Xumo',
    applicationType: 'HtmlApp',
    uri: 'https://x1box-app.xumo.com/index.html',
    url: '/images/apps/App_Xumo_454x255.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var appListInfoOffline = [{
    displayName: 'USB',
    applicationType: '',
    uri: 'USB',
    url: '/images/usb/USB_Featured_Item.jpg'
  },
  //the first item should be usb
  {
    displayName: 'Netflix',
    applicationType: 'Netflix',
    uri: '',
    url: '/images/apps/App_Netflix_454x255.png'
  }, {
    displayName: 'Amazon Prime video',
    applicationType: 'Amazon',
    uri: '',
    url: '/images/apps/App_Amazon_Prime_454x255.png'
  }, {
    displayName: 'Youtube',
    applicationType: 'Cobalt',
    uri: 'https://www.youtube.com/tv',
    url: '/images/apps/App_YouTube_454x255.png'
  }, {
    displayName: 'Peacock',
    applicationType: 'LightningApp',
    uri: 'https://tv.clients.peacocktv.com/lightning/rc/prod/browser/5dcb818/',
    url: '/images/apps/App_Peacock_454x255.png' //replace with online url
  }, {
    displayName: 'Xumo',
    applicationType: 'HtmlApp',
    uri: 'https://x1box-app.xumo.com/index.html',
    url: '/images/apps/App_Xumo_454x255.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for tv shows listings.
   */
  var tvShowsInfo = [{
    displayName: 'Fantasy-Island',
    url: '/images/tvShows/fantasy-island.jpg'
  }, {
    displayName: 'Onward',
    url: '/images/tvShows/onward.jpg'
  }, {
    displayName: 'Let it Snow',
    url: '/images/tvShows/let-it-snow.jpg'
  }, {
    displayName: 'Do Little',
    url: '/images/tvShows/do-little.jpg'
  }, {
    displayName: 'Summerland',
    url: '/images/tvShows/summerland.jpg'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for settings listings.
   */
  var settingsInfo = [{
    displayName: 'Bluetooth',
    url: '/images/settings/bluetooth.jpg'
  }, {
    displayName: 'Wi-Fi',
    url: '/images/settings/wifi.jpg'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for listings in side panel.
   */
  var sidePanelInfo = [{
    title: 'Apps',
    url: '/images/sidePanel/menu.png'
  }, {
    title: 'Metro Apps',
    url: '/images/sidePanel/metro.png'
  }, {
    title: 'TV Shows',
    url: '/images/sidePanel/video.png'
  }, {
    title: 'Settings',
    url: '/images/sidePanel/settings.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var rightArrowInfo = [{
    url: '/images/right-small.png'
  }, {
    url: '/images/right-small.png'
  }, {
    url: '/images/right-small.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var leftArrowInfo = [{
    url: '/images/left-small.png'
  }, {
    url: '/images/left-small.png'
  }, {
    url: '/images/left-small.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for UI selection.
   */
  var uiInfo = [{
    title: 'DEFAULT',
    url: '/images/splash/DefaultUI.png',
    uri: ''
  }, {
    title: 'LIVE',
    url: '/images/splash/LiveTv.png',
    uri: 'http://35.155.171.121:8088/index.html'
  }, {
    title: 'TATA',
    url: '/images/splash/TataElxsi.png',
    uri: 'http://35.155.171.121:8088/index.html'
  }, {
    title: 'NEW',
    url: '/images/splash/NewUi.png',
    uri: 'https://px-apps.sys.comcast.net/lightning_apps/diagnostics/dist/index.html'
  }, {
    title: 'COMINGSOON',
    url: '/images/splash/ComingSoon.png',
    uri: 'https://px-apps.sys.comcast.net/lightning_apps/diagnostics/dist/index.html'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for metro app listings.
   */
  var metroAppsInfo = [{
    displayName: "CNN",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.CNN",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.CNN.png"
  }, {
    displayName: "VimeoRelease",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.VimeoRelease",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.VimeoRelease.png"
  }, {
    displayName: "WeatherNetwork",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WeatherNetwork",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.WeatherNetwork.png"
  }, {
    displayName: "EuroNews",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Euronews",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.Euronews.png"
  }, {
    displayName: "AccuWeather",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.AccuWeather",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.AccuWeather.png"
  }, {
    displayName: "BaebleMusic",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.BaebleMusic",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.BaebleMusic.png"
  }, {
    displayName: "Aljazeera",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aljazeera",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.Aljazeera.png"
  }, {
    displayName: "GuessThatCity",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.GuessThatCity",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.GuessThatCity.png"
  }, {
    displayName: "Radioline",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Radioline",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.Radioline.png"
  }, {
    displayName: "WallStreetJournal",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WallStreetJournal",
    url: "https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.WallStreetJournal.png"
  }, {
    displayName: "FRacer",
    applicationType: "LightningApp",
    uri: "https://lightningjs.io/fracer/#main",
    url: "/images/metroApps/fracer-steerling.png"
  }, {
    displayName: "Aquarium",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aquarium",
    url: "/images/metroApps/Aquarium.png"
  }, {
    displayName: "Fireplace",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Fireplace",
    url: "/images/metroApps/Fireplace.png"
  }, {
    displayName: "Deutsche Welle",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.DW",
    url: "/images/metroApps/DWelle.png"
  }, {
    displayName: "MyTuner Radio",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.appgeneration.mytuner",
    url: "/images/metroApps/Radio.png"
  }, {
    displayName: "Sudoku",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sudoku",
    url: "/images/metroApps/Sudoku.png"
  }, {
    displayName: "Tastemade",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Tastemade",
    url: "/images/metroApps/Tastemade.png"
  }, {
    displayName: "Bloomberg",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.bloomberg.metrological.x1",
    url: "/images/metroApps/Bloomberg.png"
  }, {
    displayName: "Playworks",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.playworks.pwkids",
    url: "/images/metroApps/Playworks.png"
  }, {
    displayName: "Sunrise",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sunrise",
    url: "/images/metroApps/Sunrise.png"
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for metro app listings.
   */
  var metroAppsInfoOffline = [{
    displayName: "CNN",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.CNN",
    url: "/images/metroApps/Test-01.jpg"
  }, {
    displayName: "VimeoRelease",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.VimeoRelease",
    url: "/images/metroApps/Test-02.jpg"
  }, {
    displayName: "WeatherNetwork",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WeatherNetwork",
    url: "/images/metroApps/Test-03.jpg"
  }, {
    displayName: "EuroNews",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Euronews",
    url: "/images/metroApps/Test-04.jpg"
  }, {
    displayName: "AccuWeather",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.AccuWeather",
    url: "/images/metroApps/Test-05.jpg"
  }, {
    displayName: "BaebleMusic",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.BaebleMusic",
    url: "/images/metroApps/Test-06.jpg"
  }, {
    displayName: "Aljazeera",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aljazeera",
    url: "/images/metroApps/Test-07.jpg"
  }, {
    displayName: "GuessThatCity",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.GuessThatCity",
    url: "/images/metroApps/Test-08.jpg"
  }, {
    displayName: "Radioline",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Radioline",
    url: "/images/metroApps/Test-09.jpg"
  }, {
    displayName: "WallStreetJournal",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WallStreetJournal",
    url: "/images/metroApps/Test-10.jpg"
  }, {
    displayName: "FRacer",
    applicationType: "LightningApp",
    uri: "https://lightningjs.io/fracer/#main",
    url: "/images/metroApps/fracer-steerling.png"
  }, {
    displayName: "Aquarium",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aquarium",
    url: "/images/metroApps/Aquarium.png"
  }, {
    displayName: "Fireplace",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Fireplace",
    url: "/images/metroApps/Fireplace.png"
  }, {
    displayName: "Deutsche Welle",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.DW",
    url: "/images/metroApps/DWelle.png"
  }, {
    displayName: "MyTuner Radio",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.appgeneration.mytuner",
    url: "/images/metroApps/Radio.png"
  }, {
    displayName: "Sudoku",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sudoku",
    url: "/images/metroApps/Sudoku.png"
  }, {
    displayName: "Tastemade",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Tastemade",
    url: "/images/metroApps/Tastemade.png"
  }, {
    displayName: "Bloomberg",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.bloomberg.metrological.x1",
    url: "/images/metroApps/Bloomberg.png"
  }, {
    displayName: "Playworks",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.playworks.pwkids",
    url: "/images/metroApps/Playworks.png"
  }, {
    displayName: "Sunrise",
    applicationType: "LightningApp",
    uri: "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sunrise",
    url: "/images/metroApps/Sunrise.png"
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  var showCaseApps = [{
    displayName: "Strike Benchmark",
    applicationType: "LightningApp",
    uri: "https://strike.lightningjs.io/es6/#home",
    url: "/images/lightningApps/strike_app.png"
  }, {
    displayName: "TMBD App",
    applicationType: "LightningApp",
    uri: "https://lightningjs.io/tmdb/#splash",
    url: "/images/lightningApps/tmbd.png"
  }];

  var lib = {};

  var __assign = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  var defaultOptions = {
    aloneValueName: '_@attribute'
  };
  /**
   * Main function. Clears the given xml and then starts the recursion
   * @param xmlStr
   * @param options the options
   */
  function xml2json(xmlStr, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var opt = __assign(__assign({}, defaultOptions), options);
    xmlStr = cleanXML(xmlStr, opt.aloneValueName);
    return xml2jsonRecurse(xmlStr, opt);
  }
  var _default = lib.default = xml2json;
  /**
   * Recursive function that creates a JSON object with a given XML string.
   *
   * @param xmlStr
   * @param options the options
   */
  function xml2jsonRecurse(xmlStr, options) {
    var obj = {};
    var startTagMatch;
    while (startTagMatch = xmlStr.match(/<[^\/][^>]*>/)) {
      var openingTag = startTagMatch[0];
      var tagName = openingTag.substring(1, openingTag.length - 1);
      var indexClosingTag = xmlStr.indexOf(openingTag.replace('<', '</'));
      // account for case where additional information in the opening tag
      var closingTagMatch = void 0;
      if (indexClosingTag == -1 && (closingTagMatch = openingTag.match(/[^<][\S+$]*/))) {
        tagName = closingTagMatch[0];
        indexClosingTag = xmlStr.indexOf('</' + tagName);
        if (indexClosingTag == -1) {
          indexClosingTag = xmlStr.indexOf('<\\/' + tagName);
        }
      }
      var inner_substring = xmlStr.substring(openingTag.length, indexClosingTag);
      var tempVal = inner_substring.match(/<[^\/][^>]*>/) ? xml2json(inner_substring, options) : inner_substring;
      // account for array or obj
      if (obj[tagName] === undefined) {
        obj[tagName] = tempVal;
      } else if (Array.isArray(obj[tagName])) {
        obj[tagName].push(tempVal);
      } else {
        obj[tagName] = [obj[tagName], tempVal];
      }
      xmlStr = xmlStr.substring(openingTag.length * 2 + 1 + inner_substring.length);
    }
    return obj;
  }
  /**
   * Removes some characters that would break the recursive function.
   *
   * @param xmlStr
   * @param aloneValueName
   * @returns {string}
   */
  function cleanXML(xmlStr, aloneValueName) {
    xmlStr = xmlStr.replace(/<!--[\s\S]*?-->/g, ''); // remove commented lines
    xmlStr = xmlStr.replace(/[\n\t\r]/g, ''); // replace special characters
    xmlStr = xmlStr.replace(/>[ \t]+</g, '><'); // replace leading spaces and tabs betweet elements
    xmlStr = xmlStr.replace(/<\?[^>]*\?>/g, ''); // delete docType tags
    xmlStr = replaceSelfClosingTags(xmlStr); // replace self closing tags
    xmlStr = replaceAloneValues(xmlStr, aloneValueName); // replace the alone tags values
    xmlStr = replaceAttributes(xmlStr); // replace attributes
    return xmlStr;
  }
  /**
   * Replaces all the self closing tags with attributes with another tag containing its attribute as a property.
   * The function works if the tag contains multiple attributes.
   * Example : '<tagName attrName="attrValue" />' becomes
   *           '<tagName><attrName>attrValue</attrName></tagName>'
   * @param xmlStr
   * @returns {*}
   */
  function replaceSelfClosingTags(xmlStr) {
    var selfClosingTags = xmlStr.match(/<[^/][^>]*\/>/g);
    if (!selfClosingTags) {
      return xmlStr;
    }
    for (var i = 0; i < selfClosingTags.length; i++) {
      var oldTag = selfClosingTags[i];
      var match = oldTag.match(/[^<][\S+$]*/);
      if (match) {
        var tagName = match[0];
        var closingTag = "</" + tagName + ">";
        var newTag = extractAttributeValue(tagName, oldTag) + closingTag;
        xmlStr = xmlStr.replace(oldTag, newTag);
      }
    }
    return xmlStr;
  }
  /**
   *  Replaces all the tags with attributes and a value with a new tag.
   *
   *  Example : '<tagName attrName="attrValue">tagValue</tagName>' becomes
   *  '<tagName><attrName>attrValue</attrName><_@attribute>tagValue</_@attribute></tagName>'
   *
   * @param xmlStr
   * @param aloneValueName
   * @returns {string}
   */
  function replaceAloneValues(xmlStr, aloneValueName) {
    var tagsWithAttributesAndValue = xmlStr.match(/<[^\/][^>][^<]+\s+.[^<]+[=][^<]+>([^<]+)/g);
    if (!tagsWithAttributesAndValue) {
      return xmlStr;
    }
    for (var i = 0; i < tagsWithAttributesAndValue.length; i++) {
      var oldTag = tagsWithAttributesAndValue[i];
      var oldTagName = oldTag.substring(0, oldTag.indexOf(">") + 1);
      var oldTagValue = oldTag.substring(oldTag.indexOf(">") + 1);
      var newTag = oldTagName + "<" + aloneValueName + ">" + oldTagValue + "</" + aloneValueName + ">";
      xmlStr = xmlStr.replace(oldTag, newTag);
    }
    return xmlStr;
  }
  function extractAttributeValue(tagName, oldTag) {
    var newTag = "<" + tagName + ">";
    var attrs = oldTag.match(/(\S+)\s?=\s?((?:"[^"]+")|(?:'[^']+'))/g);
    if (!attrs) {
      return newTag;
    }
    for (var j = 0; j < attrs.length; j++) {
      var attr = attrs[j];
      var attrName = attr.substring(0, attr.indexOf('=')).trim();
      var quote = attr[attr.length - 1];
      var attrValue = attr.substring(attr.indexOf(quote) + 1, attr.lastIndexOf(quote));
      newTag += "<" + attrName + ">" + attrValue + "</" + attrName + ">";
    }
    return newTag;
  }
  /**
   * Replaces all the tags with attributes with another tag containing its attribute as a property.
   * The function works if the tag contains multiple attributes.
   *
   * Example : '<tagName attrName="attrValue"></tagName>' becomes '<tagName><attrName>attrValue</attrName></tagName>'
   *
   * @param xmlStr
   * @returns {*}
   */
  function replaceAttributes(xmlStr) {
    var tagsWithAttributes = xmlStr.match(/<[^\/><]\S+\s+[^<]+[=][^<]+>/g);
    if (!tagsWithAttributes) {
      return xmlStr;
    }
    for (var i = 0; i < tagsWithAttributes.length; i++) {
      var oldTag = tagsWithAttributes[i];
      var match = oldTag.match(/[^<]\S*/);
      if (match) {
        var tagName = match[0];
        var newTag = extractAttributeValue(tagName, oldTag);
        xmlStr = xmlStr.replace(oldTag, newTag);
      }
    }
    return xmlStr;
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let partnerApps = [];

  /**
   * Get the ip address.
   */
  let IpAddress1 = "";
  let IpAddress2 = "";
  let networkApi = new Network();
  networkApi.getIP().then(ip => {
    IpAddress1 = ip;
    Storage.set("ipAddress", IpAddress1);
  }).catch(() => {
    Storage.set("ipAddress", null);
  });
  let appApi$b = new AppApi();
  appApi$b.getIP().then(ip => {
    IpAddress2 = ip;
  });

  /**
   * Class that returns the data required for home screen.
   */
  class HomeApi {
    /**
     * Function to get details for app listing.
     */
    getAppListInfo() {
      let appsMetaData;
      if (IpAddress1 || IpAddress2) {
        appsMetaData = appListInfo;
      } else {
        appsMetaData = appListInfoOffline;
      }
      return appsMetaData;
    }

    /**
     * Function to get details for tv shows listings.
     */
    getTVShowsInfo() {
      return tvShowsInfo;
    }

    /**
     * Function to get details for settings listings.
     */
    getSettingsInfo() {
      return settingsInfo;
    }

    /**
     * Function to get details for lightning showcase apps.
     */
    getShowCaseApps() {
      return showCaseApps;
    }

    /**
     * Function to get details for all apps.
     */
    getAllApps() {
      return [...this.getAppListInfo(), ...this.getMetroInfo(), ...this.getShowCaseApps()];
    }

    /**
     * Function to get details for side panel.
     */
    getSidePanelInfo() {
      return sidePanelInfo;
    }

    /**
     * Function to get details of different UI
     */
    getUIInfo() {
      return uiInfo;
    }

    /**
     * Function to details of metro apps
     */
    getMetroInfo() {
      let metroAppsMetaData;
      if (IpAddress1 || IpAddress2) {
        metroAppsMetaData = metroAppsInfo;
      } else {
        metroAppsMetaData = metroAppsInfoOffline;
      }
      return metroAppsMetaData;
    }
    getOfflineMetroApps() {
      return metroAppsInfoOffline;
    }
    getOnlineMetroApps() {
      return metroAppsInfo;
    }

    /**
     * Function to store partner app details.
     * @param {obj} data Partner app details.
     */
    setPartnerAppsInfo(data) {
      partnerApps = data;
    }

    /**
     *Function to return partner app details.
     */
    getPartnerAppsInfo() {
      return partnerApps;
    }
    /**
     * Function to details of right arrow
     */
    getRightArrowInfo() {
      return rightArrowInfo;
    }
    /**
     * Function to details of left arrow
     */
    getLeftArrowInfo() {
      return leftArrowInfo;
    }
    getMovieSubscriptions(id) {
      return new Promise((resolve, reject) => {
        appApi$b.fetchApiKey().then(res => {
          // console.log("Key is: ", res);
          // console.log("tmsID is :", id);
          try {
            fetch("http://feeds.tmsapi.com/v2/movies/" + id + ".xml?api_key=" + res).then(response => response.text()).then(res => {
              resolve(_default(res));
            });
          } catch (err) {
            console.log("API key not defined");
          }
        });
      });
    }
    getAPIKey() {
      return new Promise((resolve, reject) => {
        appApi$b.fetchApiKey().then(res => {
          let [day, month, year] = [new Date().getUTCDate(), new Date().getUTCMonth(), new Date().getUTCFullYear()];
          month += 1;
          day = day.toString();
          month = month.toString();
          //fetch date time from the thunder plugins and pass it to the url
          try {
            fetch("http://data.tmsapi.com/v1.1/movies/airings?lineupId=USA-TX42500-X&startDateTime=" + year + "-" + month + "-" + day + "T08%3A00Z&includeAdult=false&imageSize=Lg&imageAspectTV=16x9&imageText=true&api_key=" + res).then(response => response.json()).then(response => {
              const ids = response.map(id => id.program.rootId);
              const filtered = response.filter((_ref, index) => {
                let {
                  program
                } = _ref;
                return !ids.includes(program.rootId, index + 1);
              });
              resolve({
                key: res,
                data: filtered.slice(0, 20)
              });
            }).catch(err => {
              console.log("Incorrect API key or no data available");
              resolve({
                key: res,
                data: []
              });
            });
          } catch (err) {
            console.log("API key not defined");
            resolve({
              key: res,
              data: []
            });
          }
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**Color constants */
  var COLORS = {
    textColor: 0xffffffff,
    titleColor: 0xffffffff,
    hightlightColor: 0xffc0c0c0,
    headingColor: 0xffffffff
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class SettingsItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: false
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SettingsMainItem extends SettingsItem {
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90,
          rect: true,
          color: 0x00000000
        },
        BottomLine: {
          y: 0 + 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {}
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$c = {
    host: "127.0.0.1",
    port: 9998,
    default: 1
  };
  const thunder$d = thunderJS(config$c);
  const systemcCallsign$2 = "DTV";
  let playerID = -1; //set to -1 to indicate nothing is currently playing

  //plugin is activated by default, no need to call explicitly
  class DTVApi {
    activate() {
      return new Promise((resolve, reject) => {
        thunder$d.Controller.activate({
          callsign: systemcCallsign$2
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log("DTV Error Activation", err);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        thunder$d.Controller.deactivate({
          callsign: systemcCallsign$2
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log("DTV Error Deactivation", err);
          reject(err);
        });
      });
    }
    //gets the number of available countries
    noOfCountries() {
      return new Promise((resolve, reject) => {
        thunder$d.call(systemcCallsign$2, "numberOfCountries").then(result => {
          resolve(result);
        }).catch(err => {
          console.log("Error: noOfCountries: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    //returns the list of the available countries
    countryList() {
      return new Promise((resolve, reject) => {
        thunder$d.call(systemcCallsign$2, "countryList").then(result => {
          resolve(result);
        }).catch(err => {
          console.log("Error: countryList: ", JSON.stringify(err));
          reject(err);
        });
      });
    }

    //returns the list of services(channels with name, uri and other details)
    serviceList() {
      let arr = [{
        shortname: 'Amazon Prime',
        dvburi: 'OTT',
        lcn: 0
      }, {
        shortname: 'Netflix',
        dvburi: 'OTT',
        lcn: 0
      }, {
        shortname: 'Youtube',
        dvburi: 'OTT',
        lcn: 0
      }];
      return new Promise((resolve, reject) => {
        thunder$d.call(systemcCallsign$2, "serviceList@dvbs").then(result => {
          arr = arr.concat(result);
          console.log("serviceListResult: ", JSON.stringify(arr));
          resolve(arr);
        }).catch(err => {
          console.log("Error: serviceList: ", JSON.stringify(err));
          resolve(arr);
        });
      });
    }

    //returns the schedule for the given channel with provided dvburi
    scheduleEvents(dvburi) {
      let method = 'scheduleEvents@' + dvburi;
      return new Promise((resolve, reject) => {
        thunder$d.call(systemcCallsign$2, method).then(result => {
          console.log("scheduleEventsResult: ", JSON.stringify(result));
          for (let show of result) {
            show.starttime *= 1000;
            show.duration *= 1000;
          }
          resolve(result);
        }).catch(err => {
          console.log("Error: scheduleEvents: ", JSON.stringify(err));
          reject(err);
        });
      });
    }

    //lists the satellites available
    satelliteList() {
      return new Promise((resolve, reject) => {
        // resolve([{name: "Satellite 1",longitude: 282,lnb: "Universal" },{name: "Satellite 2",longitude: 282,lnb: "Universal" }]) //#forTesting
        thunder$d.call(systemcCallsign$2, "satelliteList").then(result => {
          if (result.length === 0) {
            result = [{
              "name": "Astra 28.2E",
              "longitude": 282,
              "lnb": "Universal"
            }];
          }
          resolve(result);
        }).catch(err => {
          console.log("Error: satelliteList: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    //returns the available polarity options for dvb-s scan, returns a list of static values
    polarityList() {
      return new Promise((resolve, reject) => {
        resolve(["horizontal", "vertical", "left", "right"]);
      });
    }

    //returns the available symbolRate options for dvb-s scan, returns a list of static values
    symbolRateList() {
      return new Promise((resolve, reject) => {
        resolve(["22000", "23000", "27500", "29500"]); //values can be edited/entered custom from UI, no need to mention custom here
      });
    }
    //returns the available FEC options for dvb-s scan, returns a list of static values
    fecList() {
      return new Promise((resolve, reject) => {
        resolve(["fecauto", "fec1_2", "fec2_3", "fec3_4", "fec5_6", "fec7_8", "fec1_4", "fec1_3", "fec2_5", "fec8_9", "fec9_10", "fec3_5", "fec4_5"]);
      });
    }
    //returns the available modulation options for dvb-s scan, returns a list of static values
    modulationList() {
      return new Promise((resolve, reject) => {
        resolve(["auto", "qpsk", "8psk", "16qam"]);
      });
    }
    //returns the available searchtype(searchmode) options for dvb-s scan, returns a list of static values
    searchtypeList() {
      return new Promise((resolve, reject) => {
        resolve(["frequency", "network"]);
      });
    }
    //initiates a service search for the provided params
    startServiceSearch(params) {
      return new Promise((resolve, reject) => {
        thunder$d.call(systemcCallsign$2, "startServiceSearch", params).then(result => {
          //console.log("serviceSearchResult: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("serviceSearchError: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    //returns the number of available services(channels)
    noOfServices() {
      return new Promise((resolve, reject) => {
        thunder$d.call(systemcCallsign$2, "numberOfServices").then(result => {
          //console.log("numberOfServicesResult: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("Error: numberOfServices: ", JSON.stringify(err));
          reject(err);
        });
      });
    }

    //returns the current and next event details for the given channel with provided dvburi
    nowNextEvents(dvburi) {
      let method = "nowNextEvents@" + dvburi;
      return new Promise((resolve, reject) => {
        thunder$d.call(systemcCallsign$2, method).then(result => {
          //console.log("nowNextEventsResult: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("Error: nowNextEvents: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    startPlaying(params) {
      //params contains dvburi and lcn
      console.log("PARAMS: startPlaying: ", JSON.stringify(params));
      if (playerID !== -1) {
        this.stopPlaying();
        return Promise.reject("something is still playing Please retry");
      }
      return new Promise((resolve, reject) => {
        thunder$d.call(systemcCallsign$2, "startPlaying", params).then(result => {
          console.log("RESULT: startPlaying: ", JSON.stringify(result));
          if (result === -1) {
            reject("Can't be played");
          } else {
            playerID = result; //to be used in stopPlaying method
            resolve(result);
          }
        }).catch(err => {
          console.log("ERROR: startPlaying: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    stopPlaying() {
      return new Promise((resolve, reject) => {
        thunder$d.call(systemcCallsign$2, "stopPlaying", playerID).then(result => {
          //playerID is retuned from startPlaying method
          console.log("RESULT: stopPlaying: ", JSON.stringify(result)); //result is always null
          playerID = -1; //to set that nothing is being played currently
          resolve(true);
        }).catch(err => {
          console.log("ERROR: stopPlaying: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    launchChannel(dvburi) {
      console.log("PARAMS: launchChannel: ", JSON.stringify(dvburi));
      if (playerID !== -1) {
        this.exitChannel();
        console.log("launchChannel: FAIL: something is still playing, trying to call exitChannel");
        return Promise.reject("Fail: something is still playing");
      }
      return new Promise((resolve, reject) => {
        let port = "8080"; //try to fetch it later
        let cmd = "open"; //add other methods also
        let url = "http://127.0.0.1:" + port + "/vldms/sessionmgr/" + cmd;
        let data = {
          "openRequest": {
            "type": "main",
            "locator": "dtv://" + dvburi,
            "playerParams": {
              "subContentType": "live",
              "window": "0,0,1920,1080",
              "videoBlank": false
            }
          }
        };
        let params = {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(data)
        };
        console.log("launchChannel: url & params: ", JSON.stringify(url), JSON.stringify(params));
        fetch(url, params).then(response => response.json()).then(result => {
          console.log("launchChannel: SUCCESS: ", JSON.stringify(result));
          playerID = result.openStatus.sessionId;
          console.log("launchChannel: SESSIONID: ", playerID);
          resolve(result);
        }).catch(err => {
          console.log("launchChannel: FAILED: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    exitChannel() {
      return new Promise((resolve, reject) => {
        let port = "8080"; //try to fetch it later
        let cmd = "close"; //add other methods also
        let url = "http://127.0.0.1:" + port + "/vldms/sessionmgr/" + cmd;
        let data = {
          "closeRequest": {
            "sessionId": playerID
          }
        };
        let params = {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(data)
        };
        console.log("exitChannel: url & params: ", JSON.stringify(url), JSON.stringify(params));
        fetch(url, params).then(response => response.json()).then(result => {
          console.log("exitChannel: SUCCESS: ", JSON.stringify(result));
          playerID = -1;
          resolve(result);
        }).catch(err => {
          console.log("exitChannel: FAILED: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$b = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  var thunder$c = thunderJS(config$b);

  /**
   * Class for settings screen.
   */
  class SettingsScreen extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        SettingsScreenContents: {
          x: 200,
          y: 275,
          NetworkConfiguration: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Network Configuration'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Bluetooth: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Pair Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Video: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Video'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Audio: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Audio'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OtherSettings: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Other Settings'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NFRStatus: {
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Native Frame Rate'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          DTVSettings: {
            alpha: 0.3,
            y: 540,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Live TV'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this.appApi = new AppApi();
      this._setState('NetworkConfiguration');
    }
    _focus() {
      this._setState(this.state);
    }
    _firstActive() {
      if (Storage.get("NFRStatus")) {
        console.log("Netflix : NFRStatus is found to be enabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
      } else {
        console.log("Netflix : NFRStatus is found to be disabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
      }
      this.dtvApi = new DTVApi();
      this.dtvPlugin = false; //plugin availability
      this.dtvApi.activate().then(res => {
        // if (res){
        this.dtvPlugin = true;
        this.tag("DTVSettings").alpha = 1;
        // }
      });
    }

    _handleBack() {
      console.log("application Type = ", Storage.get("applicationType"));
      if (Storage.get("applicationType") == "") {
        Router.navigate('menu');
      } else {
        this.appApi.visibile("ResidentApp", false);
        let appType = Storage.get("applicationType");
        if (appType === "WebApp") {
          appType = "HtmlApp";
        }
        this.appApi.setFocus(appType);
        this.appApi.zorder(appType);
      }
    }
    static _states() {
      return [class NetworkConfiguration extends this {
        $enter() {
          this.tag('NetworkConfiguration')._focus();
        }
        $exit() {
          this.tag('NetworkConfiguration')._unfocus();
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          Router.navigate('settings/network');
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag('Bluetooth')._focus();
        }
        $exit() {
          this.tag('Bluetooth')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkConfiguration');
        }
        _handleDown() {
          this._setState('Video');
        }
        _handleLeft() {}
        _handleEnter() {
          Router.navigate('settings/bluetooth');
        }
      }, class Video extends this {
        $enter() {
          this.tag('Video')._focus();
        }
        $exit() {
          this.tag('Video')._unfocus();
        }
        _handleUp() {
          this._setState('Bluetooth');
        }
        _handleDown() {
          this._setState('Audio');
        }
        _handleEnter() {
          Router.navigate('settings/video');
        }
      }, class Audio extends this {
        $enter() {
          this.tag('Audio')._focus();
        }
        $exit() {
          this.tag('Audio')._unfocus();
        }
        _handleUp() {
          this._setState('Video');
        }
        _handleEnter() {
          Router.navigate('settings/audio');
        }
        _handleDown() {
          this._setState('OtherSettings');
        }
      }, class OtherSettings extends this {
        $enter() {
          this.tag('OtherSettings')._focus();
        }
        $exit() {
          this.tag('OtherSettings')._unfocus();
        }
        _handleUp() {
          this._setState('Audio');
        }
        _handleEnter() {
          Router.navigate('settings/other');
        }
        _handleDown() {
          this._setState("NFRStatus");
        }
      }, class NFRStatus extends this {
        $enter() {
          this.tag('NFRStatus')._focus();
        }
        $exit() {
          this.tag('NFRStatus')._unfocus();
        }
        _handleUp() {
          this._setState('OtherSettings');
        }
        _handleDown() {
          if (this.dtvPlugin) {
            this._setState('DTVSettings');
          }
        }
        _handleEnter() {
          //handle Switch
          let self = this;
          if (Storage.get("NFRStatus")) {
            thunder$c.call("Netflix.1", "nfrstatus", {
              "params": "disable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
              Storage.set("NFRStatus", false);
              console.log("Netflix : nfr disable updation results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus");
              console.error(nerr);
            });
          } else {
            thunder$c.call("Netflix.1", "nfrstatus", {
              "params": "enable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
              Storage.set("NFRStatus", true);
              console.log("Netflix : nfr enable results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus ");
              console.error(nerr);
            });
          }
        }
      }, class DTVSettings extends this {
        $enter() {
          this.tag('DTVSettings')._focus();
        }
        $exit() {
          this.tag('DTVSettings')._unfocus();
        }
        _handleUp() {
          this._setState('NFRStatus');
        }
        _handleEnter() {
          if (this.dtvPlugin) {
            Router.navigate('settings/livetv');
          }
          // dtvApi.activate().then(res =>{
          //   this.tag('DTVSettings.Title').text.text = 'DTV Settings: Activtion'+ res
          // })
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in main view.
   */
  class ListItem$1 extends lng$1.Component {
    /**
     * Function to render various elements in the main view item.
     */
    static _template() {
      return {
        Item: {
          Shadow: {
            alpha: 0
          },
          y: 20,
          Image: {},
          Info: {}
        }
      };
    }
    _init() {
      this.tag('Shadow').patch({
        color: CONFIG.theme.hex,
        rect: true,
        h: this.h + this.bar * 2,
        w: this.w,
        x: this.x,
        y: this.y - this.bar
      });
      if (this.data.url.startsWith('/images')) {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: Utils.asset(this.data.url),
          scale: this.unfocus
        });
      } else {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: this.data.url
        });
      }

      /* Used static data for develpment purpose ,
      it wil replaced with Dynamic data once implimetation is completed.*/
      this.tag('Info').patch({
        x: this.x - 20,
        y: this.y + this.h + 10,
        w: this.w,
        h: 140,
        alpha: 0,
        PlayIcon: {
          Label: {
            x: this.idx === 0 ? this.x + 20 : this.x,
            y: this.y + 10,
            text: {
              fontFace: CONFIG.language.font,
              text: this.data.displayName,
              fontSize: 35,
              maxLines: 1,
              wordWrapWidth: this.w
            }
          }
        }
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        zIndex: 1,
        scale: this.focus
      });
      this.tag('Info').alpha = 1;
      this.tag('Item').patch({
        zIndex: 2
      });
      this.tag('Shadow').patch({
        smooth: {
          scale: [this.focus, {
            timingFunction: 'ease',
            duration: 0.7
          }],
          alpha: 1
        }
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus,
        zIndex: 0
      });
      this.tag('Item').patch({
        zIndex: 0
      });
      this.tag('Info').alpha = 0;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 0,
          scale: [this.unfocus, {
            timingFunction: 'ease',
            duration: 0.7
          }]
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var imageListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var musicListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var videoListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var UsbInnerFolderListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$a = {
    host: '127.0.0.1',
    port: 9998,
    versions: {
      default: 2,
      Controller: 1,
      UsbAccess: 2
    }
  };
  var thunder$b = thunderJS(config$a);
  /**
   * Class that contains functions which commuicates with thunder API's
   */

  class UsbApi {
    /**
    *  Function to activate USB Access Plugin
    */

    activate() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$b.Controller.activate({
          callsign: systemcCallsign
        }).then(res => {
          resolve(res);
        }).catch(err => {
          console.log('UsbAccess Plugin Activation Failed: ' + err);
          reject(err);
        });
      });
    }

    /**
    *  Function to deactivate USB Access Plugin
    */

    deactivate() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$b.Controller.deactivate({
          callsign: systemcCallsign
        }).then(res => {
          resolve(res);
        }).catch(err => {
          console.log('UsbAccess Plugin Deactivation Failed: ' + err);
          reject(err);
        });
      });
    }

    /**
    *  Function to create link for USB content
    */
    clearLink() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$b.call(systemcCallsign, 'clearLink').then(result => {
          resolve(result);
        }).catch(err => {
          resolve(false);
        });
      });
    }

    /**
    *  Function to create link for USB content
    */
    createLink() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$b.call(systemcCallsign, 'createLink').then(result => {
          resolve(result);
        }).catch(err => {
          resolve(false);
        });
      });
    }

    /**
    *  Function to get getUsbList
    */
    getUsbFileList() {
      if (arguments.length === 0) {
        return new Promise((resolve, reject) => {
          const systemcCallsign = 'org.rdk.UsbAccess';
          thunder$b.call(systemcCallsign, 'getFileList').then(result => {
            resolve(result.contents);
          }).catch(err => {
            resolve(false);
          });
        });
      } else {
        return new Promise((resolve, reject) => {
          const systemcCallsign = 'org.rdk.UsbAccess';
          thunder$b.call(systemcCallsign, 'getFileList', {
            "path": arguments[0]
          }).then(result => {
            resolve(result.contents);
          }).catch(err => {
            resolve(false);
          });
        });
      }
    }
    retrieUsb() {
      this.usbLink = "";
      var self = this;
      return new Promise((resolve, reject) => {
        self.clearLink().then(result => {
          self.createLink().then(res => {
            if (res.success) {
              self.usbLink = res.baseURL;
              self.getUsbFileList().then(result1 => {
                self.getUsbContentList(result1);
                resolve(true);
              }).catch(err => {
                reject(err);
              });
            }
          }).catch(err => {
            reject(err);
          });
        }).catch(err => {
          reject(err);
        });
      });
    }
    destroy() {
      imageListInfo.length = 0;
      videoListInfo.length = 0;
      musicListInfo.length = 0;
      UsbInnerFolderListInfo.length = 0;
    }
    cd(dname) {
      return new Promise((resolve, reject) => {
        this.getUsbFileList(dname).then(result1 => {
          this.getUsbContentList(result1, dname);
          resolve(true);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getMountedDevices() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = "org.rdk.UsbAccess";
        thunder$b.call(systemcCallsign, 'getMounted').then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
          console.error("Error while getting the mounted device ".concat(JSON.stringify(err)));
        });
      });
    }
    getUsbContentList(result) {
      this.destroy();
      let cwd = this.usbLink;
      if (arguments[1]) {
        cwd = cwd + '/' + arguments[1];
      }
      // to add support for more formats, extension can be added same as below 
      var extensionForImage = ['.png', '.jpg', '.PNG', '.jpeg', '.JPEG', '.jpg', '.JPG'];
      var extensionForVideo = ['.mp4', '.MP4', '.mov', '.MOV', '.avi', '.AVI', '.m3u8', '.M3U8', '.mpeg2', '.MPEG2'];
      var extensionForAudio = ['.mp3', '.mpeg', '.MP3', '.MPEG'];
      this._discoveredC = result;
      //   console.log("Discovered result :: " + JSON.stringify(result));

      this._discoveredC.filter(device => {
        for (let i in extensionForImage) {
          if (device.name.indexOf(extensionForImage[i]) !== -1) {
            var obj1 = {
              displayName: device.name,
              uri: cwd + '/' + device.name,
              url: cwd + '/' + device.name
              // url: '/images/usb/picture-default-tile.jpg',
              // url: '/images/usb/USB_Photo_Placeholder.jpg',
              // uri: this.usbLink + '/' + device.name,
            };

            imageListInfo.push(obj1);
            return device;
          }
        }
      });
      this._discoveredC.filter(device => {
        for (let i in extensionForVideo) {
          if (device.name.indexOf(extensionForVideo[i]) !== -1) {
            var obj2 = {
              displayName: device.name,
              //  url: '/images/usb/video-default-tile.jpg',
              url: '/images/usb/USB_Video_Placeholder.jpg',
              uri: cwd + '/' + device.name
            };
            videoListInfo.push(obj2);
            return device;
          }
        }
      });
      this._discoveredC.filter(device => {
        for (let i in extensionForAudio) {
          if (device.name.indexOf(extensionForAudio[i]) !== -1) {
            var obj3 = {
              displayName: device.name,
              //  url: '/images/usb/music-default-tile.jpg',
              url: '/images/usb/USB_Audio_Placeholder.jpg',
              uri: cwd + '/' + device.name
            };
            musicListInfo.push(obj3);
            return device;
          }
        }
      });
      this._discoveredC.filter(device => {
        if (device.t === 'd') {
          if (!(device.name === '.' || device.name === "..")) {
            var obj4 = {
              displayName: device.name,
              url: "/images/usb/USB_Folder.jpg",
              uri: cwd + "/" + device.name
            };
            UsbInnerFolderListInfo.push(obj4);
            return device;
          }
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Xcast thunder plugin apis.
   */
  class XcastApi {
    constructor() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS(config);
      console.log('Xcast constructor');
      this._events = new Map();
    }

    /**
     * Function to activate the Xcast plugin
     */
    activate() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Xcast';
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          console.log('Xcast activation success ' + result);
          this._thunder.call('org.rdk.Xcast', 'setEnabled', {
            enabled: true
          }).then(result => {
            if (result.success) {
              console.log('Xcast enabled');
              this._thunder.on(this.callsign, 'onApplicationLaunchRequest', notification => {
                console.log('onApplicationLaunchRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationLaunchRequest')) {
                  this._events.get('onApplicationLaunchRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationHideRequest', notification => {
                console.log('onApplicationHideRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationHideRequest')) {
                  this._events.get('onApplicationHideRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationResumeRequest', notification => {
                console.log('onApplicationResumeRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationResumeRequest')) {
                  this._events.get('onApplicationResumeRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationStopRequest', notification => {
                console.log('onApplicationStopRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationStopRequest')) {
                  this._events.get('onApplicationStopRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationStateRequest', notification => {
                // console.log('onApplicationStateRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationStateRequest')) {
                  this._events.get('onApplicationStateRequest')(notification);
                }
              });
              resolve(true);
            } else {
              console.log('Xcast enabled failed');
            }
          }).catch(err => {
            console.error('Enabling failure', err);
            reject('Xcast enabling failed', err);
          });
        }).catch(err => {
          console.error('Activation failure', err);
          reject('Xcast activation failed', err);
        });
      });
    }
    getEnabled() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Xcast', 'getEnabled').then(res => {
          resolve(res);
        }).catch(err => {
          console.log('Xdial error', err);
          reject(err);
        });
      });
    }

    /**
     *
     * @param {string} eventId
     * @param {function} callback
     * Function to register the events for the Xcast plugin.
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Function to deactivate the Xcast plugin.
     */
    deactivate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Xcast', 'setEnabled', {
          enabled: false
        }).then(res => {
          resolve(res.success);
        }).catch(err => {
          console.log('Failed to close Xcast', err);
        });
      });
    }

    /**
     * Function to notify the state of the app.
     */
    onApplicationStateChanged(params) {
      return new Promise((resolve, reject) => {
        console.log('Notifying back');
        this._thunder.call('org.rdk.Xcast.1', 'onApplicationStateChanged', params).then(result => {
          resolve(result);
        }).catch(err => {
          console.error(err);
          resolve(false);
        });
      });
    }
    static supportedApps() {
      var xcastApps = {
        AmazonInstantVideo: 'Amazon',
        YouTube: 'Cobalt',
        NetflixApp: 'Netflix'
      };
      return xcastApps;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in main view.
   */
  class GracenoteItem extends lng$1.Component {
    /**
     * Function to render various elements in the main view item.
     */
    static _template() {
      return {
        Item: {
          Shadow: {
            alpha: 0
          },
          y: 20,
          Image: {},
          Info: {}
        }
      };
    }
    _init() {
      let imgUrl = this.data.program.preferredImage.uri.replace("w=1280&", "w=480&").replace("&h=720", "&h=270");
      this.tag('Shadow').patch({
        color: CONFIG.theme.hex,
        rect: true,
        h: this.h + this.bar * 2,
        w: this.w,
        x: this.x,
        y: this.y - this.bar
      });
      this.tag('Image').patch({
        rtt: true,
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        src: Utils.proxyUrl('http://developer.tmsimg.com/' + imgUrl + '&api_key=' + this.key),
        scale: this.unfocus
      });

      /* Used static data for develpment purpose ,
      it wil replaced with Dynamic data once implimetation is completed.*/
      this.tag('Info').patch({
        x: this.x - 20,
        y: this.y + this.h + 20,
        w: this.w,
        h: 140,
        alpha: 0,
        PlayIcon: {
          Label: {
            x: this.idx === 0 ? this.x + 20 : this.x,
            y: this.y + 10,
            text: {
              fontFace: CONFIG.language.font,
              text: this.data.program.title,
              fontSize: 35,
              maxLines: 1,
              wordWrapWidth: this.w
            }
          }
        }
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        zIndex: 1,
        scale: this.focus
      });
      this.tag('Info').alpha = 1;
      this.tag('Item').patch({
        zIndex: 2
      });
      this.tag('Shadow').patch({
        smooth: {
          scale: [this.focus, {
            timingFunction: 'ease',
            duration: 0.7
          }],
          alpha: 1
        }
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus
      });
      this.tag('Item').patch({
        zIndex: 0
      });
      this.tag('Info').alpha = 0;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 0,
          scale: [this.unfocus, {
            timingFunction: 'ease',
            duration: 0.7
          }]
        }
      });
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class CollectionWrapper extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {}
      };
    }
    _construct() {
      this._direction = CollectionWrapper.DIRECTION.row;
      this._scrollTransitionSettings = this.stage.transitions.createSettings({});
      this._spacing = 0;
      this._autoResize = false;
      this._requestingItems = false;
      this._requestThreshold = 1;
      this._requestsEnabled = false;
      this._gcThreshold = 5;
      this._gcIncrement = 0;
      this._forceLoad = false;
      this.clear();
    }
    _setup() {
      this._updateScrollTransition();
    }
    _updateScrollTransition() {
      const axis = this._direction === 1 ? 'y' : 'x';
      this.wrapper.transition(axis, this._scrollTransitionSettings);
      this._scrollTransition = this.wrapper.transition(axis);
    }
    _indexChanged(obj) {
      let {
        previousIndex: previous,
        index: target,
        dataLength: max,
        mainIndex,
        previousMainIndex,
        lines
      } = obj;
      if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
        previous = previousMainIndex;
        target = mainIndex;
        max = lines;
      }
      if (this._requestsEnabled && !this._requestingItems) {
        if (previous < target && target + this._requestThreshold >= max) {
          this._requestingItems = true;
          this.signal('onRequestItems', obj).then(response => {
            const type = typeof response;
            if (Array.isArray(response) || type === 'object' || type === 'string' || type === 'number') {
              this.add(response);
            }
            if (response === false) {
              this.enableRequests = false;
            }
            this._requestingItems = false;
          });
        }
      }
      this._refocus();
      this.scrollCollectionWrapper(obj);
      this.signal('onIndexChanged', obj);
    }
    setIndex(index) {
      const targetIndex = limitWithinRange(index, 0, this._items.length - 1);
      const previousIndex = this._index;
      this._index = targetIndex;
      this._indexChanged({
        previousIndex,
        index: targetIndex,
        dataLength: this._items.length
      });
      return previousIndex !== targetIndex;
    }
    clear() {
      this._uids = [];
      this._items = [];
      this._index = 0;
      if (this._scrollTransition) {
        this._scrollTransition.reset(0, 1);
      }
      if (this.wrapper) {
        const hadChildren = this.wrapper.children > 0;
        this.wrapper.patch({
          x: 0,
          y: 0,
          children: []
        });
        if (hadChildren) {
          this._collectGarbage(true);
        }
      }
    }
    add(item) {
      this.addAt(item);
    }
    addAt(item) {
      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._items.length;
      if (index >= 0 && index <= this._items.length) {
        if (!Array.isArray(item)) {
          item = [item];
        }
        const items = this._normalizeDataItems(item);
        this._items.splice(index, 0, ...items);
        this.plotItems();
        this.setIndex(this._index);
      } else {
        throw new Error('addAt: The index ' + index + ' is out of bounds ' + this._items.length);
      }
    }
    remove(item) {
      if (this.hasItems && item.assignedID) {
        for (let i = 0; i < this.wrapper.children.length; i++) {
          if (this.wrapper.children[i].assignedID === item.assignedID) {
            return this.removeAt(i);
          }
        }
      } else {
        throw new Error('remove: item not found');
      }
    }
    removeAt(index) {
      let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (index < 0 && index >= this._items.length) {
        throw new Error('removeAt: The index ' + index + ' is out of bounds ' + this._items.length);
      }
      const item = this._items[index];
      this._items.splice(index, amount);
      this.plotItems();
      return item;
    }
    reload(item) {
      this.clear();
      this.add(item);
    }
    plotItems(items, options) {
      //placeholder
    }
    reposition() {
      let time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 70;
      if (this._repositionDebounce) {
        clearTimeout(this._repositionDebounce);
      }
      this._repositionDebounce = setTimeout(() => {
        this.repositionItems();
      }, time);
    }
    repositionItems() {
      //placeHolder
      this.signal('onItemsRepositioned');
    }
    up() {
      return this._attemptNavigation(-1, 1);
    }
    down() {
      return this._attemptNavigation(1, 1);
    }
    left() {
      return this._attemptNavigation(-1, 0);
    }
    right() {
      return this._attemptNavigation(1, 0);
    }
    first() {
      return this.setIndex(0);
    }
    last() {
      return this.setIndex(this._items.length - 1);
    }
    next() {
      return this.setIndex(this._index + 1);
    }
    previous() {
      return this.setIndex(this._index - 1);
    }
    _attemptNavigation(shift, direction) {
      if (this.hasItems) {
        return this.navigate(shift, direction);
      }
      return false;
    }
    navigate(shift) {
      let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._direction;
      if (direction !== this._direction) {
        return false;
      }
      return this.setIndex(this._index + shift);
    }
    scrollCollectionWrapper(obj) {
      let {
        previousIndex: previous,
        index: target,
        dataLength: max,
        mainIndex,
        previousMainIndex,
        lines
      } = obj;
      if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
        previous = previousMainIndex;
        target = mainIndex;
        max = lines;
      }
      const {
        directionIsRow,
        main,
        mainDim,
        mainMarginFrom,
        mainMarginTo
      } = this._getPlotProperties(this._direction);
      const cw = this.currentItemWrapper;
      let bound = this[mainDim];
      if (bound === 0) {
        bound = directionIsRow ? 1920 : 1080;
      }
      const offset = Math.min(this.wrapper[main], this._scrollTransition && this._scrollTransition.targetValue || 0);
      const sizes = this._getItemSizes(cw);
      const marginFrom = sizes[mainMarginFrom] || sizes.margin || 0;
      const marginTo = sizes[mainMarginTo] || sizes.margin || 0;
      let scroll = this._scroll;
      if (!isNaN(scroll)) {
        if (scroll >= 0 && scroll <= 1) {
          scroll = bound * scroll - (cw[main] + cw[mainDim] * scroll);
        } else {
          scroll = scroll - cw[main];
        }
      } else if (typeof scroll === 'function') {
        scroll = scroll.apply(this, [cw, obj]);
      } else if (typeof scroll === 'object') {
        const {
          jump = false,
          after = false,
          backward = 0.0,
          forward = 1.0
        } = scroll;
        if (jump) {
          let mod = target % jump;
          if (mod === 0) {
            scroll = marginFrom - cw[main];
          }
          if (mod === jump - 1) {
            const actualSize = marginFrom + cw[mainDim] + marginTo;
            scroll = mod * actualSize + marginFrom - cw[main];
          }
        } else if (after) {
          scroll = 0;
          if (target >= after - 1) {
            const actualSize = marginFrom + cw[mainDim] + marginTo;
            scroll = (after - 1) * actualSize + marginFrom - cw[main];
          }
        } else {
          const backwardBound = bound * this._normalizePixelToPercentage(backward, bound);
          const forwardBound = bound * this._normalizePixelToPercentage(forward, bound);
          if (target < max - 1 && previous < target && offset + cw[main] + cw[mainDim] > forwardBound) {
            scroll = forwardBound - (cw[main] + cw[mainDim]);
          } else if (target > 0 && target < previous && offset + cw[main] < backwardBound) {
            scroll = backwardBound - cw[main];
          } else if (target === max - 1) {
            scroll = bound - (cw[main] + cw[mainDim]);
          } else if (target === 0) {
            scroll = marginFrom - cw[main];
          }
        }
      } else if (isNaN(scroll)) {
        if (previous < target && offset + cw[main] + cw[mainDim] > bound) {
          scroll = bound - (cw[main] + cw[mainDim]);
        } else if (target < previous && offset + cw[main] < 0) {
          scroll = marginFrom - cw[main];
        }
      }
      if (this.active && !isNaN(scroll) && this._scrollTransition) {
        if (this._scrollTransition.isRunning()) {
          this._scrollTransition.reset(scroll, 0.05);
        } else {
          this._scrollTransition.start(scroll);
        }
      } else if (!isNaN(scroll)) {
        this.wrapper[main] = scroll;
      }
    }
    $childInactive(_ref) {
      let {
        child
      } = _ref;
      if (typeof child === 'object') {
        const index = child.componentIndex;
        for (let key in this._items[index]) {
          if (child.component[key] !== undefined) {
            this._items[index][key] = child.component[key];
          }
        }
      }
      this._collectGarbage();
    }
    $getChildComponent(_ref2) {
      let {
        index
      } = _ref2;
      return this._items[index];
    }
    _resizeWrapper(crossSize) {
      let obj = crossSize;
      if (!isNaN(crossSize)) {
        const {
          main,
          mainDim,
          crossDim
        } = this._getPlotProperties(this._direction);
        const lastItem = this.wrapper.childList.last;
        obj = {
          [mainDim]: lastItem[main] + lastItem[mainDim],
          [crossDim]: crossSize
        };
      }
      this.wrapper.patch(obj);
      if (this._autoResize) {
        this.patch(obj);
      }
    }
    _generateUniqueID() {
      let id = '';
      while (this._uids[id] || id === '') {
        id = Math.random().toString(36).substr(2, 9);
      }
      this._uids[id] = true;
      return id;
    }
    _getPlotProperties(direction) {
      const directionIsRow = direction === 0;
      return {
        directionIsRow: directionIsRow ? true : false,
        mainDirection: directionIsRow ? 'rows' : 'columns',
        main: directionIsRow ? 'x' : 'y',
        mainDim: directionIsRow ? 'w' : 'h',
        mainMarginTo: directionIsRow ? 'marginRight' : 'marginBottom',
        mainMarginFrom: directionIsRow ? 'marginLeft' : 'marginUp',
        crossDirection: !directionIsRow ? 'columns' : 'rows',
        cross: directionIsRow ? 'y' : 'x',
        crossDim: directionIsRow ? 'h' : 'w',
        crossMarginTo: directionIsRow ? 'marginBottom' : 'marginRight',
        crossMarginFrom: directionIsRow ? 'marginUp' : 'marginLeft'
      };
    }
    _getItemSizes(item) {
      const itemType = item.type;
      if (item.component && item.component.__attached) {
        item = item.component;
      }
      return {
        w: item.w || itemType && itemType['width'],
        h: item.h || itemType && itemType['height'],
        margin: item.margin || itemType && itemType['margin'] || 0,
        marginLeft: item.marginLeft || itemType && itemType['marginLeft'],
        marginRight: item.marginRight || itemType && itemType['marginRight'],
        marginTop: item.marginTop || itemType && itemType['marginTop'],
        marginBottom: item.marginBottom || itemType && itemType['marginBottom']
      };
    }
    _collectGarbage(immediate) {
      this._gcIncrement++;
      if (immediate || this.active && this._gcThreshold !== 0 && this._gcIncrement >= this._gcThreshold) {
        this._gcIncrement = 0;
        this.stage.gc();
      }
    }
    _normalizeDataItems(array) {
      return array.map((item, index) => {
        return this._normalizeDataItem(item) || index;
      }).filter(item => {
        if (!isNaN(item)) {
          console.warn("Item at index: ".concat(item, ", is not a valid item. Removing it from dataset"));
          return false;
        }
        return true;
      });
    }
    _normalizeDataItem(item, index) {
      if (typeof item === 'string' || typeof item === 'number') {
        item = {
          label: item.toString()
        };
      }
      if (typeof item === 'object') {
        let id = this._generateUniqueID();
        return {
          assignedID: id,
          type: this.itemType,
          collectionWrapper: this,
          isAlive: false,
          ...item
        };
      }
      return index;
    }
    _normalizePixelToPercentage(value, max) {
      if (value && value > 1) {
        return value / max;
      }
      return value || 0;
    }
    _getFocused() {
      if (this.hasItems) {
        return this.currentItemWrapper;
      }
      return this;
    }
    _handleRight() {
      return this.right();
    }
    _handleLeft() {
      return this.left();
    }
    _handleUp() {
      return this.up();
    }
    _handleDown() {
      return this.down();
    }
    _inactive() {
      if (this._repositionDebounce) {
        clearTimeout(this._repositionDebounce);
      }
      this._collectGarbage(true);
    }
    static get itemType() {
      return undefined;
    }
    set forceLoad(bool) {
      this._forceLoad = bool;
    }
    get forceLoad() {
      return this._forceLoad;
    }
    get requestingItems() {
      return this._requestingItems;
    }
    set requestThreshold(num) {
      this._requestThreshold = num;
    }
    get requestThreshold() {
      return this._requestThreshold;
    }
    set enableRequests(bool) {
      this._requestsEnabled = bool;
    }
    get enableRequests() {
      return this._requestsEnabled;
    }
    set gcThreshold(num) {
      this._gcThreshold = num;
    }
    get gcThreshold() {
      return this._gcThreshold;
    }
    get wrapper() {
      return this.tag('Wrapper');
    }
    get hasItems() {
      return this.wrapper && this.wrapper.children && this.wrapper.children.length > 0;
    }
    get currentItemWrapper() {
      return this.wrapper.children[this._index];
    }
    get currentItem() {
      return this.currentItemWrapper.component;
    }
    set direction(string) {
      this._direction = CollectionWrapper.DIRECTION[string] || CollectionWrapper.DIRECTION.row;
    }
    get direction() {
      return Object.keys(CollectionWrapper.DIRECTION)[this._direction];
    }
    set items(array) {
      this.clear();
      this.add(array);
    }
    get items() {
      const itemWrappers = this.itemWrappers;
      return this._items.map((item, index) => {
        if (itemWrappers[index] && itemWrappers[index].component.isAlive) {
          return itemWrappers[index].component;
        }
        return item;
      });
    }
    get length() {
      return this._items.length;
    }
    set index(index) {
      this.setIndex(index);
    }
    get itemWrappers() {
      return this.wrapper.children;
    }
    get index() {
      return this._index;
    }
    set scrollTransition(obj) {
      this._scrollTransitionSettings.patch(obj);
      if (this.active) {
        this._updateScrollTransition();
      }
    }
    get scrollTransition() {
      return this._scrollTransition;
    }
    set scroll(value) {
      this._scroll = value;
    }
    get scrollTo() {
      return this._scroll;
    }
    set autoResize(bool) {
      this._autoResize = bool;
    }
    get autoResize() {
      return this._autoResize;
    }
    set spacing(num) {
      this._spacing = num;
    }
    get spacing() {
      return this._spacing;
    }
  }
  CollectionWrapper.DIRECTION = {
    row: 0,
    column: 1
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Cursor extends lng$1.Component {
    static _template() {
      return {
        alpha: 0
      };
    }
    _construct() {
      this._blink = true;
    }
    _init() {
      this._blinkAnimation = this.animation({
        duration: 1,
        repeat: -1,
        actions: [{
          p: 'alpha',
          v: {
            0: 0,
            0.5: 1,
            1: 0
          }
        }]
      });
    }
    show() {
      if (this._blink) {
        this._blinkAnimation.start();
      } else {
        this.alpha = 1;
      }
    }
    hide() {
      if (this._blink) {
        this._blinkAnimation.stop();
      } else {
        this.alpha = 0;
      }
    }
    set blink(bool) {
      this._blink = bool;
      if (this.active) {
        if (bool) {
          this.show();
        } else {
          this.hide();
        }
      }
    }
    get blink() {
      return this._blink;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ItemWrapper extends lng$1.Component {
    static _template() {
      return {
        clipbox: true
      };
    }
    create() {
      if (this.children.length > 0) {
        return;
      }
      const component = this.fireAncestors('$getChildComponent', {
        index: this.componentIndex
      });
      component.isAlive = true;
      const {
        w,
        h,
        margin,
        marginUp,
        marginBottom,
        marginRight,
        marginLeft
      } = this;
      this.children = [{
        ...component,
        w,
        h,
        margin,
        marginUp,
        marginRight,
        marginLeft,
        marginBottom
      }];
      if (this.hasFocus()) {
        this._refocus();
      }
    }
    get component() {
      return this.children[0] || this.fireAncestors('$getChildComponent', {
        index: this.componentIndex
      });
    }
    _setup() {
      if (this.forceLoad) {
        this.create();
      }
    }
    _active() {
      this.create();
    }
    _inactive() {
      if (!this.forceLoad) {
        this.children[0].isAlive = false;
        this.fireAncestors('$childInactive', {
          child: this
        });
        this.childList.clear();
      }
    }
    _getFocused() {
      return this.children && this.children[0] || this;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class KeyWrapper extends lng$1.Component {
    static _template() {
      return {
        clipbox: true
      };
    }
    _update() {
      let currentKey = this.children && this.children[0];
      if (currentKey && currentKey.action === this._key.data.action) {
        currentKey.patch({
          ...this._key
        });
      } else {
        this.children = [{
          type: this._key.keyType,
          ...this._key
        }];
      }
      if (this.hasFocus()) {
        this._refocus();
      }
    }
    set key(obj) {
      this._key = obj;
      if (this.active) {
        this._update();
      }
    }
    get key() {
      return this._key;
    }
    _active() {
      this._update();
    }
    _inactive() {
      this.childList.clear();
    }
    _getFocused() {
      return this.children && this.children[0] || this;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const limitWithinRange = (num, min, max) => {
    return Math.min(Math.max(num, min), max);
  };
  const defineProperties = (component, props) => {
    props.forEach(prop => {
      Object.defineProperty(component, prop, {
        set: function (value) {
          component["_".concat(prop)] = value;
        },
        get: function () {
          return component["_".concat(prop)];
        }
      });
    });
  };
  const findIndexOfObject = (array, search, targetProp) => {
    for (let i = 0; i < array.length; i++) {
      if (array[i][targetProp] === search) {
        return i;
      }
    }
    return -1;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Grid extends CollectionWrapper {
    _construct() {
      this._crossSpacing = 5;
      this._mainSpacing = 5;
      this._rows = 0;
      this._columns = 0;
      super._construct();
    }
    clear() {
      super.clear();
      this._mainIndex = 0;
      this._crossIndex = 0;
      this._previous = undefined;
    }
    setIndex(index) {
      const targetIndex = limitWithinRange(index, 0, this._items.length - 1);
      const previousIndex = this._index;
      const {
        mainIndex: previousMainIndex,
        crossIndex: previousCrossIndex
      } = this._findLocationOfIndex(this._index);
      const {
        mainIndex,
        crossIndex
      } = this._findLocationOfIndex(targetIndex);
      this._mainIndex = mainIndex;
      this._crossIndex = crossIndex;
      this._previous = {
        mainIndex,
        crossIndex,
        realIndex: previousIndex
      };
      this._index = targetIndex;
      this._indexChanged({
        previousIndex,
        index: targetIndex,
        mainIndex,
        previousMainIndex,
        crossIndex,
        previousCrossIndex,
        lines: this._lines.length,
        dataLength: this._items.length
      });
    }
    _findLocationOfIndex(index) {
      for (let i = 0; i < this._lines.length; i++) {
        if (this._lines[i].includes(index)) {
          return {
            mainIndex: i,
            crossIndex: this._lines[i].indexOf(index)
          };
        }
      }
      return {
        mainIndex: -1,
        crossIndex: -1
      };
    }
    plotItems() {
      const items = this._items;
      const wrapper = this.wrapper;
      const {
        directionIsRow,
        mainDirection,
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim,
        crossMarginTo,
        crossMarginFrom
      } = this._getPlotProperties(this._direction);
      const crossSize = this[crossDim];
      let mainPos = 0,
        crossPos = 0,
        lineIndex = 0;
      const animateItems = [];
      const viewboundMain = directionIsRow ? 1920 : 1080;
      const viewboundCross = directionIsRow ? 1080 : 1920;
      const renderContext = this.core.renderContext;
      this._lines = [[]];
      //create empty line array
      let cl = [];
      const newChildren = items.map((item, index) => {
        const sizes = this._getItemSizes(item);
        const targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
        if (index === 0) {
          mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
        }
        if (cl.length > 0 && (this[mainDirection] > 0 && this[mainDirection] === cl.length || this[mainDirection] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
          const bil = this._getBiggestInLine(cl);
          mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
          crossPos = targetCrossFromMargin;
          this._lines.push([]);
          cl = [];
          lineIndex++;
        } else {
          crossPos += targetCrossFromMargin;
        }
        const ref = "IW-".concat(item.assignedID);
        let tmp = mainPos;
        let tcp = crossPos;
        const existingItemWrapper = wrapper.tag(ref);
        if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext["p".concat(main)] + wrapper[main] + mainPos <= viewboundMain || renderContext["p".concat(cross)] + wrapper[cross] + crossPos <= viewboundCross))) {
          tmp = existingItemWrapper[main];
          tcp = existingItemWrapper[cross];
          animateItems.push(index);
        }
        const newItem = {
          ref,
          type: ItemWrapper,
          componentIndex: index,
          forceLoad: this._forceLoad,
          ...sizes,
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: crossPos,
          [main]: tmp,
          [cross]: tcp
        };
        crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
        this._lines[lineIndex].push(index);
        cl.push(newItem);
        return newItem;
      });
      wrapper.children = newChildren;
      animateItems.forEach(index => {
        const item = wrapper.children[index];
        item.patch({
          smooth: {
            x: item.assignedX,
            y: item.assignedY
          }
        });
      });
      const biggestInLastLine = this._getBiggestInLine(cl);
      this._resizeWrapper({
        [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
        [crossDim]: crossSize
      });
    }
    repositionItems() {
      const wrapper = this.wrapper;
      if (!wrapper && wrapper.children.length) {
        return true;
      }
      const {
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim,
        crossMarginTo,
        crossMarginFrom
      } = this._getPlotProperties(this._direction);
      const crossSize = this[crossDim];
      let mainPos = 0,
        crossPos = 0,
        lineIndex = 0;

      //create empty line array
      let cl = [];
      this.lines = [[]];
      wrapper.children.forEach((item, index) => {
        const sizes = this._getItemSizes(item);
        const targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
        if (index === 0) {
          mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
        }
        if (cl.length > 0 && (this[mainDirection] > 0 && this[mainDirection] === cl.length || this[mainDirection] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
          const bil = this._getBiggestInLine(cl);
          mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
          crossPos = targetCrossFromMargin;
          this._lines.push([]);
          cl = [];
          lineIndex++;
        } else {
          crossPos += targetCrossFromMargin;
        }
        item.patch({
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: crossPos,
          [main]: mainPos,
          [cross]: crossPos
        });
        crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
        this._lines[lineIndex].push(index);
        cl.push(newItem);
      });
      const biggestInLastLine = this._getBiggestInLine(cl);
      this._resizeWrapper({
        [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
        [crossDim]: crossSize
      });
      super.repositionItems();
    }
    _getBiggestInLine(line) {
      const {
        mainDim
      } = this._getPlotProperties(this._direction);
      return line.reduce((biggestItem, newItem) => {
        if (newItem[mainDim] > biggestItem[mainDim]) {
          return newItem;
        }
        return biggestItem;
      });
    }
    navigate(shift, direction) {
      const {
        directionIsRow,
        cross,
        crossDim
      } = this._getPlotProperties(this._direction);
      const overCross = directionIsRow && direction === CollectionWrapper.DIRECTION.column || !directionIsRow && direction === CollectionWrapper.DIRECTION.row;
      let targetMainIndex = this._mainIndex + !!!overCross * shift;
      let targetCrossIndex = this._crossIndex + !!overCross * shift;
      let targetIndex = this._index;
      if (overCross && targetCrossIndex > -1 && targetCrossIndex <= this._lines[targetMainIndex].length) {
        if (this._lines[targetMainIndex][targetCrossIndex] !== undefined) {
          targetIndex = this._lines[targetMainIndex][targetCrossIndex];
          this._previous = undefined;
        }
      } else if (!overCross && targetMainIndex < this._lines.length && targetMainIndex > -1) {
        const targetLine = this._lines[targetMainIndex];
        if (this._previous && this._previous.mainIndex === targetMainIndex) {
          targetIndex = this._previous.realIndex;
          targetCrossIndex = this._previous.crossIndex;
        } else if (targetLine) {
          const currentItem = this.currentItemWrapper;
          const m = targetLine.map(item => {
            const targetItem = this.wrapper.children[item];
            if (targetItem[cross] <= currentItem[cross] && currentItem[cross] <= targetItem[cross] + targetItem[crossDim]) {
              return targetItem[cross] + targetItem[crossDim] - currentItem[cross];
            }
            if (targetItem[cross] >= currentItem[cross] && targetItem[cross] <= currentItem[cross] + currentItem[crossDim]) {
              return currentItem[cross] + currentItem[crossDim] - targetItem[cross];
            }
            return -1;
          });
          let acc = -1;
          let t = -1;
          for (let i = 0; i < m.length; i++) {
            if (m[i] === -1 && acc > -1) {
              break;
            }
            if (m[i] > acc) {
              acc = m[i];
              t = i;
            }
          }
          if (t > -1) {
            targetCrossIndex = t;
            targetIndex = targetLine[t];
          }
        }
        this._previous = {
          mainIndex: this._mainIndex,
          crossIndex: this._crossIndex,
          realIndex: this._index
        };
      }
      if (this._index !== targetIndex) {
        this.setIndex(targetIndex);
        return true;
      }
      return false;
    }
    set rows(num) {
      this._rows = num;
      this.direction = 'row';
    }
    get rows() {
      return this._rows;
    }
    set columns(num) {
      this._columns = num;
      this.direction = 'column';
    }
    get columns() {
      return this._columns;
    }
    set crossSpacing(num) {
      this._crossSpacing = num;
    }
    get crossSpacing() {
      return this._crossSpacing;
    }
    set mainSpacing(num) {
      this._mainSpacing = num;
    }
    get mainSpacing() {
      return this._mainSpacing;
    }
    set spacing(num) {
      this._spacing = num;
      this._mainSpacing = num;
      this._crossSpacing = num;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class InputField extends lng$1.Component {
    static _template() {
      return {
        PreLabel: {
          renderOffscreen: true
        },
        PostLabel: {
          renderOffscreen: true
        },
        Cursor: {
          type: Cursor,
          rect: true,
          w: 4,
          h: 54,
          x: 0,
          y: 0
        }
      };
    }
    _construct() {
      this._input = '';
      this._previousInput = '';
      this._description = '';
      this._cursorX = 0;
      this._cursorIndex = 0;
      this._passwordMask = '*';
      this._passwordMode = false;
      this._autoHideCursor = true;
      this._labelPositionStatic = true;
      this._maxLabelWidth = 0;
    }
    _init() {
      this.tag('PreLabel').on('txLoaded', () => {
        this._labelTxLoaded();
      });
      this.tag('PostLabel').on('txLoaded', () => {
        this._labelTxLoaded;
      });
    }
    onInputChanged(_ref) {
      let {
        input = ''
      } = _ref;
      let targetIndex = Math.max(input.length - this._input.length + this._cursorIndex, 0);
      this._input = input;
      this._update(targetIndex);
    }
    toggleCursor() {
      let bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this._cursorVisible;
      this._cursorVisible = bool;
      this.cursor[bool ? 'show' : 'hide']();
    }
    _labelTxLoaded() {
      const preLabel = this.tag('PreLabel');
      const cursor = this.tag('Cursor');
      const postLabel = this.tag('PostLabel');
      this.h = preLabel.renderHeight || postLabel.renderHeight;
      cursor.x = preLabel.renderWidth + this._cursorX;
      postLabel.x = cursor.x + cursor.w * (1 - cursor.mountX);
      this.setSmooth('x', this._labelOffset);
      if (!this.autoHideCursor) {
        this.toggleCursor(true);
      }
    }
    _update() {
      let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      const hasInput = this._input.length > 0;
      let pre = this._description + '';
      let post = '';
      if (hasInput) {
        pre = this._input.substring(0, index);
        post = this._input.substring(index, this._input.length);
        if (this._passwordMode) {
          pre = this._passwordMask.repeat(pre.length);
          post = this._passwordMask.repeat(post.length);
        }
        this.toggleCursor(true);
      } else if (this._autoHideCursor) {
        this.toggleCursor(false);
      }
      this.patch({
        PreLabel: {
          text: {
            text: pre
          }
        },
        PostLabel: {
          text: {
            text: post
          }
        }
      });
      if (this.h === 0) {
        this.tag('PreLabel').loadTexture();
        this.h = this.tag('PreLabel').renderHeight;
      }
      this._cursorIndex = index;
    }
    _handleRight() {
      this._update(Math.min(this._input.length, this._cursorIndex + 1));
    }
    _handleLeft() {
      this._update(Math.max(0, this._cursorIndex - 1));
    }
    _firstActive() {
      this._labelTxLoaded();
      this._update();
    }
    get input() {
      return this._input;
    }
    get hasInput() {
      return this._input.length > 0;
    }
    get cursorIndex() {
      return this._cursorIndex;
    }
    set inputText(obj) {
      this._inputText = obj;
      this.tag('PreLabel').patch({
        text: obj
      });
      this.tag('PostLabel').patch({
        text: obj
      });
    }
    get inputText() {
      return this._inputText;
    }
    set description(str) {
      this._description = str;
    }
    get description() {
      return this._description;
    }
    set cursor(obj) {
      if (obj.x) {
        this._cursorX = obj.x;
        delete obj.x;
      }
      this.tag('Cursor').patch(obj);
    }
    get cursor() {
      return this.tag('Cursor');
    }
    get cursorVisible() {
      return this._cursorVisible;
    }
    set autoHideCursor(bool) {
      this._autoHideCursor = bool;
    }
    get autoHideCursor() {
      return this._autoHideCursor;
    }
    set passwordMode(val) {
      this._passwordMode = val;
    }
    get passwordMode() {
      return this._passwordMode;
    }
    set passwordMask(str) {
      this._passwordMask = str;
    }
    get passwordmask() {
      return this._passwordMask;
    }

    // the width at which the text start scrolling
    set maxLabelWidth(val) {
      this._maxLabelWidth = val;
    }
    get maxLabelWidth() {
      return this._maxLabelWidth;
    }
    set labelPositionStatic(val) {
      this._labelPositionStatic = val;
    }
    get labelPositionStatic() {
      return this._labelPositionStatic;
    }
    get _labelOffset() {
      if (this._labelPositionStatic) return 0;
      let offset = this.maxLabelWidth - this.tag('Cursor').x;
      return offset < 0 ? offset : 0;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Key$1 extends lng$1.Component {
    static _template() {
      return {
        Background: {
          w: w => w,
          h: h => h,
          rect: true
        },
        Label: {
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2
        }
      };
    }
    _construct() {
      this._backgroundColors = {};
      this._labelColors = {};
    }
    set data(obj) {
      this._data = obj;
      this._update();
    }
    get data() {
      return this._data;
    }
    set labelText(obj) {
      this._labelText = obj;
      this.tag('Label').patch({
        text: obj
      });
    }
    get labelText() {
      return this._labelText;
    }
    set label(obj) {
      this.tag('Label').patch(obj);
    }
    get label() {
      return this.tag('Label');
    }
    set labelColors(obj) {
      this._labelColors = obj;
      this._update();
    }
    get labelColors() {
      return this._labelColors;
    }
    set backgroundColors(obj) {
      this._backgroundColors = obj;
      this._update();
    }
    get backgroundColors() {
      return this._backgroundColors;
    }
    set background(obj) {
      this.tag('Background').patch(obj);
    }
    get background() {
      return this.tag('Background');
    }
    _update() {
      if (!this.active) {
        return;
      }
      const {
        label = ''
      } = this._data;
      const hasFocus = this.hasFocus();
      let {
        focused,
        unfocused = 0xff000000
      } = this._backgroundColors;
      let {
        focused: labelFocused,
        unfocused: labelUnfocused = 0xffffffff
      } = this._labelColors;
      this.patch({
        Background: {
          color: hasFocus && focused ? focused : unfocused
        },
        Label: {
          text: {
            text: label
          },
          color: hasFocus && labelFocused ? labelFocused : labelUnfocused
        }
      });
    }
    _firstActive() {
      this._update();
    }
    _focus() {
      let {
        focused,
        unfocused = 0xff000000
      } = this._backgroundColors;
      let {
        focused: labelFocused,
        unfocused: labelUnfocused = 0xffffffff
      } = this._labelColors;
      this.patch({
        Background: {
          smooth: {
            color: focused || unfocused
          }
        },
        Label: {
          smooth: {
            color: labelFocused || labelUnfocused
          }
        }
      });
    }
    _unfocus() {
      let {
        unfocused = 0xff000000
      } = this._backgroundColors;
      let {
        unfocused: labelUnfocused = 0xffffffff
      } = this._labelColors;
      this.patch({
        Background: {
          smooth: {
            color: unfocused
          }
        },
        Label: {
          smooth: {
            color: labelUnfocused
          }
        }
      });
    }
    static get width() {
      return 80;
    }
    static get height() {
      return 80;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Keyboard$1 extends lng$1.Component {
    static _template() {
      return {
        Keys: {
          w: w => w
        }
      };
    }
    _construct() {
      this._input = '';
      this._inputField = undefined;
      this._maxCharacters = 56;
      this.navigationWrapAround = false;
      this.resetFocus();
    }
    resetFocus() {
      this._columnIndex = 0;
      this._rowIndex = 0;
      this._previousKey = null;
    }
    _setup() {
      this._keys = this.tag('Keys');
      this._update();
    }
    _update() {
      const {
        layouts,
        buttonTypes = {},
        styling = {}
      } = this._config;
      if (!this._layout || this._layout && layouts[this._layout] === undefined) {
        console.error("Configured layout \"".concat(this._layout, "\" does not exist. Picking first available: \"").concat(Object.keys(layouts)[0], "\""));
        this._layout = Object.keys(layouts)[0];
      }
      const {
        horizontalSpacing = 0,
        verticalSpacing = 0,
        align = 'left'
      } = styling;
      let rowPosition = 0;
      const isEvent = /^[A-Z][A-Za-z0-9]{1}/;
      const hasLabel = /\:/;
      if (buttonTypes.default === undefined) {
        buttonTypes.default = Key$1;
      }
      this._keys.children = layouts[this._layout].map((row, rowIndex) => {
        const {
          x = 0,
          margin = 0,
          marginRight,
          marginLeft,
          marginTop,
          marginBottom,
          spacing: rowHorizontalSpacing = horizontalSpacing || 0,
          align: rowAlign = align
        } = styling["Row".concat(rowIndex + 1)] || {};
        let keyPosition = 0;
        let rowHeight = 0;
        const rowKeys = row.map((key, keyIndex) => {
          const origin = key;
          let keyType = buttonTypes.default;
          let action = 'Input';
          let label = key;
          if (isEvent.test(key)) {
            if (hasLabel.test(key)) {
              key = key.split(':');
              label = key[1].toString();
              key = key[0];
            }
            if (buttonTypes[key]) {
              keyType = buttonTypes[key];
              action = key.action || key;
            }
          }
          const keySpacing = keyType.margin || keyType.type.margin;
          const {
            w = keyType.type.width || 0,
            h = keyType.type.height || 0,
            marginLeft = keyType.type.marginLeft || keySpacing || 0,
            marginRight = keyType.type.marginRight || keySpacing || rowHorizontalSpacing
          } = keyType;
          rowHeight = h > rowHeight ? h : rowHeight;
          const currentPosition = keyPosition + marginLeft;
          keyPosition += marginLeft + w + marginRight;
          return {
            ref: "Key-{".concat(keyIndex + 1, "}"),
            type: KeyWrapper,
            keyboard: this,
            x: currentPosition,
            w,
            h,
            key: {
              data: {
                origin,
                key,
                label,
                action
              },
              w,
              h,
              ...keyType
            }
          };
        });
        let rowOffset = x + (marginLeft || margin);
        let rowMount = 0;
        if (this.w && rowAlign === 'center') {
          rowOffset = this.w / 2;
          rowMount = 0.5;
        }
        if (this.w && rowAlign === 'right') {
          rowOffset = this.w - (marginRight || margin);
          rowMount = 1;
        }
        const currentPosition = rowPosition + (marginTop || margin);
        rowPosition = currentPosition + rowHeight + (marginBottom || margin || verticalSpacing);
        return {
          ref: "Row-".concat(rowIndex + 1),
          x: rowOffset,
          mountX: rowMount,
          w: keyPosition,
          y: currentPosition,
          children: rowKeys
        };
      });
      this._refocus();
    }
    _getFocused() {
      return this.currentKeyWrapper || this;
    }
    _handleRight() {
      return this.navigate('row', 1);
    }
    _handleLeft() {
      return this.navigate('row', -1);
    }
    _handleUp() {
      return this.navigate('column', -1);
    }
    _handleDown() {
      return this.navigate('column', 1);
    }
    _handleKey(_ref) {
      let {
        key,
        code = 'CustomKey'
      } = _ref;
      if (code === 'Backspace' && this._input.length === 0) {
        return false;
      }
      if (key === ' ') {
        key = 'Space';
      }
      const targetFound = this._findKey(key);
      if (targetFound) {
        this._handleEnter();
      }
      return targetFound;
    }
    _findKey(str) {
      const rows = this._config.layouts[this._layout];
      let i = 0,
        j = 0;
      for (; i < rows.length; i++) {
        for (j = 0; j < rows[i].length; j++) {
          let key = rows[i][j];
          if (str.length > 1 && key.indexOf(str) > -1 || key.toUpperCase() === str.toUpperCase()) {
            this._rowIndex = i;
            this._columnIndex = j;
            return true;
          }
        }
      }
      return false;
    }
    _handleEnter() {
      const {
        origin,
        action
      } = this.currentKey.data;
      const event = {
        index: this._input.length,
        key: origin
      };
      if (this._inputField && this._inputField.cursorIndex) {
        event.index = this._inputField.cursorIndex;
      }
      if (action !== 'Input') {
        const split = event.key.split(':');
        const call = "on".concat(split[0]);
        const eventFunction = this[call];
        event.key = split[1];
        if (eventFunction && eventFunction.apply && eventFunction.call) {
          eventFunction.call(this, event);
        }
        this.signal(call, {
          input: this._input,
          keyboard: this,
          ...event
        });
      } else {
        this.addAt(event.key, event.index);
      }
    }
    _changeInput(input) {
      if (input.length > this._maxCharacters) {
        return;
      }
      const eventData = {
        previousInput: this._input,
        input: this._input = input
      };
      if (this._inputField && this._inputField.onInputChanged) {
        this._inputField.onInputChanged(eventData);
      }
      this.signal('onInputChanged', eventData);
    }
    focus(str) {
      this._findKey(str);
    }
    add(str) {
      this._changeInput(this._input + str);
    }
    addAt(str, index) {
      if (index > this._input.length - 1) {
        this.add(str);
      } else if (index > -1) {
        this._changeInput(this._input.substring(0, index) + str + this._input.substring(index, this._input.length));
      }
    }
    remove() {
      this._changeInput(this._input.substring(0, this._input.length - 1));
    }
    removeAt(index) {
      if (index > this._input.length - 1) {
        this.remove();
      } else if (index > -1) {
        this._changeInput(this._input.substring(0, index - 1) + this._input.substring(index, this._input.length));
      }
    }
    clear() {
      this._changeInput('');
    }
    layout(key) {
      if (key === this._layout) {
        return;
      }
      this._layout = key;
      if (this.attached) {
        this.resetFocus();
        this._update();
      }
    }
    inputField(component) {
      if (component && component.isComponent) {
        this._rowIndex = 0;
        this._columnIndex = 0;
        this._input = component.input !== undefined ? component.input : '';
        this._inputField = component;
      } else {
        this._rowIndex = 0;
        this._columnIndex = 0;
        this._input = '';
        this._inputField = undefined;
      }
    }
    navigate(direction, shift) {
      const targetIndex = (direction === 'row' ? this._columnIndex : this._rowIndex) + shift;
      const currentRow = this.rows[this._rowIndex];
      if (direction === 'row' && targetIndex > -1 && targetIndex < currentRow.children.length) {
        this._previous = null;
        return this._columnIndex = targetIndex;
      } else if (direction === 'row' && this.navigationWrapAround) {
        this._previous = null;
        let rowLen = currentRow.children.length;
        return this._columnIndex = (targetIndex % rowLen + rowLen) % rowLen;
      }
      if (direction === 'column' && targetIndex > -1 && targetIndex < this.rows.length) {
        const currentRowIndex = this._rowIndex;
        const currentColumnIndex = this._columnIndex;
        if (this._previous && this._previous.row === targetIndex) {
          const tmp = this._previous.column;
          this._previous.column = this._columnIndex;
          this._columnIndex = tmp;
          this._rowIndex = this._previous.row;
        } else {
          const targetRow = this.rows[targetIndex];
          const currentKey = this.currentKeyWrapper;
          const currentRow = this.rows[this._rowIndex];
          const currentX = currentRow.x - currentRow.w * currentRow.mountX + currentKey.x;
          const m = targetRow.children.map(key => {
            const keyX = targetRow.x - targetRow.w * targetRow.mountX + key.x;
            if (keyX <= currentX && currentX < keyX + key.w) {
              return keyX + key.w - currentX;
            }
            if (keyX >= currentX && keyX <= currentX + currentKey.w) {
              return currentX + currentKey.w - keyX;
            }
            return -1;
          });
          let acc = -1;
          let t = -1;
          for (let i = 0; i < m.length; i++) {
            if (m[i] === -1 && acc > -1) {
              break;
            }
            if (m[i] > acc) {
              acc = m[i];
              t = i;
            }
          }
          if (t > -1) {
            this._rowIndex = targetIndex;
            this._columnIndex = t;
          } // if no next row found and wraparound is on, loop back to first row
          else if (this.navigationWrapAround) {
            this._columnIndex = Math.min(this.rows[0].children.length - 1, this._columnIndex);
            return this._rowIndex = 0;
          }
        }
        if (this._rowIndex !== currentRowIndex) {
          this._previous = {
            column: currentColumnIndex,
            row: currentRowIndex
          };
          return this._rowIndex = targetIndex;
        }
      } else if (direction === 'column' && this.navigationWrapAround) {
        this._previous = {
          column: this._columnIndex,
          row: this._rowIndex
        };
        let nrRows = this.rows.length;
        this._rowIndex = (targetIndex % nrRows + nrRows) % nrRows;
        this._columnIndex = Math.min(this.rows[this._rowIndex].children.length - 1, this._columnIndex);
      }
      return false;
    }
    onSpace(_ref2) {
      let {
        index
      } = _ref2;
      this.addAt(' ', index);
    }
    onBackspace(_ref3) {
      let {
        index
      } = _ref3;
      this.removeAt(index);
    }
    onClear() {
      this.clear();
    }
    onLayout(_ref4) {
      let {
        key
      } = _ref4;
      this.layout(key);
    }
    set config(obj) {
      this._config = obj;
      if (this.active) {
        this._update();
      }
    }
    get config() {
      return this._config;
    }
    set currentInputField(component) {
      this.inputField(component);
    }
    get currentInputField() {
      return this._inputField;
    }
    set currentLayout(str) {
      this.layout(str);
    }
    get currentLayout() {
      return this._layout;
    }
    set maxCharacters(num) {
      this._maxCharacters = num;
    }
    get maxCharacters() {
      return this._maxCharacters;
    }
    get rows() {
      return this._keys && this._keys.children;
    }
    get currentKeyWrapper() {
      return this.rows && this.rows[this._rowIndex].children[this._columnIndex];
    }
    get currentKey() {
      return this.currentKeyWrapper && this.currentKeyWrapper.key;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class List extends CollectionWrapper {
    plotItems() {
      const items = this._items;
      const wrapper = this.wrapper;
      const {
        directionIsRow,
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim
      } = this._getPlotProperties(this._direction);
      let crossPos = 0,
        crossSize = 0,
        position = 0;
      const animateItems = [];
      const viewboundMain = directionIsRow ? 1920 : 1080;
      const viewboundCross = directionIsRow ? 1080 : 1920;
      const renderContext = this.core.renderContext;
      const newChildren = items.map((item, index) => {
        const sizes = this._getItemSizes(item);
        position += sizes[mainMarginFrom] || sizes.margin || 0;
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        const ref = "IW-".concat(item.assignedID);
        let mainPos = position;
        crossPos = item[cross] || crossPos;
        let tmp = mainPos;
        let tcp = crossPos;
        const existingItemWrapper = wrapper.tag(ref);
        if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext["p".concat(main)] + wrapper[main] + mainPos <= viewboundMain || renderContext["p".concat(cross)] + wrapper[cross] + crossPos <= viewboundCross))) {
          tmp = existingItemWrapper[main];
          tcp = existingItemWrapper[cross];
          animateItems.push(index);
        }
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
        return {
          ref,
          type: ItemWrapper,
          componentIndex: index,
          forceLoad: this._forceLoad,
          ...sizes,
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: crossPos,
          [main]: tmp,
          [cross]: tcp
        };
      });
      wrapper.children = newChildren;
      animateItems.forEach(index => {
        const item = wrapper.children[index];
        item.patch({
          smooth: {
            x: item.assignedX,
            y: item.assignedY
          }
        });
      });
      this._resizeWrapper(crossSize);
    }
    repositionItems() {
      const wrapper = this.wrapper;
      if (!wrapper && wrapper.children.length) {
        return true;
      }
      const {
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim
      } = this._getPlotProperties(this._direction);
      let crossPos = 0,
        crossSize = 0,
        position = 0;
      wrapper.children.forEach(item => {
        const sizes = this._getItemSizes(item.component);
        position += sizes[mainMarginFrom] || sizes.margin || 0;
        crossPos = item[cross] || crossPos;
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        const mainPos = position;
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this.spacing);
        item.patch({
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: 0,
          [main]: mainPos,
          [cross]: crossPos,
          ...sizes
        });
      });
      this._resizeWrapper(crossSize);
      super.repositionItems();
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ScrollingLabel extends lng$1.Component {
    static _template() {
      return {
        LabelClipper: {
          w: w => w,
          rtt: true,
          shader: {
            type: lng$1.shaders.FadeOut
          },
          LabelWrapper: {
            Label: {
              renderOffscreen: true
            },
            LabelCopy: {
              renderOffscreen: true
            }
          }
        }
      };
    }
    _construct() {
      this._autoStart = true;
      this._scrollAnimation = false;
      this._fade = 30;
      this._spacing = 30;
      this._label = {};
      this._align = 'left';
      this._animationSettings = {
        delay: 0.7,
        repeat: -1,
        stopMethod: 'immediate'
      };
    }
    _init() {
      const label = this.tag('Label');
      label.on('txLoaded', () => {
        this._update(label);
        this._updateAnimation(label);
        if (this._autoStart) {
          this.start();
        }
      });
    }
    _update() {
      let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tag('Label');
      const renderWidth = label.renderWidth;
      const noScroll = renderWidth <= this.renderWidth;
      let labelPos = 0;
      if (noScroll && this._align !== 'left') {
        labelPos = (this.renderWidth - renderWidth) * ScrollingLabel.ALIGN[this._align];
      }
      this.tag('LabelClipper').patch({
        h: label.renderHeight,
        shader: {
          right: noScroll ? 0 : this._fade
        },
        LabelWrapper: {
          x: 0,
          Label: {
            x: labelPos
          },
          LabelCopy: {
            x: renderWidth + this._spacing
          }
        }
      });
    }
    _updateAnimation() {
      let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tag('Label');
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
      }
      if (label.renderWidth > this.renderWidth) {
        if (!this._animationSettings.duration) {
          this._animationSettings.duration = label.renderWidth / 50;
        }
        this._scrollAnimation = this.animation({
          ...this._animationSettings,
          actions: [{
            t: 'LabelWrapper',
            p: 'x',
            v: {
              sm: 0,
              0: 0,
              1.0: -(label.renderWidth + this._spacing)
            }
          }, {
            t: 'LabelClipper',
            p: 'shader.left',
            v: {
              0: 0,
              0.2: this._fade,
              0.8: this._fade,
              1.0: 0
            }
          }]
        });
      }
    }
    start() {
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this.tag('LabelCopy').patch({
          text: this._label
        });
        this._scrollAnimation.start();
      }
    }
    stop() {
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this.tag('LabelCopy').text = '';
      }
    }
    set label(obj) {
      if (typeof obj === 'string') {
        obj = {
          text: obj
        };
      }
      this._label = {
        ...this._label,
        ...obj
      };
      this.tag('Label').patch({
        text: obj
      });
    }
    get label() {
      return this.tag('Label');
    }
    set align(pos) {
      this._align = pos;
    }
    get align() {
      return this._align;
    }
    set autoStart(bool) {
      this._autoStart = bool;
    }
    get autoStart() {
      return this._autoStart;
    }
    set repeat(num) {
      this.animationSettings = {
        repeat: num
      };
    }
    get repeat() {
      return this._animationSettings.repeat;
    }
    set delay(num) {
      this.animationSettings = {
        delay: num
      };
    }
    get delay() {
      return this._animationSettings.delay;
    }
    set duration(num) {
      this.animationSettings = {
        duration: num
      };
    }
    get duration() {
      return this._animationSettings.duration;
    }
    set animationSettings(obj) {
      this._animationSettings = {
        ...this._animationSettings,
        ...obj
      };
      if (this._scrollAnimation) {
        this._updateAnimation();
      }
    }
    get animationSettings() {
      return this._animationSettings;
    }
  }
  ScrollingLabel.ALIGN = {
    left: 0,
    center: 0.5,
    right: 1
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const calcCarouselNavigation = (dir, current, min, max) => {
    let target = current + dir;
    if (target < min) {
      target = max;
    }
    if (target > max) {
      target = min;
    }
    return target;
  };
  class Stepper extends lng$1.Component {
    static _template() {
      return {
        h: 80,
        w: 574,
        Focus: {
          alpha: 0,
          w: w => w,
          h: h => h,
          rect: true
        },
        Label: {
          x: 30,
          y: h => h * 0.5,
          mountY: 0.5,
          text: {
            text: '',
            fontSize: 22
          }
        },
        ValueWrapper: {
          x: w => w - 30,
          w: 200,
          h: h => h,
          mountX: 1,
          Value: {
            x: w => w * 0.5,
            y: h => h * 0.5,
            mountX: 0.5,
            mountY: 0.5,
            text: {
              text: '',
              fontSize: 22
            }
          }
        }
      };
    }
    _construct() {
      this._focusColor = 0xff009245;
      this._labelColor = 0xff9d9d9d;
      this._labelColorFocused = 0xffffffff;
      this._padding = 30;
      this._max = 100;
      this._min = 0;
      this._value = 50;
      this._options = undefined;
      this._label = 'label';
      this._focusAnimation = null;
      defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'padding', 'max', 'min', 'focusAnimation']);
    }
    _update() {
      this.patch({
        Focus: {
          color: this._focusColor
        },
        Label: {
          x: this._padding,
          color: this._labelColor,
          text: {
            text: this._label
          }
        },
        ValueWrapper: {
          x: w => w - this._padding,
          Value: {
            color: this._labelColor,
            text: {
              text: this.optionValue || this.value
            }
          }
        }
      });
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({
        duration: 0.2,
        stopMethod: 'reverse',
        actions: [{
          t: 'Focus',
          p: 'alpha',
          v: {
            0: 0,
            1: 1
          }
        }, {
          t: 'Label',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }, {
          t: 'ValueWrapper.Value',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }]
      });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      this._update();
    }
    _navigate(dir) {
      this.value = calcCarouselNavigation(dir, this._value, this._min, this._max);
      const event = {
        value: this._value
      };
      if (this._options) {
        event.options = this._options;
      }
      this.fireAncestors('$onValueChanged', event);
      this.signal('onValueChanged', event);
    }
    _handleLeft() {
      this._navigate(-1);
    }
    _handleRight() {
      this._navigate(1);
    }
    _focus() {
      if (this._focusAnimation) {
        this._focusAnimation.start();
      }
    }
    _unfocus() {
      if (this._focusAnimation) {
        this._focusAnimation.stop();
      }
    }
    set label(str) {
      this._label = str;
      if (this.active) {
        this.tag('Label').text.text = str;
      }
    }
    get label() {
      return this._label;
    }
    set value(str) {
      this._value = str;
      if (this.active) {
        this.tag('Value').text.text = this.optionValue || this._value;
      }
    }
    get value() {
      return this._value;
    }
    get optionValue() {
      return this._options && this._options[this._value] && this._options[this._value].label || undefined;
    }
    set options(arr) {
      const refactor = arr.map(option => {
        if (typeof option === 'string') {
          return {
            label: option
          };
        }
        return option;
      });
      this._value = 0;
      this._options = refactor;
      this._max = refactor.length - 1;
      this._update();
    }
    get options() {
      return this._options;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ArrowStepper extends Stepper {
    static _template() {
      return {
        ...super._template(),
        ValueWrapper: {
          x: w => w - 30,
          w: 200,
          h: h => h,
          mountX: 1,
          ArrowLeft: {
            y: h => h * 0.5,
            mountY: 0.5
          },
          Value: {
            x: w => w * 0.5,
            y: h => h * 0.5,
            mountX: 0.5,
            mountY: 0.5,
            text: {
              text: '',
              fontSize: 22
            }
          },
          ArrowRight: {
            y: h => h * 0.5,
            x: w => w,
            mountY: 0.5,
            mountX: 1
          }
        }
      };
    }
    _update() {
      this.patch({
        Focus: {
          color: this._focusColor
        },
        Label: {
          x: this._padding,
          color: this._labelColor,
          text: {
            text: this._label
          }
        },
        ValueWrapper: {
          x: w => w - this._padding,
          ArrowLeft: {
            color: this._labelColor
          },
          Value: {
            color: this._labelColor,
            text: {
              text: this.optionValue || this.value
            }
          },
          ArrowRight: {
            color: this._labelColor
          }
        }
      });
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({
        duration: 0.2,
        stopMethod: 'reverse',
        actions: [{
          t: 'Focus',
          p: 'alpha',
          v: {
            0: 0,
            1: 1
          }
        }, {
          t: 'ValueWrapper.ArrowLeft',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }, {
          t: 'ValueWrapper.Value',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }, {
          t: 'ValueWrapper.ArrowRight',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }]
      });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      const arrowLeft = this.tag('ArrowLeft');
      const arrowRight = this.tag('ArrowRight');
      if (!(arrowLeft.src !== undefined && arrowLeft.text !== null)) {
        arrowLeft.text = {
          text: '\u25c0',
          fontSize: 18
        };
      }
      if (!(arrowRight.src !== undefined && arrowRight.text !== null)) {
        arrowRight.text = {
          text: '\u25b6',
          fontSize: 18
        };
      }
      this._update();
    }
  }

  class ColorShift extends lng$1.Component {
    static _template() {
      return {
        w: 574,
        h: 240,
        List: {
          type: List,
          w: w => w,
          h: h => h,
          forceLoad: true,
          spacing: 0,
          direction: 'column'
        }
      };
    }
    _construct() {
      this._autoColorShift = true;
      this._focusColor = 0xff009245;
      this._labelColor = 0xff9d9d9d;
      this._labelColorFocused = 0xffffffff;
      this._options = [{
        type: 'neutral',
        label: 'normal'
      }, {
        type: 'protanopia',
        label: 'Protanopia'
      }, {
        type: 'deuteranopia',
        label: 'Deuteranopia'
      }, {
        type: 'tritanopia',
        label: 'Tritanopia'
      }, {
        type: 'monochromacy',
        label: 'Achromatopsia'
      }];
      defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'options', 'autoColorShift']);
    }
    _getFocused() {
      return this.tag('List');
    }
    _shiftColors() {
      if (this._autoColorShift && this.application && this.application.colorshift) {
        this.application.colorshift(this._settings.correction, this._settings);
      }
    }
    $onValueChanged() {
      const listItems = this.tag('List').items;
      const correction = listItems[0];
      this._settings = {
        correction: correction.options[correction.value].type,
        brightness: listItems[1].value,
        contrast: listItems[2].value,
        gamma: listItems[3].value
      };
      if (this._currentCorrection && this._settings.correction !== this._currentCorrection) {
        const steppers = listItems.slice(1);
        steppers.forEach(stepper => {
          stepper.value = 50;
        });
      }
      this._currentCorrection = this._settings.correction;
      this._shiftColors();
      this.signal('onColorShift', this._settings);
    }
    _update() {
      const list = this.tag('List');
      const steppers = ['Brightness', 'Contrast', 'Gamma'];
      const options = this._options;
      const settings = this._settings;
      const colors = {
        focusColor: this._focusColor,
        labelColor: this._labelColor,
        labelColorFocused: this._labelColorFocused
      };
      this._shiftColors();
      const settingItems = steppers.map(stepper => {
        const lowerC = stepper.toLocaleLowerCase();
        return {
          type: this["".concat(lowerC, "Component")],
          label: stepper,
          value: settings[lowerC],
          w: this.finalW,
          h: 80,
          ...colors
        };
      });
      settingItems.unshift({
        type: this.correctionComponent,
        options,
        value: findIndexOfObject(options, settings.correction, 'type'),
        label: 'Color adjustment',
        w: this.finalW,
        h: 80,
        ...colors
      });
      list.clear();
      list.add(settingItems);
    }
    _firstActive() {
      if (!this._settings) {
        this._settings = {
          correction: 'neutral',
          brightness: 50,
          contrast: 50,
          gamma: 50
        };
      }
      this._update();
    }
    set settings(obj) {
      this._settings = obj;
      if (this.active) {
        const listItems = this.tag('List').items;
        listItems[0] = findIndexOfObject(this._options, obj.correction, 'type');
        listItems[1] = obj.brightness || 50;
        listItems[2] = obj.contrast || 50;
        listItems[3] = obj.gamma || 50;
      }
    }
    get settings() {
      return this._settings;
    }
    get correctionTag() {
      return this.tag('List').items[0];
    }
    get brightnessTag() {
      return this.tag('List').items[1];
    }
    get contrastTag() {
      return this.tag('List').items[2];
    }
    get gammaTag() {
      return this.tag('List').items[3];
    }
    get adjustmentTags() {
      return this.tag('List').items;
    }
    set stepperComponent(component) {
      this._stepperComponent = component;
    }
    get stepperComponent() {
      return this._stepperComponent || ArrowStepper;
    }
    set correctionComponent(component) {
      this._correctionComponent = component;
    }
    get correctionComponent() {
      return this._correctionComponent || this.stepperComponent;
    }
    set brightnessComponent(component) {
      this._brightnessComponent = component;
    }
    get brightnessComponent() {
      return this._brightnessComponent || this.stepperComponent;
    }
    set contrastComponent(component) {
      this._contrastComponent = component;
    }
    get contrastComponent() {
      return this._contrastComponent || this.stepperComponent;
    }
    set gammaComponent(component) {
      this._gammaComponent = component;
    }
    get gammaComponent() {
      return this._gammaComponent || this.stepperComponent;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class CarouselItem extends lng$1.Component {
    static _template() {
      return {
        Focus: {
          alpha: 0,
          x: w => w * 0.5,
          y: h => h * 0.5,
          mount: 0.5,
          w: 120,
          h: 50,
          rect: true,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 25
          }
        },
        Label: {
          x: w => w * 0.5,
          y: h => h * 0.5,
          mount: 0.5,
          renderOffscreen: true,
          text: {
            text: '',
            fontSize: 22
          }
        }
      };
    }
    _construct() {
      this._focusColor = 0xff009245;
      this._labelColor = 0xff9d9d9d;
      this._labelColorFocused = 0xffffffff;
      this._padding = 40;
      defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'padding']);
    }
    set label(str) {
      this.tag('Label').text.text = str;
      this._label = str;
    }
    get label() {
      return this._label;
    }
    _init() {
      const label = this.tag('Label');
      label.on('txLoaded', () => {
        this.patch({
          w: label.renderWidth,
          Focus: {
            w: label.renderWidth + this._padding * 2
          }
        });
        if (this.collectionWrapper) {
          this.collectionWrapper.reposition();
        }
      });
    }
    _focus() {
      this.patch({
        Focus: {
          smooth: {
            alpha: 1
          }
        },
        Label: {
          smooth: {
            color: this._labelColorFocused
          }
        }
      });
    }
    _unfocus(target) {
      if (target.isCarouselItem === true) {
        this.patch({
          Focus: {
            smooth: {
              alpha: 0
            }
          },
          Label: {
            smooth: {
              color: this._labelColor
            }
          }
        });
      }
    }
    _firstActive() {
      this.patch({
        Focus: {
          color: this._focusColor
        },
        Label: {
          color: this._labelColor
        }
      });
      if (this.cparent.componentIndex === this.collectionWrapper.currentItemWrapper.componentIndex) {
        this._focus();
      }
    }
    get isCarouselItem() {
      return true;
    }
    static get width() {
      return 120;
    }
    static get height() {
      return 50;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ProgressBar$1 extends lng$1.Component {
    static _template() {
      return {
        w: 300,
        h: 10,
        Background: {
          w: w => w,
          h: h => h,
          rect: true,
          rtt: true,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 5
          },
          Progress: {
            h: h => h,
            w: 10,
            rect: true,
            shader: {
              type: lng$1.shaders.RoundedRectangle,
              radius: 0
            }
          }
        }
      };
    }
    _construct() {
      this._progressColor = 0xff009245;
      this._progressColorFocused = undefined;
      this._backgroundColor = 0xff9d9d9d;
      this._backgroundColorFocused = undefined;
      this._backgroundRadius = 5;
      this._progressRadius = 0;
      this.value = 0.5;
      defineProperties(this, ['progressColor', 'backgroundColor', 'progressColorFocused', 'backgroundColorFocused']);
    }
    progress(p) {
      if (p > 1) {
        p = p / 100;
      }
      this._value = p;
      this.tag('Progress').w = this.w * p;
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({
        duration: 0.2,
        stopMethod: 'reverse',
        actions: [{
          t: 'Background',
          p: 'color',
          v: {
            0: this._backgroundColor,
            1: this._backgroundColorFocused || this._backgroundColor
          }
        }, {
          t: 'Background.Progress',
          p: 'color',
          v: {
            0: this._progressColor,
            1: this._progressColorFocused || this._progressColor
          }
        }]
      });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      this.patch({
        Background: {
          color: this._backgroundColor,
          shader: {
            radius: this._backgroundRadius
          },
          Progress: {
            color: this._progressColor,
            shader: {
              radius: this._progressRadius
            }
          }
        }
      });
      this.progress(this._value);
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _focus() {
      if (this._focusAnimation) {
        this._focusAnimation.start();
      }
    }
    _unfocus() {
      if (this._focusAnimation) {
        this._focusAnimation.stop();
      }
    }
    set value(p) {
      this._value = p;
      if (this.active) {
        this.progress(p);
      }
    }
    get value() {
      return this._value;
    }
    set backgroundRadius(num) {
      this._backgroundRadius = num;
      if (this.active) {
        this.tag('Background').shader.radius = num;
      }
    }
    get progressRadius() {
      return this._progressRadius;
    }
    set progressRadius(num) {
      this._progressRadius = num;
      if (this.active) {
        this.tag('Progress').shader.radius = num;
      }
    }
    get progressRadius() {
      return this._progressRadius;
    }
    get backgroundTag() {
      return this.tag('Background');
    }
    get progressTag() {
      return this.tag('Progress');
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /** Class for main view component in home UI */
  class MainView extends lng$1.Component {
    /**
     * Function to render various elements in main view.
     */
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('home'));
    }
    static _template() {
      return {
        rect: true,
        color: CONFIG.theme.background,
        w: 1920,
        h: 1080,
        clipping: true,
        MainView: {
          w: 1720,
          h: 1200,
          xIndex: 2,
          y: 270,
          x: 200,
          clipping: false,
          Text0: {
            alpha: 0,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language.translate('Popular Movies'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            },
            zIndex: 0
          },
          Gracenote: {
            y: 50,
            x: -20,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            type: lng$1.components.ListComponent,
            w: 1745,
            h: 400,
            itemSize: 500,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -1,
            clipping: false
          },
          Inputs: {
            y: 0,
            visible: false,
            //false by default
            Title: {
              y: 0,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language.translate('Input Select'),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Slider: {
              x: -20,
              y: 37,
              type: lng$1.components.ListComponent,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              w: 1745,
              h: 300,
              itemSize: 288,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            }
          },
          Text1: {
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language.translate('Featured Content'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            },
            zIndex: 0
          },
          AppList: {
            y: 37,
            x: 0,
            type: List,
            h: 400,
            scroll: {
              after: 2
            },
            spacing: 20
          },
          Text2: {
            // x: 10 + 25,
            y: 395,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language.translate('Lightning Apps'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          MetroApps: {
            x: -20,
            y: 435,
            type: lng$1.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            w: 1745,
            h: 300,
            itemSize: 288,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          },
          Text3: {
            // x: 10 + 25,
            y: 673,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language.translate('Featured Video on Demand'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          TVShows: {
            x: -20,
            y: 710,
            w: 1745,
            h: 400,
            type: lng$1.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            roll: true,
            itemSize: 277,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          },
          Text4: {
            // x: 10 + 25,
            y: 938,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language.translate('Lightning Showcase'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          ShowcaseApps: {
            x: -20,
            y: 978,
            type: lng$1.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            w: 1745,
            h: 400,
            itemSize: 277,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          },
          Text5: {
            alpha: 0,
            // x: 10 + 25,
            y: 1203,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language.translate('Partner Apps'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          UsbApps: {
            x: -20,
            y: 1243,
            type: lng$1.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            w: 1745,
            h: 400,
            itemSize: 277,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          }
        }
      };
    }
    pageTransition() {
      return 'up';
    }
    moveDownContent() {
      let inputSelectOffset = 0;
      if (this.inputSelect) {
        inputSelectOffset = 275;
      }
      this.tag('Text0').alpha = 1;
      this.tag("Inputs").y = 440;
      this.tag('Text1').y = 440 + inputSelectOffset;
      this.tag('AppList').y = 477 + inputSelectOffset;
      this.tag("Text2").y = 705 + inputSelectOffset;
      this.tag("MetroApps").y = 745 + inputSelectOffset;
      this.tag("Text3").y = 980 + inputSelectOffset;
      this.tag("TVShows").y = 1020 + inputSelectOffset;
      this.tag("Text4").y = 1248 + inputSelectOffset;
      this.tag("ShowcaseApps").y = 1288 + inputSelectOffset;
      this.tag("Text5").y = 1516 + inputSelectOffset;
      this.tag("UsbApps").y = 1556 + inputSelectOffset;
    }
    showInputSelect() {
      this.tag("Inputs").visible = true;
      let gracenoteOffset = 0;
      if (!this.gracenote) {
        gracenoteOffset = 440;
      }
      this.tag("Inputs").y = this.gracenote ? 440 : 0;
      this.tag('Text1').y = 440 + 275 - gracenoteOffset;
      this.tag('AppList').y = 477 + 275 - gracenoteOffset;
      this.tag("Text2").y = 705 + 275 - gracenoteOffset;
      this.tag("MetroApps").y = 745 + 275 - gracenoteOffset;
      this.tag("Text3").y = 980 + 275 - gracenoteOffset;
      this.tag("TVShows").y = 1020 + 275 - gracenoteOffset;
      this.tag("Text4").y = 1248 + 275 - gracenoteOffset;
      this.tag("ShowcaseApps").y = 1288 + 275 - gracenoteOffset;
      this.tag("Text5").y = 1516 + 275 - gracenoteOffset;
      this.tag("UsbApps").y = 1556 + 275 - gracenoteOffset;
    }

    /**
     * @param {any} data
     */
    setGracenoteData(data) {
      if (!this.gracenote) {
        this.gracenote = true;
        this.key = data.key;
        this.graceNoteItems = data.data;
        this.appItems = this.currentItems;
      }
    }
    _handleBack() {}
    _init() {
      this.gracenote = false;
      this.inputSelect = false; //false by default
      this.settingsScreen = false;
      this.indexVal = 0;
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this.usbApi = new UsbApi();
      this.homeApi = new HomeApi();
      this.xcastApi = new XcastApi();
      this.hdmiApi = new HDMIApi();
      this.appApi = new AppApi();
      let thunder = thunderJS(config);

      // for initially showing/hiding usb icon

      var appItems = this.homeApi.getAppListInfo();
      var data = this.homeApi.getPartnerAppsInfo();
      this.metroApps = this.homeApi.getOfflineMetroApps();
      this.showcaseApps = this.homeApi.getShowCaseApps();
      this.appApi.isConnectedToInternet().then(result => {
        if (result) {
          this.metroApps = this.homeApi.getOnlineMetroApps();
        }
      }).catch(err => {
        console.log(err);
      });
      var prop_apps = 'applications';
      var prop_displayname = 'displayName';
      var prop_uri = 'uri';
      var prop_apptype = 'applicationType';
      var appdetails = [];
      var appdetails_format = [];
      var usbAppsArr = [];
      var usbApps = 0;
      try {
        if (data != null && JSON.parse(data).hasOwnProperty(prop_apps)) {
          appdetails = JSON.parse(data).applications;
          for (var i = 0; i < appdetails.length; i++) {
            if (appdetails[i].hasOwnProperty(prop_displayname) && appdetails[i].hasOwnProperty(prop_uri) && appdetails[i].hasOwnProperty(prop_apptype)) {
              usbAppsArr.push(appdetails[i]);
              usbApps++;
            }
          }
          for (var i = 0; i < appItems.length; i++) {
            appdetails_format.push(appItems[i]);
          }
        } else {
          appdetails_format = appItems;
        }
      } catch (e) {
        appdetails_format = appItems;
        console.log('Query data is not proper: ' + e);
      }
      this.firstRowItems = appdetails_format;
      this.tempRow = JSON.parse(JSON.stringify(this.firstRowItems));
      if (this.firstRowItems[0].uri === 'USB') {
        this.tempRow.shift();
      }
      this.appItems = this.tempRow;
      this.usbApps = usbAppsArr;
      this.hdmiApi.activate().then(() => {
        this.hdmiApi.registerEvent('onDevicesChanged', notification => {
          console.log('onDevicesChanged ', JSON.stringify(notification));
        });
        this.hdmiApi.registerEvent('onInputStatusChanged', notification => {
          console.log('onInputStatusChanged ', JSON.stringify(notification));
        });
        this.hdmiApi.registerEvent('onSignalChanged', notification => {
          console.log('onSignalChanged ', JSON.stringify(notification));
          if (notification.signalStatus !== 'stableSignal') {
            this.appApi.setVisibility('ResidentApp', true);
            this.widgets.fail.notify({
              title: this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data.displayName,
              msg: 'Input disconnected'
            });
            Router.focusWidget('Fail');
          }
        });
        this.hdmiApi.registerEvent('videoStreamInfoUpdate', notification => {
          console.log('videoStreamInfoUpdate ', JSON.stringify(notification));
        });
        this.inputSelect = true; //set the inputSelect to true if the device is tv, here considering hdmiApi is only available on tv
        this.appItems = this.tempRow;
        this.hdmiApi.getHDMIDevices().then(res => {
          if (res.length > 0) this.inputItems = res;
        });
      }).catch(err => {
        console.log('HDMIInput Plugin not activated', err);
      });
      //get the available input methods from the api

      // for USB event
      const registerListener = () => {
        let listener;
        listener = thunder.on('org.rdk.UsbAccess', 'onUSBMountChanged', notification => {
          console.log('onUsbMountChanged notification: ', JSON.stringify(notification));
          Storage.set('UsbMountedStatus', notification.mounted ? 'mounted' : 'unmounted');
          const currentPage = window.location.href.split('#').slice(-1)[0];
          if (Storage.get('UsbMedia') === 'ON') {
            if (notification.mounted) {
              this.appItems = this.firstRowItems;
              this._setState('AppList.0');
            } else if (!notification.mounted) {
              this.appItems = this.tempRow;
              this._setState('AppList.0');
            }
            console.log("app items = ".concat(this.appItems, " ; "));
            if (currentPage === 'menu') {
              //refresh page to hide or show usb icon
              console.log('page refreshed on unplug/plug');
            }
            if (!notification.mounted) {
              //if mounted is false
              if (currentPage === 'usb' || currentPage === 'usb/image' || currentPage === 'usb/player') {
                // hot exit if we are on usb screen or sub screens
                // this.$changeHomeText('Home')
                Router.navigate('menu');
              }
            }
          }
          console.log("usb event successfully registered");
        });
        return listener;
      };
      thunder.on('org.rdk.Network.1', 'onIPAddressStatusChanged', notification => {
        console.log('IP ADDRESS changed', JSON.stringify(notification));
        if (notification.status === 'ACQUIRED') {
          Storage.set('ipAddress', notification.ip4Address);
          this.metroApps = this.homeApi.getOnlineMetroApps();
        } else {
          Storage.set('ipAddress', null);
          //this.metroApps = this.homeApi.getMetroInfo()
        }
      });

      this.fireAncestors("$mountEventConstructor", registerListener.bind(this));
      this.refreshFirstRow();
      // this._setState('AppList.0')
    }

    _firstActive() {
      if (!Storage.get('UsbMedia')) {
        this.usbApi.activate().then(res => {
          Storage.set('UsbMedia', 'ON');
          this.fireAncestors('$registerUsbMount');
        });
      } else if (Storage.get('UsbMedia') === 'ON') {
        this.usbApi.activate().then(res => {
          this.fireAncestors('$registerUsbMount');
        });
      } else if (Storage.get('UsbMedia') === 'OFF') {
        // deactivate usb Plugin here 
        this.usbApi.deactivate().then(res => {
          console.log("disabled the Usb Plugin");
        }).catch(err => {
          console.error("error while disabling the usb plugin = ".concat(err));
        });
      }
      if (this.gracenote) {
        this._setState("Gracenote");
      } else if (this.inputSelect) {
        this._setState("Inputs");
      } else {
        this._setState("AppList.0");
      }
    }
    _focus() {
      this._setState(this.state);
    }
    _firstEnable() {
      console.timeEnd('PerformanceTest');
      console.log('Mainview Screen timer end - ', new Date().toUTCString());
      this.networkApi = new Network();
      this.internetConnectivity = false;
    }
    scroll(val) {
      this.tag('MainView').patch({
        smooth: {
          y: [val, {
            timingFunction: 'ease',
            duration: 0.7
          }]
        }
      });
    }
    refreshFirstRow() {
      if (Storage.get('UsbMedia') === 'ON') {
        this.usbApi.activate().then(res => {
          this.usbApi.getMountedDevices().then(result => {
            if (result.mounted.length === 1) {
              this.appItems = this.firstRowItems;
            } else {
              this.appItems = this.tempRow;
            }
          });
        });
      } else if (Storage.get('UsbMedia') === 'OFF') {
        this.appItems = this.tempRow;
      } else {
        Storage.set('UsbMedia', 'ON');
        this.usbApi.activate().then(res => {
          this.usbApi.getMountedDevices().then(result => {
            if (result.mounted.length === 1) {
              this.appItems = this.firstRowItems;
            } else {
              this.appItems = this.tempRow;
            }
          });
        });
      }
    }

    /**
     * Function to set details of items in gracenote list.
     */
    set graceNoteItems(items) {
      this.moveDownContent();
      this.tag('Gracenote').items = items.map((info, idx) => {
        return {
          w: 480,
          h: 270,
          type: GracenoteItem,
          data: info,
          key: this.key,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 10
        };
      });
      this._setState('Gracenote');
    }
    set inputItems(items) {
      this.showInputSelect();
      this.tag("Inputs.Slider").items = items.map((info, idx) => {
        return {
          w: 268,
          h: 151,
          type: ListItem$1,
          data: {
            ...info,
            displayName: "Port ".concat(info.id),
            url: "/images/inputs/HDMI.jpg"
          },
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      });
      this._setState("Inputs.0");
    }
    set showcaseApps(items) {
      this.tag('ShowcaseApps').items = items.map((info, idx) => {
        return {
          w: 268,
          h: 151,
          type: ListItem$1,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      });
    }

    /**
     * Function to set details of items in app list.
     */
    set appItems(items) {
      this.currentItems = items;
      this.tag('AppList').clear();
      this.tag('AppList').add(items.map((info, idx) => {
        return {
          w: this.gracenote || this.inputSelect ? 268 : 454,
          h: this.gracenote || this.inputSelect ? 151 : 255,
          type: ListItem$1,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      }));
    }
    set metroApps(items) {
      this.tag('MetroApps').items = items.map((info, index) => {
        return {
          w: 268,
          h: 151,
          type: ListItem$1,
          data: info,
          focus: 1.15,
          unfocus: 1,
          idx: index,
          bar: 12
        };
      });
    }

    /**
     * Function to set details of items in tv shows list.
     */
    set tvShowItems(items) {
      this.tag('TVShows').items = items.map((info, idx) => {
        return {
          w: 257,
          h: 145,
          type: ListItem$1,
          data: info,
          focus: 1.15,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      });
    }
    set usbApps(items) {
      if (items.length > 0) {
        this.tag('Text5').alpha = 1;
      }
      this.tag('UsbApps').items = items.map((info, index) => {
        return {
          w: 257,
          h: 145,
          type: ListItem$1,
          data: info,
          focus: 1.15,
          unfocus: 1,
          idx: index,
          bar: 12
        };
      });
    }
    /**
     * Function to set the state in main view.
     */
    index(index) {
      if (index == 0) {
        this._setState('AppList');
      } else if (index == 1) {
        this._setState('MetroApps');
      } else if (index == 2) {
        this._setState('TVShows');
      } else if (index == 3) {
        if (this.tag('UsbApps').length) {
          this._setState('UsbApps');
        } else {
          this._setState('TVShows');
        }
      }
    }
    /**
     * Function to define various states needed for main view.
     */
    static _states() {
      return [class Gracenote extends this {
        $enter() {
          this.indexVal = 0;
          this.scroll(270);
        }
        $exit() {
          this.tag('Text0').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text0').text.fontStyle = 'bold';
          if (this.tag('Gracenote').length) {
            return this.tag('Gracenote').element;
          }
        }
        _handleDown() {
          if (this.inputSelect) {
            this._setState('Inputs');
          } else {
            this._setState('AppList');
          }
        }
        _handleRight() {
          if (this.tag('Gracenote').length - 1 != this.tag('Gracenote').index) {
            this.tag('Gracenote').setNext();
            return this.tag('Gracenote').element;
          }
        }
        _handleUp() {
          this.widgets.menu.notify('TopPanel');
        }
        _handleLeft() {
          this.tag('Text0').text.fontStyle = 'normal';
          if (0 != this.tag('Gracenote').index) {
            this.tag('Gracenote').setPrevious();
            return this.tag('Gracenote').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        _handleEnter() {
          Router.navigate('menu/details', {
            gracenoteItem: this.tag('Gracenote').element.data,
            key: this.key
          });
        }
      }, class Inputs extends this {
        $enter() {
          this.tag('Inputs.Title').text.fontStyle = 'bold';
          this.indexVal = 0;
          this.scroll(270);
        }
        $exit() {
          this.tag('Inputs.Title').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Inputs.Title').text.fontStyle = 'bold';
          if (this.tag("Inputs.Slider").length) {
            return this.tag("Inputs.Slider").element;
          }
        }
        _handleDown() {
          this._setState('AppList');
        }
        _handleUp() {
          if (this.gracenote) {
            this._setState('Gracenote');
          } else {
            this.widgets.menu.notify('TopPanel');
          }
        }
        _handleLeft() {
          if (0 != this.tag('Inputs.Slider').index) {
            this.tag('Inputs.Slider').setPrevious();
            return this.tag('Inputs.Slider').element;
          } else {
            this.tag('Inputs.Title').text.fontStyle = 'normal';
            Router.focusWidget('Menu');
          }
        }
        _handleRight() {
          if (this.tag('Inputs.Slider').length - 1 != this.tag('Inputs.Slider').index) {
            this.tag('Inputs.Slider').setNext();
            return this.tag('Inputs.Slider').element;
          }
        }
        _handleEnter() {
          console.log(this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data);
          this.hdmiApi.setHDMIInput(this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data).then(res => {
            console.log('completed');
            Storage.set('applicationType', 'HDMI');
            const currentInput = this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data;
            Storage.set("_currentInputMode", {
              id: currentInput.id,
              locator: currentInput.locator
            });
            this.appApi.setVisibility('ResidentApp', false);
          }).catch(err => {
            console.log('failed', err);
            this.widgets.fail.notify({
              title: this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data.displayName,
              msg: 'Select a different input.'
            });
            Router.focusWidget('Fail');
          });
        }
      }, class AppList extends this {
        $enter() {
          this.indexVal = 0;
          if (this.inputSelect && this.gracenote) {
            this.scroll(-100);
          } else {
            this.scroll(270);
          }
        }
        $exit() {
          this.tag('Text1').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text1').text.fontStyle = 'bold';
          if (this.tag('AppList').length) {
            return this.tag('AppList');
          }
        }
        _handleDown() {
          this._setState('MetroApps');
        }
        _handleUp() {
          if (this.inputSelect) {
            this._setState('Inputs');
          } else if (this.gracenote) {
            this._setState('Gracenote');
          } else {
            this.widgets.menu.notify('TopPanel');
          }
        }
        _handleLeft() {
          this.tag('Text1').text.fontStyle = 'normal';
          Router.focusWidget('Menu');
        }
        async _handleEnter() {
          let applicationType = this.tag('AppList').items[this.tag('AppList').index].data.applicationType;
          let uri = this.tag('AppList').items[this.tag('AppList').index].data.uri;
          if (uri === 'USB') {
            this.usbApi.getMountedDevices().then(result => {
              if (result.mounted.length === 1) {
                Router.navigate('usb');
              }
            });
          } else {
            let params = {
              url: uri,
              launchLocation: "mainView"
            };
            this.appApi.launchApp(applicationType, params).catch(err => {
              console.log("ApplaunchError: ", err);
            });
          }
        }
      }, class MetroApps extends this {
        $enter() {
          if (this.inputSelect && this.gracenote) {
            this.scroll(-200);
          } else {
            this.scroll(-100);
          }
          this.indexVal = 1;
        }
        $exit() {
          this.tag('Text2').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text2').text.fontStyle = 'bold';
          if (this.tag('MetroApps').length) {
            return this.tag('MetroApps').element;
          }
        }
        _handleUp() {
          this._setState('AppList');
        }
        _handleDown() {
          this._setState('TVShows');
        }
        _handleRight() {
          if (this.tag('MetroApps').length - 1 != this.tag('MetroApps').index) {
            this.tag('MetroApps').setNext();
            return this.tag('MetroApps').element;
          }
        }
        _handleLeft() {
          this.tag('Text2').text.fontStyle = 'normal';
          if (0 != this.tag('MetroApps').index) {
            this.tag('MetroApps').setPrevious();
            return this.tag('MetroApps').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        async _handleEnter() {
          let applicationType = this.tag('MetroApps').items[this.tag('MetroApps').index].data.applicationType;
          let params = {
            url: this.tag('MetroApps').items[this.tag('MetroApps').index].data.uri,
            launchLocation: "mainView"
          };
          this.appApi.launchApp(applicationType, params).catch(err => {
            console.log("ApplaunchError: ", JSON.stringify(err), err);
          });
        }
      }, class TVShows extends this {
        $enter() {
          this.indexVal = 2;
          if (this.inputSelect && this.gracenote) {
            this.scroll(-600);
          } else {
            this.scroll(-400);
          }
        }
        _handleUp() {
          this.scroll(270);
          this._setState('MetroApps');
        }
        _getFocused() {
          this.tag('Text3').text.fontStyle = 'bold';
          if (this.tag('TVShows').length) {
            return this.tag('TVShows').element;
          }
        }
        _handleRight() {
          if (this.tag('TVShows').length - 1 != this.tag('TVShows').index) {
            this.tag('TVShows').setNext();
            return this.tag('TVShows').element;
          }
        }
        _handleLeft() {
          this.tag('Text3').text.fontStyle = 'normal';
          if (0 != this.tag('TVShows').index) {
            this.tag('TVShows').setPrevious();
            return this.tag('TVShows').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        _handleDown() {
          // if (this.tag('UsbApps').length) {
          this._setState("ShowcaseApps");
          //}
        }

        async _handleEnter() {
          try {
            this.internetConnectivity = await this.networkApi.isConnectedToInternet();
          } catch {
            this.internetConnectivity = false;
          }
          if (this.internetConnectivity) {
            //this.fireAncestors('$goToPlayer')
            Router.navigate('player');
          }
        }
        $exit() {
          this.tag('Text3').text.fontStyle = 'normal';
        }
      }, class ShowcaseApps extends this {
        $enter() {
          if (this.inputSelect && this.gracenote) {
            this.scroll(-750);
          } else {
            this.scroll(-550);
          }
        }
        $exit() {
          this.tag('Text4').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text4').text.fontStyle = 'bold';
          if (this.tag('ShowcaseApps').length) {
            return this.tag('ShowcaseApps').element;
          }
        }
        _handleUp() {
          this._setState('TVShows');
        }
        _handleRight() {
          if (this.tag('ShowcaseApps').length - 1 != this.tag('ShowcaseApps').index) {
            this.tag('ShowcaseApps').setNext();
            return this.tag('ShowcaseApps').element;
          }
        }
        _handleDown() {
          if (this.tag('UsbApps').length) {
            this._setState("UsbApps");
          }
        }
        _handleLeft() {
          this.tag('Text4').text.fontStyle = 'normal';
          if (0 != this.tag('ShowcaseApps').index) {
            this.tag('ShowcaseApps').setPrevious();
            return this.tag('ShowcaseApps').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        async _handleEnter() {
          let applicationType = this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.applicationType;
          let params = {
            url: this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.uri,
            launchLocation: "mainView"
          };
          this.appApi.launchApp(applicationType, params).catch(err => {
            console.log("ApplaunchError: ", JSON.stringify(err), err);
          });
        }
      }, class UsbApps extends this {
        $enter() {
          if (this.inputSelect && this.gracenote) {
            this.scroll(-1000);
          } else {
            this.scroll(-750);
          }
        }
        $exit() {
          this.tag('Text5').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text5').text.fontStyle = 'bold';
          if (this.tag('UsbApps').length) {
            return this.tag('UsbApps').element;
          }
        }
        _handleUp() {
          this._setState('ShowcaseApps');
        }
        _handleRight() {
          if (this.tag('UsbApps').length - 1 != this.tag('MetroApps').index) {
            this.tag('UsbApps').setNext();
            return this.tag('UsbApps').element;
          }
        }
        _handleLeft() {
          this.tag('Text5').text.fontStyle = 'normal';
          if (0 != this.tag('UsbApps').index) {
            this.tag('UsbApps').setPrevious();
            return this.tag('UsbApps').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        async _handleEnter() {
          let applicationType = this.tag('UsbApps').items[this.tag('UsbApps').index].data.applicationType;
          let params = {
            url: this.tag('UsbApps').items[this.tag('UsbApps').index].data.uri,
            launchLocation: "mainView"
          };
          this.appApi.launchApp(applicationType, params).catch(err => {
            console.log("ApplaunchError: ", JSON.stringify(err), err);
          });
        }
      }, class RightArrow extends this {
        //TODO
      }, class LeftArrow extends this {
        //TODO
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let _item$1;
  /**
   * Class for pairing screen for the Bluetooth.
   */
  class BluetoothPairingScreen$1 extends lng$1.Component {
    set params(args) {
      if (args.bluetoothItem) {
        this.item(args.bluetoothItem);
      } else {
        Router.navigate('settings/bluetooth');
      }
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xff000000,
        BluetoothPair: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Pairing: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 0,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            ConnectDisconnect: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Unpair: {
              x: 0 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Unpair"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 0 + 220 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    item(item) {
      _item$1 = item;
      this._setState('ConnectDisconnect');
      this.tag('Title').text = item.name;
      if (item.connected) {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = 'Disconnect';
      } else {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = 'Connect';
      }
    }
    _init() {
      this._setState('ConnectDisconnect');
    }
    static _states() {
      return [class ConnectDisconnect extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          // this.tag('Pairing').text = "Someting is wrong " + _item.name
          if (_item$1.connected) {
            // this.tag('Pairing').text = "Connecting to " + _item.name
            //this.fireAncestors('$pressEnter', 'Disconnect')
            Router.navigate('settings/bluetooth', {
              action: 'Disconnect'
            });
          } else {
            // this.tag('Pairing').text = "Disconnecting from " + _item.name
            // this.fireAncestors('$pressEnter', 'Connect')
            Router.navigate('settings/bluetooth', {
              action: 'Connect'
            });
          }
        }
        _handleRight() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Unpair extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          //this.fireAncestors('$pressEnter', 'Unpair')
          Router.navigate('settings/bluetooth', {
            action: 'Unpair'
          });
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _handleLeft() {
          this._setState('ConnectDisconnect');
        }
        _focus() {
          this.tag('Unpair').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Unpair').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          //this.fireAncestors('$pressEnter', 'Cancel')
          Router.navigate('settings/bluetooth', {
            action: 'Cancel'
          });
        }
        _handleLeft() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for the item in the Bluetooth screen.
   */
  class BluetoothItem extends SettingsItem {
    static _template() {
      return {
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents of an item in the Bluetooth screen.
     */
    set item(item) {
      this._item = item;
      this.connected = item.connected ? 'Connected' : 'Not Connected';
      this.status = item.paired ? this.connected : 'Not Paired';
      this.tag('Item').patch({
        Left: {
          x: 10,
          y: 45,
          mountY: 0.5,
          text: {
            text: item.name,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        },
        Right: {
          x: 1600 - 200,
          y: 30,
          mountY: 0.5,
          mountX: 1,
          Text: {
            text: {
              text: this.status,
              fontSize: 25,
              fontFace: CONFIG.language.font,
              verticalAlign: "middle"
            }
          }
        }
        //  Debug:{
        //    x: 300,
        //    y:5,
        //    mountY: 0.5,
        //    mountX:1,
        //    Text: { text: { text: `item: ${JSON.stringify(item)}`, fontSize: 15,fontFace:CONFIG.language.font,verticalAlign:"middle" } },
        //  }
      });
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 10
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
    // _handleEnter() {
    //   // this.tag("Item").patch(
    //   //   {
    //   //     text: {
    //   //       text: "this works",
    //   //     }
    //   //   }
    //   // )
    //   this.fireAncestors('$connectBluetooth', this.tag('List').element.ref)
    // }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Bluetooth thunder plugin apis.
   */

  class BluetoothApi {
    constructor() {
      this._events = new Map();
      this._devices = [];
      this._pairedDevices = [];
      this._connectedDevices = [];
      this.btStatus = false;
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS(config);
    }

    /**
     * Function to activate the Bluetooth plugin
     */

    btactivate() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Bluetooth';
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          resolve(true);
        }).catch(err => {
          reject(err);
        });
      });
    }
    deactivateBluetooth() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Bluetooth';
        this._thunder.call('Controller', 'deactivate', {
          callsign: this.callsign
        }).then(result => {
          resolve(true);
        }).catch(err => {
          reject(err);
        });
      });
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Bluetooth';
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this.btStatus = true;
          this._thunder.on(this.callsign, 'onDiscoveredDevice', notification => {
            // this.getDiscoveredDevices().then(() => {
            this._events.get('onDiscoveredDevice')(notification);
            // })
          });

          this._thunder.on(this.callsign, 'onStatusChanged', notification => {
            if (notification.newStatus === 'PAIRING_CHANGE') {
              this.getPairedDevices();
            } else if (notification.newStatus === 'CONNECTION_CHANGE') {
              this.getConnectedDevices().then(() => {
                this._events.get('onConnectionChange')(notification);
              });
            } else if (notification.newStatus === 'DISCOVERY_STARTED') {
              this.getConnectedDevices().then(() => {
                this._events.get('onDiscoveryStarted')();
              });
            } else if (notification.newStatus === 'DISCOVERY_COMPLETED') {
              this.getConnectedDevices().then(() => {
                this._events.get('onDiscoveryCompleted')();
              });
            }
          });
          this._thunder.on(this.callsign, 'onPairingRequest', notification => {
            this._events.get('onPairingRequest')(notification);
          });
          this._thunder.on(this.callsign, 'onRequestFailed', notification => {
            this._events.get('onRequestFailed')(notification);
          });
          this._thunder.on(this.callsign, 'onConnectionRequest', notification => {
            this._events.get('onConnectionRequest')(notification);
          });
          resolve('Blutooth activated');
        }).catch(err => {
          console.error('Activation failure', err);
          reject('Bluetooth activation failed', err);
        });
      });
    }

    /**
     *
     * @param {string} eventId
     * @param {function} callback
     * Function to register the events for the Bluetooth plugin.
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Function to deactivate the Bluetooth plugin.
     */
    deactivate() {
      this._events = new Map();
    }

    /**
     * Function to disable the Bluetooth stack.
     */
    disable() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'disable').then(result => {
          this.btStatus = false;
          resolve(result);
        }).catch(err => {
          console.error("Can't disable : ".concat(JSON.stringify(err)));
        });
      });
    }

    /**
     * Function to enable the Bluetooth stack.
     */
    enable() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'enable').then(result => {
          resolve(result);
          this.btStatus = true;
        }).catch(err => {
          console.error("Can't enable : ".concat(JSON.stringify(err)));
          reject();
        });
      });
    }

    /**
     * Function to start scanning for the Bluetooth devices.
     */
    startScan() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'startScan', {
          timeout: '10',
          profile: "KEYBOARD,\n                    MOUSE,\n                    JOYSTICK,\n                    HUMAN INTERFACE DEVICE"
        }).then(result => {
          if (result.success) resolve();else reject();
        }).catch(err => {
          console.error('Error', err);
          reject();
        });
      });
    }
    startScanBluetooth() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'startScan', {
          timeout: 1000,
          profile: "KEYBOARD,\n          MOUSE,\n          JOYSTICK,\n          HUMAN INTERFACE DEVICE"
        }).then(result => {
          if (result.success) resolve(result);else reject(result);
        }).catch(err => {
          console.error('Error', err);
          reject(err);
        });
      });
    }

    /**
     * Function to stop scanning for the Bluetooth devices.
     */
    stopScan() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'stopScan', {}).then(result => {
          if (result.success) resolve();else reject();
        }).catch(err => {
          console.error('Error', err);
          reject();
        });
      });
    }

    /**
     * Function returns the discovered Bluetooth devices.
     */
    getDiscoveredDevices() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getDiscoveredDevices').then(result => {
          this._devices = result.discoveredDevices;
          resolve(result.discoveredDevices);
        }).catch(err => {
          console.error("Can't get discovered devices : ".concat(JSON.stringify(err)));
        });
      });
    }
    get discoveredDevices() {
      return this._devices;
    }

    /**
     * Function returns the paired Bluetooth devices.
     */
    getPairedDevices() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getPairedDevices').then(result => {
          this._pairedDevices = result.pairedDevices;
          resolve(result.pairedDevices);
        }).catch(err => {
          console.error("Can't get paired devices : ".concat(err));
          reject(false);
        });
      });
    }
    get pairedDevices() {
      return this._pairedDevices;
    }

    /**
     * Function returns the connected Bluetooth devices.
     */
    getConnectedDevices() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getConnectedDevices').then(result => {
          this._connectedDevices = result.connectedDevices;
          resolve(result.connectedDevices);
        }).catch(err => {
          console.error("Can't get connected devices : ".concat(err));
          reject();
        });
      });
    }
    get connectedDevices() {
      return this._connectedDevices;
    }

    /**
     *
     * Function to connect a Bluetooth device.
     * @param {number} deviceID Device ID of the Bluetoth client.
     * @param {string} deviceType Device type of the Bluetooth client.
     */
    connect(deviceID, deviceType) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'connect', {
          deviceID: deviceID,
          deviceType: deviceType,
          connectedProfile: deviceType
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error('Connection failed', err);
          reject();
        });
      });
    }

    /**
     * Function to disconnect a Bluetooth device.
     *@param {number} deviceID Device ID of the Bluetoth client.
     *@param {string} deviceType Device type of the Bluetooth client.
     */
    disconnect(deviceID, deviceType) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'disconnect', {
          deviceID: deviceID,
          deviceType: deviceType
        }).then(result => {
          if (result.success) resolve(true);else reject();
        }).catch(err => {
          console.error('disconnect failed', err);
          reject();
        });
      });
    }

    /**
     * Function to unpair a Bluetooth device.
     * @param {number} deviceId
     */
    unpair(deviceId) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'unpair', {
          deviceID: deviceId
        }).then(result => {
          if (result.success) resolve(result.success);else resolve(false);
        }).catch(err => {
          console.error('unpair failed', err);
          resolve(false);
        });
      });
    }

    /**
     * Function to pair a Bluetooth device.
     * @param {number} deviceId
     */
    pair(deviceId) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'pair', {
          deviceID: deviceId
        }).then(result => {
          if (result.success) resolve(result);else reject(result);
        }).catch(err => {
          console.error('Error on pairing', err);
          reject();
        });
      });
    }

    /**
     * Function to respond to client the Bluetooth event.
     * @param {number} deviceID Device ID of the Bluetooth client.
     * @param {string} eventType Name of the event.
     * @param {string} responseValue Response sent to the Bluetooth client.
     */
    respondToEvent(deviceID, eventType, responseValue) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'respondToEvent', {
          deviceID: deviceID,
          eventType: eventType,
          responseValue: responseValue
        }).then(result => {
          if (result.success) resolve();else reject();
        }).catch(err => {
          console.error('Error on respondToEvent', err);
          reject();
        });
      });
    }

    /**
     * Function to get the discoverable name of the Bluetooth plugin.
     */
    getName() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getName').then(result => {
          resolve(result.name);
        });
      });
    }
    setAudioStream(deviceID) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'setAudioStream', {
          "deviceID": deviceID,
          "audioStreamName": "AUXILIARY"
        }).then(result => {
          // console.log(JSON.stringify(result))
          this._connectedDevices = result.connectedDevices;
          resolve(result.connectedDevices);
        }).catch(err => {
          console.error("Can't get connected devices : ".concat(err));
          reject();
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for pairing screen for the Bluetooth.
   */
  class BluetoothConfirmation extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Title: {
          mountX: 0.5,
          text: {
            text: "",
            fontFace: CONFIG.language.font,
            fontSize: 40,
            textColor: CONFIG.theme.hex
          }
        },
        BorderTop: {
          x: 0,
          y: 75,
          w: 1558,
          h: 3,
          rect: true,
          mountX: 0.5
        },
        Pairing: {
          x: 0,
          y: 125,
          mountX: 0.5,
          text: {
            text: "",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        RectangleDefault: {
          x: 0,
          y: 200,
          w: 200,
          mountX: 0.5,
          h: 50,
          rect: true,
          color: CONFIG.theme.hex,
          Ok: {
            x: 100,
            y: 25,
            mount: 0.5,
            text: {
              text: "OK",
              fontFace: CONFIG.language.font,
              fontSize: 22
            }
          }
        },
        BorderBottom: {
          x: 0,
          y: 300,
          w: 1558,
          h: 3,
          rect: true,
          mountX: 0.5
        }
      };
    }
    set item(item) {
      this.tag('Title').text = item.name;
    }
    _handleEnter() {
      this.fireAncestors('$pressOK');
    }
    _handleBack() {
      this.fireAncestors('$pressOK');
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Bluetooth screen.
   */
  class BluetoothScreen$2 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Bluetooth On/Off'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        Bluetooth: {
          y: 275,
          x: 200,
          Confirmation: {
            x: 780,
            y: 100,
            type: BluetoothConfirmation,
            visible: false
          },
          PairingScreen: {
            x: 780,
            y: 100,
            type: BluetoothPairingScreen$1,
            zIndex: 100,
            visible: false
          },
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Bluetooth On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Searching: {
            visible: false,
            h: 90,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Searching for Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              // x: 1600,
              x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            }
          },
          Networks: {
            PairedNetworks: {
              y: 180,
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            AvailableNetworks: {
              y: 90,
              visible: false,
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            visible: false
          },
          AddADevice: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Add A Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        }
      };
    }

    /**
     * @param {{ action: String; }} args
     */
    set params(args) {
      if (args.action) {
        this.pressEnter(args.action);
      }
    }
    _unfocus() {
      this._disable();
    }
    pageTransition() {
      return 'left';
    }
    _firstEnable() {
      this._bt = new BluetoothApi();
      this._bluetooth = false;
      this._activateBluetooth();
      this._setState('Switch');
      //this.switch()
      //this._bluetooth = false
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this.renderDeviceList();
      this.loadingAnimation = this.tag('Searching.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState('AddADevice');
      this._enable();
      if (this._bluetooth) {
        this.tag('Networks').visible = true;
        this.tag('AddADevice').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.renderDeviceList();
        //this._bt.startScan()
      }
    }

    _handleBack() {
      Router.navigate('settings');
    }
    /**
     * Function to be excuted when the Bluetooth screen is enabled.
     */
    _enable() {
      if (this._bluetooth) {
        this._bt.startScan();
      }
      this.scanTimer = Registry.setInterval(() => {
        if (this._bluetooth) {
          this._bt.startScan();
        }
      }, 5000);
    }

    /**
     * Function to be executed when the Bluetooth screen is disabled from the screen.
     */
    _disable() {
      Registry.clearInterval(this.scanTimer);
      this._bt.stopScan();
    }

    /**
     * Function to be executed when add a device is pressed
     */

    showAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: true
      });
      this.tag('AvailableNetworks').patch({
        visible: true
      });
      //  this.loadingAnimation.stop()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    hideAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      //  this.loadingAnimation.start()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    showPairingScreen() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: true
      });
      this.fireAncestors('$hideTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    hidePairingScreen() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: false
      });
      this.fireAncestors('$showTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    showConfirmation() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: true
      });
      this.fireAncestors('$hideTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    hideConfirmation() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      this.fireAncestors('$showTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    /**
     * Function to render list of Bluetooth devices
     */
    renderDeviceList() {
      this._bt.getPairedDevices().then(result => {
        this._pairedList = result;
        this._pairedNetworks.h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
          item.paired = true;
          return {
            ref: 'Paired' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
      this._bt.getDiscoveredDevices().then(result => {
        this._discoveredList = result;
        this._otherList = this._discoveredList.filter(device => {
          if (!device.paired) {
            result = this._pairedList.map(a => a.deviceID);
            if (result.includes(device.deviceID)) {
              return false;
            } else return device;
          }
        });
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          return {
            ref: 'Other' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        this._setState('Switch');
      } else if (option === 'Pair') {
        this._bt.pair(this._availableNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._availableNetworks.tag('List').element._item.name;
          if (result.success) {
            this.widgets.fail.notify({
              title: btName,
              msg: 'Pairing Succesful'
            });
            Router.focusWidget('Fail');
          } else {
            this.widgets.fail.notify({
              title: btName,
              msg: 'Pairing Failed'
            });
            Router.focusWidget('Fail');
          }
          this.hideAvailableDevices();
        });
      } else if (option === 'Connect') {
        this._bt.connect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.widgets.fail.notify({
              title: btName,
              msg: 'Connection Failed'
            });
            Router.focusWidget('Fail');
          } else {
            this._bt.setAudioStream(this._pairedNetworks.tag('List').element._item.deviceID);
            this.widgets.fail.notify({
              title: btName,
              msg: 'Connection Successful'
            });
            Router.focusWidget('Fail');
          }
        });
      } else if (option === 'Disconnect') {
        this._bt.disconnect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.widgets.fail.notify({
              title: btName,
              msg: 'Failed to Disconnect'
            });
            Router.focusWidget('Fail');
          } else {
            this.widgets.fail.notify({
              title: btName,
              msg: 'Disconnected'
            });
            Router.focusWidget('Fail');
          }
        });
      } else if (option === 'Unpair') {
        this._bt.unpair(this._pairedNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (result) {
            this.widgets.fail.notify({
              title: btName,
              msg: 'Unpaired'
            });
            Router.focusWidget('Fail');
          } else {
            this.widgets.fail.notify({
              title: btName,
              msg: 'Unpairing Failed'
            });
            Router.focusWidget('Fail');
          }
        });
      }
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          this.hideAvailableDevices();
          this.hidePairingScreen();
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          this._setState('AddADevice');
        }
        _handleEnter() {
          this.switch();
        }
      }, class Confirmation extends this {
        $enter() {
          this.showConfirmation();
        }
        _getFocused() {
          return this.tag('Confirmation');
        }
        $pressOK() {
          this._setState('Switch');
          this.hideConfirmation();
        }
      }, class PairedDevices extends this {
        $enter() {
          this.hideAvailableDevices();
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          //this.showPairingScreen()
          //this.tag('PairingScreen').item = this._pairedNetworks.tag('List').element._item
          Router.navigate('settings/bluetooth/pairing', {
            bluetoothItem: this._pairedNetworks.tag('List').element._item
          });
          //this._setState('PairingScreen')
        }
      }, class AvailableDevices extends this {
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          this.pressEnter('Pair');
          //this.tag('Confirmation').item = this._availableNetworks.tag('List').element._item
        }

        _handleBack() {
          this.hideAvailableDevices();
          this._setState('Switch');
        }
      }, class AddADevice extends this {
        $enter() {
          this.tag('AddADevice')._focus();
          this.hideAvailableDevices();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleDown() {
          if (this._bluetooth) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('AddADevice')._unfocus();
        }
        _handleEnter() {
          if (this._bluetooth) {
            this.showAvailableDevices();
            this._setState('AvailableDevices');
          }
        }
      }, class PairingScreen extends this {
        $enter() {
          this._disable();
          this._bt.stopScan();
          return this.tag('PairingScreen');
        }
        _getFocused() {
          return this.tag('PairingScreen');
        }
        $exit() {
          this.tag('PairingScreen').visible = false;
          this._enable();
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */
    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) ;
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) ; else if (listname === 'MyDevices') {
            this._setState('AddADevice');
          }
        }
      }
    }

    /**
     * Function to turn on and off Bluetooth.
     */
    switch() {
      if (this._bluetooth) {
        this._bt.disable().then(result => {
          if (result.success) {
            this._bluetooth = false;
            this.tag('Networks').visible = false;
            this.tag('AddADevice').visible = false;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          }
        }).catch(() => {
          console.log('Cannot turn off Bluetooth');
        });
      } else {
        this._bt.enable().then(result => {
          if (result.success) {
            this._bluetooth = true;
            this.tag('Networks').visible = true;
            this.tag('AddADevice').visible = true;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.renderDeviceList();
            this._bt.startScan();
          }
        }).catch(() => {
          console.log('Cannot turn on Bluetooth');
        });
      }
    }

    /**
     * Function to activate Bluetooth plugin.
     */
    _activateBluetooth() {
      this._bt.activate().then(res => {
        console.log(res);
        this._bluetooth = true;
        this._bt.registerEvent('onDiscoveredDevice', () => {
          this.renderDeviceList();
        });
        this._bt.registerEvent('onPairingRequest', notification => {
          this.respondToPairingRequest(notification.deviceID, 'ACCEPTED');
        });
        this._bt.registerEvent('onConnectionChange', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          let btName = notification.name;
          if (notification.connected) {
            if (this.widgets.fail) {
              this.widgets.fail.notify({
                title: btName,
                msg: 'CONNECTION SUCCESS'
              });
              Router.focusWidget('Fail');
            }
          } else {
            if (this.widgets.fail) {
              this.widgets.fail.notify({
                title: btName,
                msg: 'CONNECTION FAILED'
              });
              Router.focusWidget('Fail');
            }
          }
        });
        this._bt.registerEvent('onDiscoveryCompleted', () => {
          this.tag('Searching.Loader').visible = false;
          this.loadingAnimation.stop();
          this.renderDeviceList();
        });
        this._bt.registerEvent('onDiscoveryStarted', () => {
          this.loadingAnimation.start();
          this.tag('Searching.Loader').visible = true;
        });
        this._bt.registerEvent('onRequestFailed', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          if (this.widgets.fail) {
            this.widgets.fail.notify({
              title: notification.name,
              msg: notification.newStatus
            });
            Router.focusWidget('Fail');
          }
        });
      }).catch(err => {
        console.log(err);
      });
    }

    /**
     * Function to respond to Bluetooth client.
     * @param {number} deviceID
     * @param {string} responseValue
     */
    respondToPairingRequest(deviceID, responseValue) {
      this._bt.respondToEvent(deviceID, 'onPairingRequest', responseValue);
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Colors
   *
   * Contains global color style information to easily maintain consistency throughout components.
   */

  /**
   * Combines rgb hex string and alpha into argb hexadecimal number
   * @param {string} hex - 6 alphanumeric characters between 0-f
   * @param {number} [alpha] - number between 0-100 (0 is invisible, 100 is opaque)
   */
  function getHexColor$1(hex) {
    let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    if (!hex) {
      return 0x00;
    }
    let hexAlpha = Math.round(alpha / 100 * 255).toString(16);
    let str = "0x".concat(hexAlpha).concat(hex);
    return parseInt(Number(str), 10);
  }

  /**
   * Pair color values with color names in the "Neutral" palette
   */
  const COLORS_NEUTRAL = {
    dark1: '000000',
    dark2: '080808',
    dark3: '101010',
    light1: 'FFFFFF',
    light2: 'F5F5F5',
    light3: 'E8E8E8'
  };

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  /**
   * Returns a styles object for use by components
   * @param {Object|function} styles - Object or callback that takes theme as an argument, ultimately the returned value
   * @param {Object} theme - theme to be provided to styles
   */
  var createStyles$1 = ((styles, theme) => {
    return typeof styles === 'function' ? styles(theme) : styles;
  });

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Helpers for lng.Tools.getRoundRect
   */
  const RoundRect = {
    /**
     * Returns a value that will render as the given width (w)
     * when passed to lng.Tools.getRoundRect
     * @param {number} w - px value for expected width
     * @param {*} options
     * @param {number} options.padding - px value for both left and right padding
     * @param {number} options.paddingLeft - px value for left padding, overrides options.padding
     * @param {number} options.paddingRight - px value for right padding, overrides options.padding
     * @param {number} options.strokeWidth - px value for stroke width
     */
    getWidth(w) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        padding,
        paddingLeft,
        paddingRight,
        strokeWidth
      } = {
        padding: 0,
        paddingLeft: 0,
        paddingRight: 0,
        strokeWidth: 0,
        ...options
      };
      if (!w) return 0;
      return w - (paddingLeft || padding) - (paddingRight || padding) - strokeWidth;
    },
    /**
     * Returns a value that will render as the given height (h)
     * when passed to lng.Tools.getRoundRect
     * @param {number} h - px value for expected width
     * @param {*} options
     * @param {number} options.padding - px value for both bottom and top padding
     * @param {number} options.paddingBottom - px value for bottom padding, overrides options.padding
     * @param {number} options.paddingTop - px value for top padding, overrides options.padding
     * @param {number} options.strokeWidth - px value for stroke width
     */
    getHeight(h) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        padding,
        paddingBottom,
        paddingTop,
        strokeWidth
      } = {
        padding: 0,
        paddingBottom: 0,
        paddingTop: 0,
        strokeWidth: 0,
        ...options
      };
      if (!h) return 0;
      return h - (paddingBottom || padding) - (paddingTop || padding) - strokeWidth;
    }
  };

  /**
   * Merges two objects together and returns the duplicate.
   *
   * @param {Object} target - object to be cloned
   * @param {Object} [object] - secondary object to merge into clone
   */
  function clone$1(target, object) {
    const _clone = {
      ...target
    };
    if (!object || target === object) return _clone;
    for (let key in object) {
      const value = object[key];
      if (target.hasOwnProperty(key)) {
        _clone[key] = getMergeValue$1(key, target, object);
      } else {
        _clone[key] = value;
      }
    }
    return _clone;
  }
  function getMergeValue$1(key, target, object) {
    const targetVal = target[key];
    const objectVal = object[key];
    const targetValType = typeof targetVal;
    const objectValType = typeof objectVal;
    if (targetValType !== objectValType || objectValType === 'function' || Array.isArray(objectVal)) {
      return objectVal;
    }
    if (objectVal && objectValType === 'object') {
      return clone$1(targetVal, objectVal);
    }
    return objectVal;
  }

  /**
   * Returns the rendered width of a given text texture
   * @param {Object} text - text texture properties
   * @param {string} text.text - text value
   * @param {string} text.fontStyle - css font-style property
   * @param {(string|number)} text.fontWeight - css font-weight property
   * @param {string} [fontSize=0] - css font-size property (in px)
   * @param {string} [text.fontFamily=sans-serif] - css font-weight property
   * @param {string} text.fontFace - alias for fontFamily
   *
   * @returns {number} text width
   * */
  function measureTextWidth() {
    let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const {
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily = text.fontFace || 'sans-serif'
    } = text;
    const fontCss = [fontStyle, fontWeight, fontSize ? "".concat(fontSize, "px") : '0', "'".concat(fontFamily, "'")].filter(Boolean).join(' ');
    ctx.font = fontCss;
    const textMetrics = ctx.measureText(text.text || '');
    return Math.round(textMetrics.width);
  }

  /**
   * Returns first argument that is a number. Useful for finding ARGB numbers. Does not convert strings to numbers
   * @param {...*} number - maybe a number
   **/
  function getFirstNumber() {
    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
      numbers[_key] = arguments[_key];
    }
    return numbers.find(Number.isFinite);
  }

  /**
   * Naively looks for dimensional prop (i.e. w, h, x, y, etc.), first searching for
   * a transition target value then defaulting to the current set value
   * @param {string} prop - property key
   * @param {lng.Component} component - Lightning component to operate against
   */
  function getDimension$1(prop, component) {
    if (!component) return 0;
    const transition = component.transition(prop);
    if (transition.isRunning()) return transition.targetValue;
    return component[prop];
  }
  const getX = getDimension$1.bind(null, 'x');
  const getY = getDimension$1.bind(null, 'y');
  const getW = component => getDimension$1('w', component) || component.renderWidth;
  const getH = component => getDimension$1('h', component) || component.renderHeight;

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const gradientColor = COLORS_NEUTRAL.light2;
  ({
    duration: 0.6,
    actions: [{
      p: 'colorUl',
      v: {
        0: getHexColor$1(gradientColor, 72),
        1: getHexColor$1(gradientColor, 56)
      }
    }, {
      p: 'colorUr',
      v: {
        0: getHexColor$1(gradientColor, 24),
        1: getHexColor$1(gradientColor, 16)
      }
    }, {
      p: 'colorBr',
      v: {
        0: 0x00,
        1: getHexColor$1(gradientColor, 0)
      }
    }, {
      p: 'colorBl',
      v: {
        0: getHexColor$1(gradientColor, 24),
        1: getHexColor$1(gradientColor, 16)
      }
    }]
  });

  /**
   * Returns a function, that, as long as it continues to be invoked, will not
   * be triggered. The function will be called after it stops being called for
   * N milliseconds. If `immediate` is passed, trigger the function on the
   * leading edge, instead of the trailing. The function also has a property 'clear' 
   * that is a function which will clear the timer to prevent previously scheduled executions. 
   *
   * @source underscore.js
   * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
   * @param {Function} function to wrap
   * @param {Number} timeout in ms (`100`)
   * @param {Boolean} whether to execute at the beginning (`false`)
   * @api public
   */
  function debounce(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    if (null == wait) wait = 100;
    function later() {
      var last = Date.now() - timestamp;
      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    }
    var debounced = function () {
      context = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
    debounced.clear = function () {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    debounced.flush = function () {
      if (timeout) {
        result = func.apply(context, args);
        context = args = null;
        clearTimeout(timeout);
        timeout = null;
      }
    };
    return debounced;
  }

  // Adds compatibility for ES modules
  debounce.debounce = debounce;
  var debounce_1 = debounce;

  /**
  * Copyright 2020 Comcast Cable Communications Management, LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  * SPDX-License-Identifier: Apache-2.0
  */
  function withStyles$1(Base, styles, theme) {
    const _theme = theme || Base.theme;
    const _styles = Base.styles ? clone$1(Base.styles, createStyles$1(styles, _theme)) : createStyles$1(styles, _theme);
    return class extends Base {
      static get name() {
        return Base.name;
      }
      static get styles() {
        return _styles;
      }
      get styles() {
        return _styles;
      }
    };
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Icon extends lng$1.Component {
    static _template() {
      return {
        color: 0xffffffff,
        w: 0,
        h: 0
      };
    }
    get icon() {
      return this._icon;
    }
    set icon(icon) {
      this._icon = icon;
      this._update();
    }
    _init() {
      this._update();
    }
    _update() {
      const {
        icon,
        w,
        h
      } = this;
      const template = getIconTemplate(icon, w, h);
      this.patch(template);
    }
  }
  const [isSvgTag, isSvgURI, isImageURI] = [/^<svg.*<\/svg\>$/, /\.svg$/, /\.(a?png|bmp|gif|ico|cur|jpe?g|pjp(eg)?|jfif|tiff?|webp)$/].map(regex => RegExp.prototype.test.bind(regex));
  function getIconTemplate(icon, w, h) {
    const template = {
      w,
      h
    };
    switch (true) {
      case isSvgTag(icon):
        template.texture = lng$1.Tools.getSvgTexture("data:image/svg+xml,".concat(encodeURIComponent(icon)), w, h);
        break;
      case isSvgURI(icon):
        template.texture = lng$1.Tools.getSvgTexture(icon, w, h);
        break;
      case isImageURI(icon):
        template.src = icon;
        break;
    }
    return template;
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const styles$1 = {
    w: 113,
    //150
    h: 90,
    //40
    radius: 0,
    background: {
      color: 0xffffffff
    },
    // 0xff1f1f1f
    icon: {
      color: 0xffffffff
    },
    text: {
      fontSize: 30,
      fontFace: CONFIG.language.font,
      color: 0xff000000
    },
    padding: 50,
    stroke: {
      color: 0x00,
      weight: 2
    },
    focused: {
      background: {
        color: CONFIG.theme.hex
      },
      text: {
        color: 0xff1f1f1f
      },
      icon: {
        color: 0xff1f1f1f
      }
    }
  };
  class Button extends lng$1.Component {
    static _template() {
      return {
        w: this.styles.w,
        h: this.styles.h,
        radius: this.styles.radius,
        strokeColor: this.styles.stroke.color,
        strokeWeight: this.styles.stroke.weight,
        Content: {
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2,
          flex: {
            direction: 'row',
            alignContent: 'center',
            alignItems: 'center'
          },
          Icon: {
            type: Icon
          },
          Title: {
            y: 2
          }
        },
        Stroke: {
          zIndex: -1,
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2
        }
      };
    }
    _construct() {
      this._focused = false;
      this._whenEnabled = new Promise(resolve => this._enable = resolve, console.error);
      this._strokeWeight = 2;
      this._strokeColor = 0x00;
    }
    _init() {
      this._update();
    }
    _focus() {
      if (this._smooth === undefined) this._smooth = true;
      this._focused = true;
      this._update();
    }
    _unfocus() {
      this._focused = false;
      this._update();
    }
    _updateColor() {
      const color = this._focused ? getFirstNumber(this.focusedBackground, this.styles.focused.background.color) : getFirstNumber(this.background, this.styles.background.color);
      if (this._smooth) {
        this.smooth = {
          color
        };
      } else {
        this.color = color;
      }
    }
    _updateTitle() {
      if (this.title) {
        this._Title.text = {
          ...this.styles.text,
          fontColor: this.styles.text.color,
          fontSize: this.fontSize || this.styles.text.fontSize,
          fontFamily: this.styles.text.fontFace || this.styles.text.fontFamily || this.stage._options.defaultFontFace,
          text: this.title
        };
        const color = this._focused ? getFirstNumber(this.focusedTextColor, this.styles.focused.text.color) : getFirstNumber(this.textColor, this.styles.text.color);
        if (this._smooth) {
          this._Title.smooth = {
            color
          };
        } else {
          this._Title.color = color;
        }
      } else {
        this._Title.texture = false;
      }
    }
    _updateIcon() {
      if (this.icon) {
        const {
          color,
          size,
          spacing,
          src
        } = this.icon;
        this._Icon.patch({
          w: size,
          h: size,
          icon: src,
          flexItem: {
            marginRight: this.title ? spacing : 0
          }
        });
        const iconColor = this._focused ? getFirstNumber(this.focusedIconColor, this.styles.focused.icon.color) : getFirstNumber(color, this.styles.icon.color);
        if (this._smooth) {
          this._Icon.smooth = {
            color: iconColor
          };
        } else {
          this._Icon.color = iconColor;
        }
      } else {
        this._Icon.patch({
          w: 0,
          h: 0,
          texture: false,
          flexItem: false
        });
      }
    }
    _updateStroke() {
      if (this.stroke && !this._focused) {
        const radius = this.radius || this.styles.radius;
        this.texture = lng$1.Tools.getRoundRect(RoundRect.getWidth(this.w), RoundRect.getHeight(this.h), radius, 0x00, true, 0xffffffff);
        this._Stroke.color = this.strokeColor;
        this._Stroke.texture = lng$1.Tools.getRoundRect(RoundRect.getWidth(this.w), RoundRect.getHeight(this.h), radius, this.strokeWeight, 0xffffffff, true, this.background);
      } else {
        const radius = this.radius || this.styles.radius;
        this.texture = lng$1.Tools.getRoundRect(RoundRect.getWidth(this.w), RoundRect.getHeight(this.h), radius);
        this._Stroke.texture = false;
      }
    }
    _updateWidth() {
      if (!this.fixed) {
        const iconSize = this._icon ? this._icon.size + this._icon.spacing : 0;
        const padding = getFirstNumber(this.padding, this.styles.padding, 10);
        const w = measureTextWidth(this._Title.text || {}) + padding * 2 + iconSize;
        if (w && w !== this.w) {
          this.w = w > this.styles.w ? w : this.styles.w;
          this.fireAncestors('$itemChanged');
          this.signal('buttonWidthChanged', {
            w: this.w
          });
        }
      }
    }
    _update() {
      this._whenEnabled.then(() => {
        this._updateColor();
        this._updateTitle();
        this._updateIcon();
        this._updateStroke();
        this._updateWidth();
      });
    }
    _handleEnter() {
      if (typeof this.onEnter === 'function') {
        this.onEnter(this);
      }
    }
    get radius() {
      return this._radius;
    }
    set radius(radius) {
      if (this._radius !== radius) {
        this._radius = radius;
        this._update();
      }
    }
    get title() {
      return this._title;
    }
    set title(title) {
      if (this._title !== title) {
        this._title = title;
        this._update();
      }
    }
    get icon() {
      return this._icon;
    }
    set icon(_ref) {
      let {
        src,
        size = 20,
        spacing = 5,
        color = 0xffffffff
      } = _ref;
      if (src) {
        this._icon = {
          src,
          size,
          spacing,
          color
        };
      } else {
        this._icon = null;
      }
      this._update();
    }
    get strokeWeight() {
      return this._strokeWeight;
    }
    set strokeWeight(strokeWeight) {
      if (this._strokeWeight !== strokeWeight) {
        this._strokeWeight = strokeWeight;
        this._update();
      }
    }
    get strokeColor() {
      return this._strokeColor;
    }
    set strokeColor(strokeColor) {
      if (this._strokeColor !== strokeColor) {
        this._strokeColor = strokeColor;
        this._update();
      }
    }
    get stroke() {
      return this._stroke;
    }
    set stroke(stroke) {
      if (this._stroke !== stroke) {
        this._stroke = stroke;
        this._update();
      }
    }
    get w() {
      return this._w;
    }
    set w(w) {
      if (this._w !== w) {
        this._w = w;
        this._update();
      }
    }
    set label(label) {
      this._label = label;
    }
    get label() {
      return this._label || this._title;
    }
    get announce() {
      // TODO - Localization?
      // Do we need a locale file with
      // component translations?
      return this.label + ', Button';
    }
    get _Content() {
      return this.tag('Content');
    }
    get _Title() {
      return this.tag('Content.Title');
    }
    get _Icon() {
      return this.tag('Content.Icon');
    }
    get _Stroke() {
      return this.tag('Stroke');
    }
  }
  var Button$1 = withStyles$1(Button, styles$1);

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class FocusManager extends lng$1.Component {
    constructor(stage) {
      super(stage);
      this.patch({
        Items: {}
      });
      this._direction = this.direction || 'row';
    }
    _construct() {
      this._selectedIndex = 0;
    }
    get direction() {
      return this._direction;
    }
    set direction(direction) {
      this._direction = direction;
      let state = {
        none: 'None',
        column: 'Column',
        row: 'Row'
      }[direction];
      if (state) {
        this._setState(state);
      }
    }
    get Items() {
      return this.tag('Items');
    }
    get items() {
      return this.Items.children;
    }
    set items(items) {
      this.Items.childList.clear();
      this._selectedIndex = 0;
      this.appendItems(items);
    }
    appendItems() {
      let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.Items.childList.a(items);
      this._refocus();
    }
    get selected() {
      return this.Items.children[this.selectedIndex];
    }
    get selectedIndex() {
      return this._selectedIndex;
    }
    set selectedIndex(index) {
      const prevSelected = this.selected;
      if (index !== this._selectedIndex) {
        this._selectedIndex = index;
      }
      // Have items update (change height or width) before we render
      this._refocus();
      if (this.selected) {
        this.render(this.selected, prevSelected);
        this.signal('selectedChange', this.selected, prevSelected);
      }
    }

    // Override
    render() {}
    selectPrevious() {
      if (this.selectedIndex > 0) {
        let prevIndex = this.selectedIndex - 1;
        let previous = this.items[prevIndex];
        while (prevIndex && previous.skipFocus) {
          this._selectedIndex = prevIndex;
          this.render(previous, this.items[prevIndex + 1]);
          prevIndex -= 1;
          previous = this.items[prevIndex];
        }
        this.selectedIndex = prevIndex;
        return true;
      } else if (this.wrapSelected) {
        this.selectedIndex = this.Items.children.length - 1;
        return true;
      }
      return false;
    }
    selectNext() {
      if (this.selectedIndex < this.Items.children.length - 1) {
        let nextIndex = this.selectedIndex + 1;
        let next = this.items[nextIndex];
        while (nextIndex < this.items.length - 1 && next.skipFocus) {
          this._selectedIndex = nextIndex;
          this.render(next, this.items[nextIndex - 1]);
          nextIndex += 1;
          next = this.items[nextIndex];
        }
        this.selectedIndex = nextIndex;
        return true;
      } else if (this.wrapSelected) {
        this.selectedIndex = 0;
        return true;
      }
      return false;
    }
    _getFocused() {
      let {
        selected
      } = this;
      // Make sure we're focused on a component
      if (selected) {
        if (selected.focusRef) {
          return selected.tag(selected.focusRef);
        } else if (selected.cparent) {
          return selected;
        }
      }
      return this;
    }
    static _states() {
      return [class None extends this {}, class Row extends this {
        _handleLeft() {
          return this.selectPrevious();
        }
        _handleRight() {
          return this.selectNext();
        }
      }, class Column extends this {
        _handleUp() {
          return this.selectPrevious();
        }
        _handleDown() {
          return this.selectNext();
        }
      }];
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Column extends FocusManager {
    static _template() {
      return {
        direction: 'column'
      };
    }
    _construct() {
      super._construct();
      this._smooth = false;
      this._itemSpacing = 0;
      this._scrollIndex = 0;
      this._whenEnabled = new Promise(resolve => this._firstEnable = resolve);
      this._h = this.stage.h;
      this.debounceDelay = Number.isInteger(this.debounceDelay) ? this.debounceDelay : 30;
      this._update = debounce_1.debounce(this._updateLayout, this.debounceDelay);
      this._updateImmediate = debounce_1.debounce(this._updateLayout, this.debounceDelay, true);
    }
    get _itemTransition() {
      return this.itemTransition || {
        duration: 0.4,
        timingFunction: 'cubic-bezier(0.20, 1.00, 0.30, 1.00)'
      };
    }
    _focus() {
      this.items.forEach(item => item.parentFocus = true);
    }
    _unfocus() {
      this.items.forEach(item => item.parentFocus = false);
    }
    selectNext() {
      this._smooth = true;
      return super.selectNext();
    }
    selectPrevious() {
      this._smooth = true;
      return super.selectPrevious();
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollUp() {
      let shouldScroll = false;
      if (this._lastScrollIndex) {
        shouldScroll = this.selectedIndex < this._lastScrollIndex;
        if (this._prevLastScrollIndex !== undefined && this._prevLastScrollIndex !== this._lastScrollIndex) {
          shouldScroll = true;
        }
      } else {
        shouldScroll = this.selectedIndex >= this._scrollIndex;
      }
      return this._itemsY < 0 && shouldScroll;
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollDown() {
      const lastChild = this.Items.childList.last;
      return this.selectedIndex > this._scrollIndex &&
      // end of Items container < end of last item
      Math.abs(this._itemsY - this.h) < lastChild.y + this.Items.childList.last.h;
    }
    render(next, prev) {
      this._prevLastScrollIndex = this._lastScrollIndex;
      if (this.plinko && prev && (prev.currentItem || prev.selected)) {
        next.selectedIndex = this._getIndexOfItemNear(next, prev);
      }

      // Rows are changing height, so we'll render via updateLayout
      if (this.itemsChangeable) {
        return;
      }
      this._performRender();
    }
    _performRender() {
      this._whenEnabled.then(() => {
        const scrollOffset = (this.Items.children[this._scrollIndex] || {
          y: 0
        }).y;
        const firstChild = this.Items.childList.first;
        const lastChild = this.Items.childList.last;
        const shouldScroll = this.alwaysScroll || lastChild && (this.shouldScrollUp() || this.shouldScrollDown());
        if (shouldScroll) {
          const scrollItem = this.selectedIndex > this._lastScrollIndex ? this.Items.children[this._lastScrollIndex - this._scrollIndex] : this.selected;
          if (this._smooth) {
            this.Items.smooth = {
              y: [-(scrollItem || firstChild).transition('y').targetValue + (scrollItem === this.selected ? scrollOffset : 0), this._itemTransition]
            };
          } else {
            this.Items.patch({
              y: -scrollItem.y + (scrollItem === this.selected ? scrollOffset : 0)
            });
          }
        }
        this.onScreenEffect(this.onScreenItems);
      });
    }
    get onScreenItems() {
      return this.Items.children.filter(child => this._isOnScreen(child));
    }
    _isOnScreen(child) {
      const y = getY(child);
      const {
        h
      } = child;
      const withinLowerBounds = y + h + this._itemsY > 0;
      const withinUpperBounds = y + this._itemsY < this.h;
      return withinLowerBounds && withinUpperBounds;
    }
    _updateLayout() {
      this._whenEnabled.then(() => {
        let nextY = 0;
        let nextW = 0;
        // layout items in row
        for (let i = 0; i < this.Items.children.length; i++) {
          const child = this.Items.children[i];
          nextW = Math.max(nextW, getW(child));
          if (this._smooth) {
            child.smooth = {
              y: [nextY, this._itemTransition]
            };
          } else {
            child.patch({
              y: nextY
            });
          }
          nextY += child.h;
          if (i < this.Items.children.length - 1) {
            nextY += this.itemSpacing;
          }
          if (child.centerInParent) {
            // if the child is another focus manager, check the width of the item container
            const childWidth = child.Items && child.Items.w || child.w;
            // only center the child if it is within the bounds of this focus manager
            if (childWidth < this.w) {
              child.x = (this.w - childWidth) / 2;
            }
          }
        }
        this.Items.patch({
          w: nextW,
          h: nextY
        });
        const lastChild = this.Items.childList.last;
        const endOfLastChild = lastChild ? getY(lastChild) + lastChild.h : 0;
        const scrollOffset = (this.Items.children[this._scrollIndex] || {
          y: 0
        }).y;

        // determine when to stop scrolling down
        if (this.alwaysScroll) {
          this._lastScrollIndex = this.Items.children.length - 1;
        } else if (endOfLastChild > this.h) {
          for (let i = this.Items.children.length - 1; i >= 0; i--) {
            const child = this.Items.children[i];
            const childY = getY(child);
            if (childY + this.h - scrollOffset > endOfLastChild) {
              this._lastScrollIndex = i;
            } else {
              break;
            }
          }
        } else if (this._lastScrollIndex > this.items.length) {
          this._lastScrollIndex = this.items.length - 1;
        }
        this._performRender();
      });
    }

    // finds the index of the item with the closest middle to the previously selected item
    _getIndexOfItemNear(selected, prev) {
      // edge case
      if (selected.items.length < 2) return 0;
      let prevItem = prev.selected || prev.currentItem;
      let prevOffset = prev.transition('x').targetValue || 0;
      let [itemX] = prevItem.core.getAbsoluteCoords(-prevOffset, 0);
      let prevMiddle = itemX + prevItem.w / 2;

      // set the first item to be closest
      let closest = selected.items[0];
      let closestMiddle = closest.core.getAbsoluteCoords(0, 0)[0] + closest.w / 2;

      // start at the 2nd item
      for (let i = 1; i < selected.items.length; i++) {
        // for some reason here !!/!.. evals returning number
        if (selected.items[i].skipFocus === true) {
          continue;
        }
        const item = selected.items[i];
        const middle = item.core.getAbsoluteCoords(0, 0)[0] + item.w / 2;
        if (Math.abs(middle - prevMiddle) < Math.abs(closestMiddle - prevMiddle)) {
          // current item is the closest
          closest = item;
          closestMiddle = middle;
        } else {
          if (!closest.skipFocus) {
            // weve already found closest return its index
            return selected.items.indexOf(closest);
          } else if (!selected.items[i - 1].skipFocus) {
            // previous item is focusable return it
            return i - 1;
          } else {
            // return closest left or right of index
            const prevIndex = prev.items.indexOf(prevItem);
            return this._getIndexofClosestFocusable(prevIndex, selected, prevMiddle);
          }
        }
      }
      // if last index is focusable return
      return selected.items.length - 1;
    }
    _getIndexofClosestFocusable(selectedIndex, selected, prevMiddle) {
      // dont want to mutate the original selected.items using spread for copy
      // get first focusable item before and after the current focused item's index
      const prevIndex = [...selected.items].slice(0, selectedIndex).map(item => !!item.skipFocus).lastIndexOf(false);
      const nextIndex = [...selected.items].slice(selectedIndex + 1).map(item => !!item.skipFocus).indexOf(false) + selectedIndex + 1;
      const prevItem = selected.items[prevIndex];
      const nextItem = selected.items[nextIndex];

      // Check if the items exist if not return the other
      // covers case where at 0 idx, previous would not exist
      // and opposite for last index next would not exist
      if (prevIndex === -1 || !prevItem) {
        return nextIndex;
      }
      if (nextIndex === -1 || !nextItem) {
        return prevIndex;
      }

      // If both items compare coordinates to determine which direction of plinko
      const next = nextItem.core.getAbsoluteCoords(0, 0)[0] + nextItem.w / 2;
      const prev = prevItem.core.getAbsoluteCoords(0, 0)[0] + prevItem.w / 2;
      return Math.abs(prev - prevMiddle) < Math.abs(next - prevMiddle) ? prevIndex : nextIndex;
    }
    get itemSpacing() {
      return this._itemSpacing;
    }
    set itemSpacing(itemSpacing) {
      if (itemSpacing !== this._itemSpacing) {
        this._itemSpacing = itemSpacing;
        this._update();
      }
    }
    get scrollIndex() {
      return this._scrollIndex;
    }
    set scrollIndex(scrollIndex) {
      if (scrollIndex !== this._scrollIndex) {
        this._scrollIndex = scrollIndex;
        this._update();
      }
    }
    get _itemsY() {
      return getY(this.Items);
    }
    appendItems() {
      let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let itemWidth = this.renderWidth;
      items.forEach(item => {
        item.parentFocus = this.hasFocus();
        item = this.Items.childList.a(item);
        item.w = getW(item) || itemWidth;
      });
      this.stage.update();
      this._updateLayout();
      this._update.clear();
      this._refocus();
    }
    scrollTo(index) {
      let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._itemTransition.duration * 100;
      if (duration === 0) this.selectedIndex = index;
      for (let i = 0; i !== Math.abs(this.selectedIndex - index); i++) {
        setTimeout(() => {
          this.selectedIndex > index ? this.selectPrevious() : this.selectNext();
        }, duration * i);
      }
      this.Items.transition('y').on('finish', () => this._smooth = false);
    }
    $itemChanged() {
      this.itemsChangeable = true;
      this._updateImmediate();
    }
    $removeItem(item) {
      if (item) {
        let wasSelected = item === this.selected;
        this.Items.childList.remove(item);
        this._updateImmediate();
        if (wasSelected || this.selectedIndex >= this.items.length) {
          // eslint-disable-next-line no-self-assign
          this.selectedIndex = this._selectedIndex;
        }
        if (!this.items.length) {
          this.fireAncestors('$columnEmpty');
        }
      }
    }
    $columnChanged() {
      this._updateImmediate();
    }

    // can be overridden
    onScreenEffect() {}
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class FadeShader extends lng$1.shaders.WebGLDefaultShader {
    constructor(context) {
      super(context);
      this._margin = {
        left: 0,
        right: 0
      };
    }
    set positionLeft(v) {
      this._positionLeft = v;
    }
    set positionRight(v) {
      this._positionRight = v;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      if (this._positionLeft === 0) {
        this._positionLeft = 0.001;
      }
      if (this._positionRight === 0) {
        this._positionRight = 0.001;
      }
      const renderPrecision = this.ctx.stage.getRenderPrecision();
      this._setUniform('margin', [this._positionLeft * renderPrecision, this._positionRight * renderPrecision], this.gl.uniform1fv);
      this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
  }
  FadeShader.fragmentShaderSource = "\n  #ifdef GL_ES\n  precision lowp float;\n  #endif\n\n  #define PI 3.14159265359\n\n  varying vec2 vTextureCoord;\n  varying vec4 vColor;\n\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n  uniform float margin[2];\n\n  void main() {\n      vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n      vec2 halfRes = 0.5 * resolution.xy;\n      vec2 point = vTextureCoord.xy * resolution;\n\n\n      vec2 pos1 = vec2(point.x, point.y);\n      vec2 pos2 = pos1;\n      pos2.x += margin[0];\n\n      vec2 d = pos2 - pos1;\n      float t = dot(pos1, d) / dot(d, d);\n      t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));\n\n      vec2 pos3 = vec2(vTextureCoord.x * resolution.x, vTextureCoord.y);\n      pos3.x -= resolution.x - margin[1];\n      vec2 pos4 = vec2(vTextureCoord.x + margin[1], vTextureCoord.y);\n\n      vec2 d2 = pos4 - pos3;\n      float t2 = dot(pos3, d2) / dot(d2, d2);\n      t2 = smoothstep(0.0, 1.0, clamp(t2, 0.0, 1.0));\n\n      color = mix(vec4(0.0), color, t);\n      color = mix(color, vec4(0.0), t2);\n\n      gl_FragColor = color;\n  }\n";

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class MarqueeText extends lng$1.Component {
    static _template() {
      return {
        TextClipper: {
          boundsMargin: [],
          // overwrite boundsMargin so text won't de-render if moved offscreen
          TextBox: {
            Text: {},
            TextLoopTexture: {}
          }
        }
      };
    }
    get title() {
      return (this._Text && this._Text.text || {}).text;
    }
    set title(text) {
      this.patch({
        TextClipper: {
          w: this.finalW + 14,
          h: text.lineHeight + 10,
          TextBox: {
            Text: {
              rtt: true,
              text: {
                ...text
              }
            },
            TextLoopTexture: {}
          }
        }
      });
      this._Text.on('txLoaded', () => {
        if (this.autoStart) {
          this.startScrolling();
        }
      });
      this._Text.loadTexture();
      this._updateShader(this.finalW);
      this._scrolling && this.startScrolling();
    }
    set color(color) {
      this.tag('TextBox.Text').smooth = {
        color
      };
    }
    startScrolling() {
      let finalW = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.finalW;
      if (this._textRenderedW === 0) {
        this._Text.on('txLoaded', () => {
          this.startScrolling();
        });
      }
      if (this._textRenderedW > finalW - this._fadeW) {
        this._scrolling = true;
        this._TextLoopTexture.x = this._textRenderedW + this._offset;
        this._TextLoopTexture.texture = this._Text.getTexture();
        this._updateShader(finalW);
        this._updateAnimation();
        this._scrollAnimation.start();
      } else {
        // in case the metadata width gets larger on focus and the text goes from being clipped to not
        this._TextClipper.shader = null;
        if (this._Text.text && this._Text.text.textAlign === 'center') {
          this._centerText(finalW);
        }
        this._scrolling = false;
      }
    }
    stopScrolling() {
      let finalW = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.finalW;
      this._scrolling = false;
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this._TextLoopTexture.texture = null;
      }
      this._updateShader(finalW);
    }
    _updateShader(finalW) {
      this.stage.update();
      this._Text.loadTexture();
      this._TextClipper.patch({
        w: finalW > 0 ? finalW + this._fadeW / 2 : 0,
        shader: {
          type: FadeShader,
          positionLeft: 0,
          positionRight: this._fadeW
        },
        rtt: true
      });
    }
    _updateAnimation() {
      this._scrollAnimation && this._scrollAnimation.stopNow();
      this._scrollAnimation = this.animation({
        duration: this._textRenderedW / 50,
        delay: isNaN(this.delay) ? 1.5 : this.delay,
        repeat: isNaN(this.repeat) ? -1 : this.repeat,
        actions: [{
          t: 'TextBox',
          p: 'x',
          v: {
            sm: 0,
            0: {
              v: 0
            },
            0.5: {
              v: -(this._textRenderedW + this._offset)
            }
          }
        }, {
          t: 'TextClipper',
          p: 'shader.positionLeft',
          v: {
            sm: 0,
            0: {
              v: 0
            },
            0.1: {
              v: this._fadeW
            },
            0.4: {
              v: this._fadeW
            },
            0.5: {
              v: 0
            }
          }
        }]
      });
    }
    _centerText(finalW) {
      this._TextBox.x = ((finalW || this.finalW) - this._textRenderedW) / 2;
    }
    get _TextClipper() {
      return this.tag('TextClipper');
    }
    get _TextBox() {
      return this.tag('TextBox');
    }
    get _Text() {
      return this.tag('Text');
    }
    get _TextLoopTexture() {
      return this.tag('TextLoopTexture');
    }
    get _offset() {
      return 32;
    }
    get _fadeW() {
      return 30;
    }
    get _textRenderedW() {
      return this._Text.renderWidth;
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Row extends FocusManager {
    static _template() {
      return {
        direction: 'row'
      };
    }
    _construct() {
      super._construct();
      this._smooth = false;
      this._itemSpacing = 0;
      this._scrollIndex = 0;
      this._whenEnabled = new Promise(resolve => this._firstEnable = resolve);
      this._w = this.stage.w;
      this.debounceDelay = Number.isInteger(this.debounceDelay) ? this.debounceDelay : 1;
      this._update = debounce_1.debounce(this._updateLayout, this.debounceDelay);
    }
    get _itemTransition() {
      return this.itemTransition || {
        duration: 0.4,
        timingFunction: 'cubic-bezier(0.20, 1.00, 0.30, 1.00)'
      };
    }
    _focus() {
      this.items.forEach(item => item.parentFocus = true);
    }
    _unfocus() {
      this.items.forEach(item => item.parentFocus = false);
    }
    selectNext() {
      this._smooth = true;
      return super.selectNext();
    }
    selectPrevious() {
      this._smooth = true;
      return super.selectPrevious();
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollLeft() {
      let shouldScroll = false;
      if (this._lastScrollIndex) {
        shouldScroll = this.selectedIndex < this._lastScrollIndex;
        if (this._prevLastScrollIndex !== undefined && this._prevLastScrollIndex !== this._lastScrollIndex) {
          shouldScroll = true;
        }
      } else {
        shouldScroll = this.selectedIndex >= this._scrollIndex;
      }
      return this._itemsX < 0 && shouldScroll;
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollRight() {
      const lastChild = this.Items.childList.last;
      return this.selectedIndex > this._scrollIndex &&
      // end of Items container < end of last item
      Math.abs(this._itemsX - this.w) < lastChild.x + this.Items.childList.last.w;
    }
    get onScreenItems() {
      return this.Items.children.filter(child => this._isOnScreen(child));
    }
    _isOnScreen(child) {
      const x = getX(child);
      const {
        w
      } = child;
      const withinLowerBounds = x + w + this._itemsX > 0;
      const withinUpperBounds = x + this._itemsX < this.w;
      return withinLowerBounds && withinUpperBounds;
    }
    _isOnScreenCompletely(child) {
      let itemX = child.core.renderContext.px;
      let rowX = this.core.renderContext.px;
      return itemX >= rowX && itemX + child.w <= rowX + this.w;
    }
    _shouldScroll() {
      const lastChild = this.Items.childList.last;
      let shouldScroll = this.alwaysScroll;
      if (!shouldScroll) {
        if (this.lazyScroll) {
          shouldScroll = !this._isOnScreenCompletely(this.selected);
        } else {
          shouldScroll = lastChild && (this.shouldScrollLeft() || this.shouldScrollRight() || !this._isOnScreenCompletely(this.selected));
        }
      }
      return shouldScroll;
    }
    _getLazyScrollX(prev) {
      let itemsContainerX;
      const prevIndex = this.Items.childList.getIndex(prev);
      if (prevIndex > this.selectedIndex) {
        itemsContainerX = -this.selected.x;
      } else if (prevIndex < this.selectedIndex) {
        itemsContainerX = this.w - this.selected.x - this.selected.w;
      }
      return itemsContainerX;
    }
    _getScrollX() {
      let itemsContainerX;
      let itemIndex = this.selectedIndex - this.scrollIndex;
      itemIndex = itemIndex < 0 ? 0 : itemIndex;
      if (this.Items.children[itemIndex]) {
        itemsContainerX = this.Items.children[itemIndex].transition('x') ? -this.Items.children[itemIndex].transition('x').targetValue : -this.Items.children[itemIndex].x;
      }
      return itemsContainerX;
    }
    render(next, prev) {
      this._whenEnabled.then(() => {
        this._prevLastScrollIndex = this._lastScrollIndex;
        if (this._shouldScroll()) {
          const itemsContainerX = this.lazyScroll && prev ? this._getLazyScrollX(prev) : this._getScrollX();
          if (itemsContainerX !== undefined) {
            if (this._smooth) {
              this.Items.smooth = {
                x: [itemsContainerX, this._itemTransition]
              };
            } else {
              this.Items.x = itemsContainerX;
            }
          }
        }
        this.onScreenEffect(this.onScreenItems);
      });
    }
    _updateLayout() {
      let nextX = 0;
      let nextH = 0;
      // layout items in row
      for (let i = 0; i < this.Items.children.length; i++) {
        const child = this.Items.children[i];
        nextH = Math.max(nextH, getH(child));
        if (this._smooth) {
          child.smooth = {
            x: [nextX, this._itemTransition]
          };
        } else {
          child.patch({
            x: nextX
          });
        }
        nextX += child.w;
        if (i < this.Items.children.length - 1) {
          nextX += this.itemSpacing;
        }
        if (child.centerInParent) {
          // if the child is another focus manager, check the height of the item container
          const childHeight = child.Items && child.Items.h || child.h;
          // only center the child if it is within the bounds of this focus manager
          if (childHeight < this.h) {
            child.y = (this.h - childHeight) / 2;
          }
        }
      }
      this.Items.patch({
        h: nextH,
        w: nextX
      });
      const lastChild = this.Items.childList.last;
      const endOfLastChild = lastChild ? getX(lastChild) + lastChild.w : 0;
      const scrollOffset = (this.Items.children[this._scrollIndex] || {
        x: 0
      }).x;

      // determine when to stop scrolling right
      if (this.alwaysScroll) {
        this._lastScrollIndex = this.Items.children.length - 1;
      } else if (endOfLastChild > this.w) {
        for (let i = this.Items.children.length - 1; i >= 0; i--) {
          const child = this.Items.children[i];
          const childX = getX(child);
          if (childX + this.w - scrollOffset > endOfLastChild) {
            this._lastScrollIndex = i;
          } else {
            break;
          }
        }
      }
      this.fireAncestors('$itemChanged');
      this.render(this.selected, null);
    }
    get itemSpacing() {
      return this._itemSpacing;
    }
    set itemSpacing(itemSpacing) {
      if (itemSpacing !== this._itemSpacing) {
        this._itemSpacing = itemSpacing;
        this._update();
      }
    }
    get scrollIndex() {
      return this._scrollIndex;
    }
    set scrollIndex(scrollIndex) {
      if (scrollIndex !== this._scrollIndex) {
        this._scrollIndex = scrollIndex;
        this._update();
      }
    }
    get _itemsX() {
      return getX(this.Items);
    }
    appendItems() {
      let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let itemHeight = this.renderHeight;
      items.forEach(item => {
        item.parentFocus = this.hasFocus();
        item = this.Items.childList.a(item);
        item.h = item.h || itemHeight;
      });
      this.stage.update();
      this._updateLayout();
      this._update.clear();
      this._refocus();
    }
    $itemChanged() {
      this._update();
    }

    // can be overridden
    onScreenEffect() {}
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const KEY_DIMENSIONS = {
    h: 90,
    w: 109,
    padding: 0,
    fixed: true
  }; // actualize key values : 60 ,60  ; 90,100
  const isUpperCase = string => /^[A-Z]$/.test(string);
  class Key extends Button$1 {
    static _template() {
      return {
        ...super._template(),
        ...KEY_DIMENSIONS
      };
    }
    set config(config) {
      if (config) {
        this.sizes = config.sizes;
      }
    }
    set icon(src) {
      if (src) {
        this._Icon.patch({
          color: 0xffffffff,
          size: 32,
          spacing: 16,
          src
        });
      }
    }
    set size(size) {
      this.w = this._sizes[size] || this.h;
    }
    set char(char) {
      this.title = char;
    }
    set announce(value) {
      this._announce = value;
    }
    get announce() {
      if (this._announce) {
        return this._announce;
      }
      if (isUpperCase(this.title)) {
        return "Capital ".concat(this.title, ", button");
      }
      return this.title + ', button';
    }
    set label(label) {
      this.title = label;
    }
    get _sizes() {
      return this.styles.sizes ? {
        ...this.styles.sizes,
        ...this.sizes
      } : {
        small: 50,
        medium: 110,
        large: 273,
        xlarge: 718,
        ...this.sizes
      }; // actualize values 50,110,212,350 ; 50,110,212,750
    }

    _handleEnter() {
      if (this.toggle) {
        this.fireAncestors('$toggleKeyboard', this.toggle);
      }
      this.fireAncestors('$onSoftKey', {
        key: this.title
      });
    }
  }

  /*
  * If not stated otherwise in this file or this component's LICENSE file the
  * following copyright and licenses apply:
  *
  * Copyright 2021 RDK Management
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  * Copyright 2021 Comcast Cable Communications Management, LLC
  * Licensed under the Apache License, Version 2.0
  */
  class Keyboard extends lng$1.Component {
    _construct() {
      this._whenEnabled = new Promise(resolve => this._firstEnable = resolve);
    }
    get announce() {
      return 'Keyboard' + (this.title ? ", ".concat(this.title) : '');
    }
    get announceContext() {
      return ['PAUSE-2', 'Use arrow keys to choose characters, press center to select'];
    }
    set formats(formats) {
      if (formats === void 0) {
        formats = {};
      }
      this._formats = formats;
      this._currentFormat = this._defaultFormat;
      // Ensure formats prop is set last
      this._whenEnabled.then(() => {
        Object.entries(formats).forEach(_ref => {
          let [key, value] = _ref;
          let keyboardData = this._formatKeyboardData(value);
          this._createKeyboard(key, this._createRows(keyboardData));
        });
        this.tag(this._currentFormat).alpha = 1;
        this._refocus();
      });
    }
    _createKeyboard(key) {
      let rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      key = key.charAt(0).toUpperCase() + key.slice(1);
      if (rows.length === 1) {
        this.patch({
          [key]: {
            ...rows[0],
            alpha: 0
          }
        });
      } else {
        this.patch({
          [key]: {
            type: Column,
            alpha: 0,
            plinko: true,
            itemSpacing: this._spacing,
            items: rows
          }
        });
      }
    }
    _createRows() {
      let rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return rows.map(keys => {
        let h = this.keysConfig && this.keysConfig.h || KEY_DIMENSIONS.h;
        return {
          type: Row,
          h,
          wrapSelected: this.rowWrap === undefined ? true : this.rowWrap,
          itemSpacing: this._spacing,
          items: this._createKeys(keys)
        };
      });
    }
    _createKeys() {
      let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return keys.map(keyProps => {
        const key = {
          type: this.keyComponent || Key,
          config: this.keysConfig
        };
        if (!keyProps) {
          return {
            ...KEY_DIMENSIONS,
            skipFocus: true
          };
        } else if (typeof keyProps === 'object') {
          return {
            ...key,
            ...keyProps
          };
        }
        return {
          ...key,
          label: keyProps
        };
      });
    }
    _formatKeyboardData() {
      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (Array.isArray(data) && data.length) {
        if (!Array.isArray(data[0]) && !this.inline) {
          let keyRows = [],
            idx,
            counter;
          for (idx = 0, counter = -1; idx < data.length; idx++) {
            if (idx % this.columnCount === 0) {
              counter++;
              keyRows[counter] = [];
            }
            keyRows[counter].push(data[idx]);
          }
          return keyRows;
        } else if (this.inline) {
          return [data];
        }
        return data;
      }
    }
    $toggleKeyboard(keyboardFormat) {
      keyboardFormat = keyboardFormat.charAt(0).toUpperCase() + keyboardFormat.slice(1);
      if (keyboardFormat !== this._currentFormat) {
        this.selectKeyOn(this.tag(keyboardFormat));
        this.tag(this._currentFormat).alpha = 0;
        this.tag(keyboardFormat).alpha = 1;
        this._currentFormat = keyboardFormat;
      }
    }
    selectKeyOn(keyboard) {
      let {
        row,
        column
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelectedKey();
      let type = keyboard.constructor.name;
      if (type === 'Row') {
        keyboard.selectedIndex = column;
      } else {
        keyboard.selectedIndex = row;
        keyboard.Items.children[row].selectedIndex = column;
      }
    }
    getSelectedKey() {
      let row, column;
      let keyboard = this.tag(this._currentFormat);
      let type = keyboard.constructor.name;
      if (type === 'Row') {
        row = 0;
        column = keyboard.selectedIndex;
      } else {
        row = keyboard.selectedIndex;
        column = keyboard.Items.children[row].selectedIndex;
      }
      return {
        row,
        column
      };
    }
    _getFocused() {
      return this.tag(this._currentFormat) || this;
    }
    _focus() {
      this.fireAncestors('$keyboardFocused', true);
    }
    _unfocus() {
      this.tag(this._currentFormat).alpha = 0;
      this._currentFormat = this._defaultFormat;
      this.tag(this._currentFormat).alpha = 1;
      this._refocus();
      this.fireAncestors('$keyboardFocused', false);
    }
    set columnCount(columnCount) {
      this._columnCount = columnCount;
    }
    set rowCount(rowCount) {
      this._rowCount = rowCount;
    }
    get columnCount() {
      if (this._columnCount) return this._columnCount;
      if (this._rowCount) return this._formats[this._defaultFormat.toLowerCase()].length / this._rowCount;
      if (this.inline) return this._formats[this._defaultFormat.toLowerCase()].length;else return 11;
    }
    get _spacing() {
      return this.spacing || 8;
    }
    get _defaultFormat() {
      let defaultFormat = this.defaultFormat || Object.keys(this._formats)[0];
      return defaultFormat.charAt(0).toUpperCase() + defaultFormat.slice(1);
    }
  }
  const KEYBOARD_FORMATS = {
    fullscreen: {
      letters: [['', '', '', '', '', '', '', '', '', {
        label: '#@!',
        size: 'large',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }, {
        label: 'Space',
        size: 'large'
      }, {
        label: 'Delete',
        size: 'large'
      }, '', '', '', '', '', '', '', '', ''], ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']],
      symbols: [['', '', '', '', '', '', '', '', '', {
        label: 'ABC',
        size: 'large',
        toggle: 'letters',
        announce: 'caps on, button'
      }, {
        label: 'Space',
        size: 'large'
      }, {
        label: 'Delete',
        size: 'large'
      }, '', '', '', '', '', '', '', '', ''], ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: '!',
        announce: 'exclamation, button'
      }, '@', '#', '$', '%', {
        label: '^',
        announce: 'caret circumflex, button'
      }, '&', '*', {
        label: '(',
        announce: 'open parenthesis, button'
      }, {
        label: ')',
        announce: 'close parenthesis, button'
      }, {
        label: '`',
        announce: 'grave accent, button'
      }, '~', '_', '.', '-', '+']]
    },
    qwerty: {
      uppercase: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', '@', {
        label: '',
        size: 'medium',
        toggle: 'accents',
        announce: 'accents, button'
      }], ['Z', 'X', 'C', 'V', 'B', 'N', 'M', {
        label: '_',
        announce: 'underscore, button'
      }, {
        label: '.',
        announce: 'period, button'
      }, {
        label: '-',
        announce: 'dash, button'
      }, {
        label: 'shift',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'shift off, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      lowercase: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', '@', {
        label: '',
        size: 'medium',
        toggle: 'accents',
        announce: 'accents, button'
      }], ['z', 'x', 'c', 'v', 'b', 'n', 'm', {
        label: '_',
        announce: 'underscore, button'
      }, {
        label: '.',
        announce: 'period, button'
      }, {
        label: '-',
        announce: 'dash, button'
      }, {
        label: 'shift',
        size: 'medium',
        toggle: 'uppercase',
        announce: 'shift on, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      accents: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'abc',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'alpha mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'shift',
        size: 'medium',
        toggle: 'accentsUpper',
        announce: 'shift off, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      accentsUpper: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'abc',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'alpha mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'shift',
        size: 'medium',
        toggle: 'accents',
        announce: 'shift off, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      symbols: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], [{
        label: '!',
        announce: 'exclamation, button'
      }, '@', '#', '$', '%', {
        label: '^',
        announce: 'caret circumflex, button'
      }, '&', '*', {
        label: '(',
        announce: 'open parenthesis, button'
      }, {
        label: ')',
        announce: 'close parenthesis, button'
      }, {
        label: 'abc',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'alpha mode, button'
      }], [{
        label: '{',
        announce: 'open brace, button'
      }, {
        label: '}',
        announce: 'close brace, button'
      }, {
        label: '[',
        announce: 'open bracket, button'
      }, {
        label: ']',
        announce: 'close bracket, button'
      }, {
        label: ';',
        announce: 'semicolon, button'
      }, {
        label: '"',
        announce: 'doublequote, button'
      }, {
        label: "'",
        announce: 'singlequote, button'
      }, {
        label: '|',
        announce: 'vertical bar, button'
      }, {
        label: '\\',
        announce: 'backslash, button'
      }, {
        label: '/',
        announce: 'forwardslash, button'
      }, {
        label: '',
        size: 'medium',
        toggle: 'accents',
        announce: 'accents, button'
      }], [{
        label: '<',
        announce: 'less than, button'
      }, {
        label: '>',
        announce: 'greater than, button'
      }, {
        label: '?',
        announce: 'question mark, button'
      }, {
        label: '=',
        announce: 'equals, button'
      }, {
        label: '`',
        announce: 'grave accent, button'
      }, {
        label: '~',
        announce: 'tilde, button'
      }, {
        label: '_',
        announce: 'underscore, button'
      }, {
        label: '.',
        announce: 'period, button'
      }, {
        label: '-',
        announce: 'dash, button'
      }, {
        label: '+',
        announce: 'plus sign, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]]
    },
    numbers: {
      // numbers: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
      // dialpad: [
      //   ['1', '2', '3'],
      //   ['4', '5', '6'],
      //   ['7', '8', '9'],
      //   ['', '0', '']
      // ],
      dialpadExtended: [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9'], ['Delete', '0', 'Clear'], [{
        label: 'Done',
        size: 'large'
      }]]
    }
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const WiFiState = {
    UNINSTALLED: 0,
    DISABLED: 1,
    DISCONNECTED: 2,
    PAIRING: 3,
    CONNECTING: 4,
    CONNECTED: 5,
    FAILED: 6
  };
  class Wifi {
    constructor() {
      this._events = new Map();
      const config = {
        host: '127.0.0.1',
        port: 9998
      };
      this._thunder = thunderJS(config);
      this.callsign = 'org.rdk.Wifi';
    }

    /**
     * Function to activate the wifi plugin.
     */
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this.getCurrentState().then(state => {
            if (state === WiFiState.DISABLED) {
              this.setEnabled(true);
            }
            if (state === WiFiState.CONNECTED) {
              this.setInterface('WIFI', true).then(res => {
                if (res.success) {
                  this.setDefaultInterface('WIFI', true);
                }
              });
            }
          });
          this._thunder.on(this.callsign, 'onWIFIStateChanged', notification => {
            if (this._events.has('onWIFIStateChanged')) {
              this._events.get('onWIFIStateChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onError', notification => {
            if (this._events.has('onError')) {
              this._events.get('onError')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onAvailableSSIDs', notification => {
            if (notification.moreData === false) {
              this.stopScan();
              notification.ssids = notification.ssids.filter((item, pos) => notification.ssids.findIndex(e => e.ssid === item.ssid) === pos);
              if (this._events.has('onAvailableSSIDs')) {
                this._events.get('onAvailableSSIDs')(notification);
              }
            }
          });
          resolve(result);
        }).catch(err => {
          console.error("Wifi activation failed: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     *Register events and event listeners.
     * @param {string} eventId
     * @param {function} callback
     *
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Deactivates wifi plugin.
     */
    deactivate() {
      this._events = new Map();
    }

    /**
     * Returns connected SSIDs
     */
    getConnectedSSID() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getConnectedSSID').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("getConnectedSSID fail: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Start scanning for available wifi.
     */
    discoverSSIDs() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'startScan', {
          incremental: false,
          ssid: '',
          frequency: ''
        }).then(result => {
          //console.log('startScan success')
          resolve(result);
        }).catch(err => {
          console.error("startScan fail: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Stops scanning for networks.
     */
    stopScan() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'stopScan').then(result => {
          //console.log('stopScan success')
          resolve(result);
        }).catch(err => {
          console.error("stopScan fail: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Function to connect to an SSID
     * @param {object} device
     * @param {string} passphrase
     */
    connect(device, passphrase) {
      let params = {};
      if (device && passphrase) {
        params = {
          ssid: device.ssid,
          passphrase: passphrase,
          securityMode: device.security
        };
      }
      return new Promise((resolve, reject) => {
        this.disconnect().then(() => {
          this._thunder.call(this.callsign, 'connect', params).then(result => {
            this.setInterface('WIFI', true).then(res => {
              if (res.success) {
                this.setDefaultInterface('WIFI', true);
              }
            });
            resolve(result);
          }).catch(err => {
            console.error("Connection failed: ".concat(err));
            reject(err);
          });
        });
      });
    }

    /**
     * Function to disconnect from the SSID.
     */
    disconnect() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'disconnect').then(result => {
          console.log('WiFi disconnected: ' + JSON.stringify(result));
          this.setInterface('ETHERNET', true).then(res => {
            if (res.success) {
              this.setDefaultInterface('ETHERNET', true);
            }
          });
          resolve(result);
        }).catch(err => {
          console.error("Can't disconnect WiFi: ".concat(err));
          reject(false);
        });
      });
    }

    /**
     * Returns current state of the Wi-Fi plugin.
     */
    getCurrentState() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getCurrentState').then(result => {
          console.log("WiFi state: ".concat(result.state));
          resolve(result.state);
        }).catch(err => {
          console.error("Can't get WiFi state: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Enables/Disables the Wi-Fi.
     * @param {bool} bool
     */
    setEnabled(bool) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setEnabled', {
          enable: bool
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }

    /**
     * Function to get paired SSID.
     */
    getPaired() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getPairedSSID', {}).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("Can't get paired: ".concat(err));
          reject(err);
        });
      });
    }
    getDefaultInterface() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Network', 'getDefaultInterface', {}).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getInterfaces() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Network', 'getInterfaces').then(result => {
          resolve(result);
        }).catch(err => {
          console.log('Failed to get Interfaces');
        });
      });
    }
    setInterface(inter, bool) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Network', 'setInterfaceEnabled', {
          interface: inter,
          persist: true,
          enabled: bool
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('SetInterface Error', JSON.stringify(err));
        });
      });
    }
    setDefaultInterface(interfaceName, bool) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Network', 'setDefaultInterface', {
          interface: interfaceName,
          persist: bool
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('SetDefaultInterface Error', JSON.stringify(err));
        });
      });
    }
    saveSSID(ssid, password, securityMode) {
      console.log("SAVESSID");
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'saveSSID', {
          ssid: ssid,
          passphrase: password,
          securityMode: securityMode
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('SaveSSID Error', JSON.stringify(err));
        });
      });
    }
    clearSSID() {
      console.log("CLEARSSID");
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'clearSSID').then(result => {
          resolve(result);
        }).catch(err => {
          console.log('Error in clear ssid');
        });
      });
    }
    SaveSSIDKey(value1) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.PersistentStore', 'setValue', {
          namespace: "wifi",
          key: "SSID",
          value: value1
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error('storage SSID failed', err);
          reject();
        });
      });
    }
    //get SSID value from Persistence Store
    getSSIDKey() {
      return new Promise(resolve => {
        this._thunder.call('org.rdk.PersistentStore', 'getValue', {
          namespace: 'wifi',
          key: 'SSID'
        }).then(result => {
          resolve(result.value);
        }).catch(err => {
          resolve('');
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$5 = new Wifi();
  class JoinAnotherNetworkComponent$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    handleDone() {
      var securityCode = this.securityCodes[this.securityCodeIndex].value;
      if (!this.textCollection['EnterSSID']) {
        this._setState("EnterSSID");
      } else if (securityCode < 0 || securityCode > 14) {
        this._setState("EnterSecurity");
      } else if (securityCode !== 0 && !this.textCollection['EnterPassword']) {
        this._setState("EnterPassword");
      } else {
        if (this.textCollection['EnterSecurity'] === "0") {
          this.textCollection['EnterPassword'] = "";
          this.tag("Pwd").text.text = "";
        }
        var self = this;
        this.startConnectForAnotherNetwork({
          ssid: self.textCollection['EnterSSID'],
          security: securityCode
        }, self.textCollection['EnterPassword']);
      }
    }

    // startConnectForAnotherNetwork(device, passphrase) {
    //   wifi.connect({ ssid: device.ssid, security: device.security }, passphrase)
    //   Router.back()
    // }
    startConnectForAnotherNetwork(device, passphrase) {
      wifi$5.connect({
        ssid: device.ssid,
        security: device.security
      }, passphrase).then(() => {
        wifi$5.saveSSID(device.ssid, passphrase, device.security).then(response => {
          if (response.result === 0 && response.success === true) {
            wifi$5.SaveSSIDKey(this._item.ssid).then(persistenceResponse => {
              console.log(persistenceResponse);
            });
            // console.log(response);
            // Router.back()
          } else if (response.result !== 0) {
            wifi$5.clearSSID().then(response => {
              // console.log(response)
              // Router.back()
            });
          }
        });
      });
      Router.back();
    }
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xCC000000
        },
        Text: {
          x: 758,
          y: 70,
          text: {
            text: "Find and join a WiFi network",
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: CONFIG.theme.hex
          }
        },
        BorderTop: {
          x: 190,
          y: 130,
          w: 1488,
          h: 2,
          rect: true
        },
        Network: {
          x: 190,
          y: 176,
          text: {
            text: "Network Name: ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        NetworkBox: {
          x: 400,
          y: 160,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        NetworkText: {
          x: 420,
          y: 170,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        NetworkType: {
          x: 190,
          y: 246,
          text: {
            text: "Security: ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        TypeBox: {
          x: 400,
          y: 230,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false),
          ArrowForward: {
            h: 30,
            w: 45,
            y: 15,
            x: 1220,
            src: Utils.asset('images/settings/Arrow.png')
          },
          ArrowBackward: {
            h: 30,
            w: 45,
            x: 10,
            scaleX: -1,
            y: 15,
            src: Utils.asset('images/settings/Arrow.png')
          }
        },
        TypeText: {
          x: 470,
          y: 263,
          mountY: 0.5,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        Password: {
          x: 190,
          y: 316,
          text: {
            text: "Password:",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        PasswordBox: {
          x: 400,
          y: 300,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        Pwd: {
          x: 420,
          y: 310,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        BorderBottom: {
          x: 190,
          y: 396,
          w: 1488,
          h: 2,
          rect: true
        },
        Keyboard: {
          y: 437,
          x: 400,
          type: Keyboard,
          visible: true,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.qwerty
        }
      };
    }
    _focus() {
      this._setState('EnterSSID');
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': ''
      };
      this.tag('Pwd').text.text = "";
      this.tag("NetworkText").text.text = "";
      this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
      if (this.securityCodes[this.securityCodeIndex].value === 0) {
        this.pwdUnReachable = true;
        this.tag("PasswordBox").alpha = 0.5;
        this.tag("Password").alpha = 0.5;
      } else {
        this.pwdUnReachable = false;
        this.tag("PasswordBox").alpha = 1;
        this.tag("Password").alpha = 1;
      }
    }
    _handleBack() {
      Router.back();
    }
    static _states() {
      return [class EnterSSID extends this {
        $enter() {
          this.tag('NetworkBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("EnterSecurity");
        }
        _handleEnter() {
          this._setState('Keyboard');
        }
        $exit() {
          this.tag('NetworkBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterSecurity extends this {
        $enter() {
          this.tag("TypeBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSSID");
        }
        isPasswordUnReachable(secCode) {
          if (secCode === 0) {
            this.tag("PasswordBox").alpha = 0.5;
            this.tag("Password").alpha = 0.5;
            return true;
          } else {
            this.tag("PasswordBox").alpha = 1;
            this.tag("Password").alpha = 1;
            return false;
          }
        }
        _handleLeft() {
          this.securityCodeIndex = (15 + --this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleEnter() {
          this.handleDone();
        }
        _handleRight() {
          this.securityCodeIndex = (15 + ++this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleDown() {
          if (!this.pwdUnReachable) {
            this._setState("EnterPassword");
          }
        }
        $exit() {
          this.tag("TypeBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterPassword extends this {
        $enter() {
          if (this.pwdUnReachable) {
            this._setState("EnterSecurity");
          }
          this.tag('PasswordBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleDown() {
          this._setState("EnterSSID");
        }
        _handleEnter() {
          this._setState('Keyboard');
        }
        $exit() {
          this.tag('PasswordBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'EnterSSID') {
            this.element = 'NetworkText';
          }
          if (this.prevState === 'EnterPassword') {
            this.element = 'Pwd';
          }
          if (this.prevState === 'EnterSecurity') {
            this.element = 'TypeText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Clear') {
            this.textCollection[this.prevState] = this.textCollection[this.prevState].substring(0, this.textCollection[this.prevState].length - 1);
            this.tag(this.element).text.text = this.textCollection[this.prevState];
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.textCollection[this.prevState] += ' ';
            this.tag(this.element).text.text = this.textCollection[this.prevState];
          } else if (key === 'Delete') {
            this.textCollection[this.prevState] = '';
            this.tag(this.element).text.text = this.textCollection[this.prevState];
          } else {
            this.textCollection[this.prevState] += key;
            this.tag(this.element).text.text = this.textCollection[this.prevState];
          }
        }
        _handleBack() {
          this._setState(this.prevState);
        }
      }];
    }
    _init() {
      this.securityCodeIndex = 0;
      this.pwdUnReachable = true;
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': '0'
      };
      this.securityCodes = [{
        name: "Open/None (Unsecure)",
        value: 0
      }, {
        name: "WEP - Deprecated, not needed",
        value: 1
      }, {
        name: "WEP",
        value: 2
      }, {
        name: "WPA Personal TKIP",
        value: 3
      }, {
        name: "WPA Personal AES",
        value: 4
      }, {
        name: "WPA2 Personal TKIP",
        value: 5
      }, {
        name: "WPA2 Personal AES",
        value: 6
      }, {
        name: "WPA Enterprise TKIP",
        value: 7
      }, {
        name: "WPA Enterprise AES",
        value: 8
      }, {
        name: "WPA2 Enterprise TKIP",
        value: 9
      }, {
        name: "WPA2 Enterprise AES",
        value: 10
      }, {
        name: "Mixed Personal",
        value: 11
      }, {
        name: "Mixed Enterprise",
        value: 12
      }, {
        name: "WPA3 Personal AES",
        value: 13
      }, {
        name: "WPA3 Personal SAE",
        value: 14
      }];
      this.tag("Pwd").text.text = this.textCollection['EnterPassword'];
      this.tag("NetworkText").text.text = this.textCollection['EnterSSID'];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
    * Class for Other Network Config Screen.
    */

  class NetworkConfigurationScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        NetworkConfigurationScreenContents: {
          x: 200,
          y: 275,
          NetworkInfo: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Network Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NetworkInterface: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Network Interface: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TestInternetAccess: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Test Internet Access: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 420,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          },
          StaticMode: {
            alpha: 0,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Static Mode'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _firstEnable() {
      this._setState('NetworkInfo');
      let _currentIPSettings = {};
      let _newIPSettings = {};
      this._network = new Network();
      this._network.getDefaultInterface().then(interfaceName => {
      });
      _newIPSettings = _currentIPSettings;
      _newIPSettings.ipversion = "IPV6"; // this fails, need to verify how to set proper ip settings

      // loader animation for testing internet
      this.loadingAnimation = this.tag('TestInternetAccess.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState(this.state); //can be used on init as well

      this._network.getDefaultInterface().then(interfaceName => {
        this.$NetworkInterfaceText(interfaceName);
      });
    }
    _unfocus() {
      this.tag('TestInternetAccess.Title').text.text = Language.translate('Test Internet Access: ');
    }
    $NetworkInterfaceText(text) {
      this.tag('NetworkInterface.Title').text.text = Language.translate('Network Interface: ') + text;
    }
    _handleBack() {
      Router.navigate('settings');
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Network Configuration'));
    }
    static _states() {
      return [class NetworkInfo extends this {
        $enter() {
          this.tag('NetworkInfo')._focus();
        }
        $exit() {
          this.tag('NetworkInfo')._unfocus();
        }
        _handleDown() {
          this._setState('NetworkInterface');
        }
        _handleEnter() {
          Router.navigate('settings/network/info');
        }
      }, class NetworkInterface extends this {
        $enter() {
          this.tag('NetworkInterface')._focus();
        }
        $exit() {
          this.tag('NetworkInterface')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInfo');
        }
        _handleDown() {
          this._setState('TestInternetAccess');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network/interface');
          }
        }
      }, class TestInternetAccess extends this {
        $enter() {
          this.tag('TestInternetAccess')._focus();
        }
        $exit() {
          this.tag('TestInternetAccess')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInterface');
        }
        _handleDown() {
          // this._setState('NetworkInfo')
        }
        _handleEnter() {
          this.loadingAnimation.start();
          this.tag('TestInternetAccess.Loader').visible = true;
          this._network.isConnectedToInternet().then(result => {
            var connectionStatus = Language.translate("Internet Access: ");
            if (result) {
              connectionStatus += Language.translate("Connected");
            } else {
              connectionStatus += Language.translate("Not Connected");
            }
            setTimeout(() => {
              this.tag('TestInternetAccess.Loader').visible = false;
              this.tag('TestInternetAccess.Title').text.text = connectionStatus;
              this.loadingAnimation.stop();
            }, 2000);
          });
        }
      }, class StaticMode extends this {
        $enter() {
          this.tag('StaticMode')._focus();
        }
        $exit() {
          this.tag('StaticMode')._unfocus();
        }
        _handleUp() {
          this._setState('TestInternetAccess');
        }
        _handleDown() {
          this._setState('NetworkInfo');
        }
        _handleEnter() {}
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
    * Class for Other Settings Screen.
    */

  var appApi$a = new AppApi();
  var defaultInterface$1 = "";
  var currentInterface$1 = [];
  class NetworkInfo$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _handleBack() {
      Router.navigate('settings/network');
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Network Configuration  Network Info'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        NetworkInfoScreenContents: {
          x: 200,
          y: 275,
          Status: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          ConnectionType: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Connection Type: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          IPAddress: {
            //alpha: 0.3, // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('IP Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Gateway: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Gateway: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MACAddress: {
            //alpha: 0.3, // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('MAC Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          InternetProtocol: {
            //alpha: 0.3, // disabled
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Internet Protocol: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SSID: {
            //alpha: 0.3, // disabled
            y: 540,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('SSID: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SignalStrength: {
            //alpha: 0.3, // disabled
            y: 630,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Signal Strength: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        }
      };
    }
    getIPSetting(interfaceName) {
      appApi$a.getIPSetting(interfaceName).then(result => {
        this.tag('InternetProtocol.Value').text.text = result.ipversion;
      }).catch(err => console.log(err));
    }
    _focus() {
      //Getting the default interface
      appApi$a.getDefaultInterface().then(result => {
        defaultInterface$1 = result.interface;
        this.getIPSetting(defaultInterface$1);
        if (defaultInterface$1 === "WIFI") {
          this.tag("ConnectionType.Value").text.text = "Wireless";
          this.tag("SSID").alpha = 1;
          this.tag("SignalStrength").alpha = 1;
        } else if (defaultInterface$1 === "ETHERNET") {
          this.tag("ConnectionType.Value").text.text = "Ethernet";
          this.tag("SSID").alpha = 0;
          this.tag("SignalStrength").alpha = 0;
        } else {
          this.tag("ConnectionType.Value").text.text = "NA";
          this.tag("Status.Value").text.text = "Disconnected";
          this.tag("IPAddress.Value").text.text = "NA";
          this.tag("Gateway.Value").text.text = "NA";
          this.tag("MACAddress.Value").text.text = "NA";
        }

        //Filtering the current interface
        appApi$a.getInterfaces().then(result => {
          currentInterface$1 = result.interfaces.filter(data => data.interface === defaultInterface$1);
          //console.log(currentInterface);
          if (currentInterface$1[0].connected) {
            this.tag("Status.Value").text.text = "Connected";
            appApi$a.getConnectedSSID().then(result => {
              if (parseInt(result.signalStrength) >= -50) {
                this.tag("SignalStrength.Value").text.text = "Excellent";
              } else if (parseInt(result.signalStrength) >= -60) {
                this.tag("SignalStrength.Value").text.text = "Good";
              } else if (parseInt(result.signalStrength) >= -67) {
                this.tag("SignalStrength.Value").text.text = "Fair";
              } else {
                this.tag("SignalStrength.Value").text.text = "Poor";
              }
              this.tag("SSID.Value").text.text = "".concat(result.ssid);
            }).catch(error => console.log(error));
            appApi$a.getIPSetting(defaultInterface$1).then(result => {
              this.tag('IPAddress.Value').text.text = "".concat(result.ipaddr);
              this.tag("Gateway.Value").text.text = "".concat(result.gateway);
            }).catch(error => console.log(error));
          } else {
            this.tag('Status.Value').text.text = "Disconnected";
          }
          this.tag('MACAddress.Value').text.text = "".concat(currentInterface$1[0].macAddress);
        }).catch(error => console.log(error));
      }).catch(error => console.log(error));
    }
    _unfocus() {
      this.tag('SSID.Value').text.text = 'NA';
      this.tag('SignalStrength.Value').text.text = 'NA';
      this.tag('MACAddress.Value').text.text = 'NA';
      this.tag('Gateway.Value').text.text = 'NA';
      this.tag('IPAddress.Value').text.text = 'NA';
      this.tag('ConnectionType.Value').text.text = 'NA';
      this.tag('InternetProtocol.Value').text.text = 'NA';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$4 = new Wifi();
  class NetworkInterfaceScreen$1 extends lng$1.Component {
    _construct() {
      this.LoadingIcon = Utils.asset('images/settings/Loading.png');
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        NetworkInterfaceScreenContents: {
          x: 200,
          y: 275,
          WiFi: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('WiFi'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Ethernet: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Ethernet'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 175,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          }
        }
      };
    }
    _focus() {
      this._setState('WiFi');
    }
    _init() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS(config);
      const systemcCallsign = 'org.rdk.Network';
      const eventName = 'onDefaultInterfaceChanged';
      this._thunder.on(systemcCallsign, eventName, notification => {
        console.log('onDefaultInterfaceChanged notification from networkInterfaceScreen: ', notification);
        if (notification.newInterfaceName === "ETHERNET") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: Connected';
        } else if (notification.newInterfaceName === "" && notification.oldInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: Error, Retry!';
        } else if (notification.newInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet';
        }
      });
      this.loadingAnimation = this.tag('Ethernet.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.tag('Ethernet.Loader').src = this.LoadingIcon;
    }
    _firstActive() {
      this.tag('Ethernet.Loader').on('txError', () => {
        const url = 'http://127.0.0.1:50050/lxresui/static/images/settings/Loading.png';
        this.tag('Ethernet.Loader').src = url;
      });
    }
    hide() {
      this.tag('NetworkInterfaceScreenContents').visible = false;
    }
    show() {
      this.tag('NetworkInterfaceScreenContents').visible = true;
    }
    setEthernetInterface() {
      wifi$4.getInterfaces().then(res => {
        res.interfaces.forEach(element => {
          if (element.interface === "ETHERNET" && element.connected) {
            wifi$4.setInterface('ETHERNET', true).then(result => {
              if (result.success) {
                wifi$4.setDefaultInterface('ETHERNET', true);
                this.tag('Ethernet.Title').text.text = 'Ethernet';
                this.tag('Ethernet.Loader').visible = true;
                this.loadingAnimation.start();
              }
            });
          }
        });
      });
    }
    _handleBack() {
      Router.navigate('settings/network');
    }
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Network Configuration  Network Interface'));
    }
    static _states() {
      return [class WiFi extends this {
        $enter() {
          this.tag('WiFi')._focus();
        }
        $exit() {
          this.tag('WiFi')._unfocus();
        }
        _handleDown() {
          this._setState('Ethernet');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network/interface/wifi');
          }
        }
      }, class Ethernet extends this {
        $enter() {
          this.tag('Ethernet')._focus();
        }
        $exit() {
          this.tag('Ethernet')._unfocus();
        }
        _handleEnter() {
          wifi$4.getDefaultInterface().then(res => {
            if (res.success) {
              if (res.interface !== "ETHERNET") {
                this.setEthernetInterface();
              }
            }
          });
        }
        _handleDown() {
          // this._setState('WiFi')
        }
        _handleUp() {
          this._setState('WiFi');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class ConfirmAndCancel extends lng$1.Component {
    static _template() {
      return {
        Item: {
          w: 325,
          // previous value : ((1920 / 2) - 350) / 2
          h: 85,
          // previous value: 65
          rect: true,
          color: 0xffffffff,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 0
          }
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Left: {
          x: this.tag("Item").w / 2,
          // orginal = 10
          y: this.tag('Item').h / 2,
          mountX: 0.5,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: 0xff000000,
            fontFace: CONFIG.language.font
          }
        }
      });
    }

    /**
     * Set width of the item.
     */
    set width(width) {
      this.tag('Item').w = width;
    }

    /**
     * Set height of the item.
     */
    set height(height) {
      this.tag('Item').h = height;
    }
    _focus() {
      this.tag('Item').color = CONFIG.theme.hex;
    }
    _unfocus() {
      this.tag('Item').color = 0xffffffff;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class PasswordSwitch extends lng$1.Component {
    static _template() {
      return {
        src: Utils.asset('images/settings/ToggleOffWhite.png')
      };
    }
    _handleEnter() {
      if (this.isOn) {
        this.patch({
          src: Utils.asset("images/settings/ToggleOffWhite.png")
        });
      } else {
        this.patch({
          src: Utils.asset("images/settings/ToggleOnOrange.png")
        });
      }
      this.isOn = !this.isOn;
      this.fireAncestors('$handleEnter', this.isOn);
    }
    _init() {
      this.isOn = false;
    }
    _disable() {
      if (this.isOn) {
        this.isOn = false;
        this.patch({
          src: Utils.asset("images/settings/ToggleOffWhite.png")
        });
        this.fireAncestors('$handleEnter', this.isOn);
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class WifiPairingScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xCC000000,
        PairingScreen: {
          Title: {
            x: 960,
            y: 95,
            mountX: 0.5,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          RectangleWithColor: {
            x: 180,
            y: 164,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          PasswordLabel: {
            x: 180,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: 'Password: ',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          Pwd: {
            x: 437,
            y: 240,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              wordWrapWidth: 1000,
              wordWrap: false,
              textOverflow: 'ellipsis'
            }
          },
          PasswordBox: {
            x: 417,
            y: 208,
            zIndex: 2,
            texture: lng$1.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false)
          },
          PasswrdSwitch: {
            h: 45,
            w: 66.9,
            x: 1656,
            y: 255,
            zIndex: 2,
            type: PasswordSwitch,
            mount: 0.5
          },
          ShowPassword: {
            x: 1398,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: 'Show Password',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          List: {
            x: 417,
            y: 331,
            type: lng$1.components.ListComponent,
            w: 1080,
            h: 400,
            itemSize: 28,
            horizontal: true,
            invertDirection: false,
            roll: true,
            zIndex: 2
          },
          RectangleWithColor2: {
            x: 180,
            y: 451,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          KeyBoard: {
            y: 501,
            x: 420,
            type: Keyboard,
            visible: true,
            zIndex: 2,
            formats: KEYBOARD_FORMATS.qwerty
          }
        }
      };
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    _handleBack() {
      Router.back();
    }

    /**
     * @param {{ item: Wifi Response Object; }} args
     */
    set params(args) {
      if (args.wifiItem) {
        this.item(args.wifiItem);
      } else {
        Router.navigate('settings/network/interface/wifi');
      }
    }
    item(item) {
      this.star = "";
      this.passwd = "";
      this.tag("Pwd").text.text = "";
      this.tag('Title').text = item.ssid;
      var options = [];
      this._item = item;
      if (item.connected) {
        options = ['Disconnect', 'Cancel'];
      } else {
        options = ['Connect', 'Cancel'];
      }
      this.tag('List').items = options.map((item, index) => {
        return {
          ref: item,
          x: index === 0 ? 0 : 325 * index,
          w: 325,
          h: 85,
          type: ConfirmAndCancel,
          item: item
        };
      });
      this._setState('Pair');
    }
    _focus() {
      this.hidePasswd = true;
      this._setState('Pair');
    }
    _unfocus() {}
    _init() {
      this.star = "";
      this.passwd = "";
      this.isOn = false;
      this._wifi = new Wifi();
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        Router.back();
      } else if (option === 'Connect') {
        if (this._item) {
          console.log('trying to connect wifi');
          this._wifi.connect(this._item, '').then(() => {}).catch(err => {
            console.log('Not able to connect to wifi', JSON.stringify(err));
          });
        }
        Router.back();
      } else if (option === 'Disconnect') {
        this._wifi.disconnect().then(() => {
          Router.back();
        });
      }
    }

    // startConnect(password) {
    //   this._wifi.connect(this._item, password).then(() => {
    //     Router.back()
    //   })

    // }
    startConnect(password) {
      this._wifi.connect(this._item, password).then(() => {
        this._wifi.saveSSID(this._item.ssid, password, this._item.security).then(response => {
          if (response.result === 0 && response.success === true) {
            this._wifi.SaveSSIDKey(this._item.ssid).then(persistenceResponse => {
              console.log(persistenceResponse);
            });
            // console.log(response);
            Router.back();
          } else if (response.result !== 0) {
            this._wifi.clearSSID().then(response => {
              // console.log(response)
              Router.back();
            });
          }
        });
        Router.back();
      });
    }
    static _states() {
      return [class Password extends this {
        $enter() {
          this.shifter = false;
          this.capsLock = false;
        }
        _getFocused() {
          return this.tag("KeyBoard");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.startConnect(this.passwd);
          } else if (key === 'Clear') {
            this.passwd = this.passwd.substring(0, this.passwd.length - 1);
            this.star = this.star.substring(0, this.star.length - 1);
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.star += '\u25CF';
            this.passwd += ' ';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === 'Delete') {
            this.star = '';
            this.passwd = '';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else {
            this.star += '\u25CF';
            this.passwd += key;
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          }
        }
        _handleUp() {
          this._setState("Pair");
        }
      }, class Pair extends this {
        $enter() {}
        _getFocused() {
          return this.tag('List').element;
        }
        _handleRight() {
          this.tag('List').setNext();
        }
        _handleLeft() {
          this.tag('List').setPrevious();
        }
        _handleUp() {
          this._setState("PasswordSwitchState");
        }
        _handleDown() {
          this._setState("Password");
        }
        _handleEnter() {
          if (this.tag('List').element.ref == 'Connect' && this._item.security != 0) {
            if (this.star === '') {
              this._setState('Password');
            } else {
              this.startConnect(this.passwd);
            }
          } else {
            this.pressEnter(this.tag('List').element.ref);
          }
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1279, 88, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Pair");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.passwd);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class WiFiItem extends lng$1.Component {
    _construct() {
      this.Lock = Utils.asset('/images/settings/Lock.png');
      this.WiFi1 = Utils.asset('/images/settings/WiFi1.png');
      this.WiFi2 = Utils.asset('/images/settings/WiFi2.png');
      this.WiFi3 = Utils.asset('/images/settings/WiFi3.png');
      this.WiFi4 = Utils.asset('/images/settings/WiFi4.png');
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    _init() {
      this.tag('Item.Tick').on('txError', () => {
        const url = 'http://127.0.0.1:50050/lxresui/static/images/settings/Tick.png';
        this.tag('Item.Tick').src = url;
      });
    }
    static _template() {
      return {
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents of an item in the Bluetooth screen.
     */
    set item(item) {
      this._item = item;
      if (item.ssid) {
        this.status = item.connected ? 'Connected' : 'Not Connected';
      }
      var wifiicon = "";
      if (item.signalStrength >= -50) {
        wifiicon = this.WiFi4;
      } else if (item.signalStrength >= -60) {
        wifiicon = this.WiFi3;
      } else if (item.signalStrength >= -67) {
        wifiicon = this.WiFi2;
      } else {
        wifiicon = this.WiFi1;
      }
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          h: 32.5,
          w: 32.5,
          src: this.Tick,
          //texture: Lightning.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item.connected ? true : false
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item.ssid,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        },
        Right: {
          x: 1560,
          mountX: 1,
          y: 45,
          mountY: 0.5,
          flex: {
            direction: 'row'
          },
          Lock: {
            color: 0xffffffff,
            texture: lng$1.Tools.getSvgTexture(this.Lock, 32.5, 32.5),
            alpha: 1
          },
          Icon: {
            color: 0xffffffff,
            flexItem: {
              marginLeft: 15
            },
            texture: lng$1.Tools.getSvgTexture(wifiicon, 32.5, 32.5)
          }
        }
      });
      if (item.security == '0' || item.security == '15') {
        this.tag('Item.Right.Lock').visible = false;
      } else {
        this.tag('Item.Right.Lock').visible = true;
      }
    }
    _focus() {
      this.tag("Item").color = COLORS.hightlightColor;
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
  * Class for WiFi screen.
  */
  class WiFiScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        WifiContents: {
          x: 200,
          y: 275,
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('WiFi On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              visible: false,
              h: 45,
              w: 45,
              x: 1500,
              // x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Networks: {
            y: 180,
            flex: {
              direction: 'column'
            },
            PairedNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            AvailableNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            visible: false
          },
          JoinAnotherNetwork: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Join Another Network'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        }
      };
    }
    _active() {
      this._setState('Switch');
    }
    _focus() {
      this._setState('Switch');
      this._enable();
    }
    _firstEnable() {
      this.wifiLoading = this.tag('Switch.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: Math.PI * 2
          }
        }]
      });
      this.onError = {
        0: 'SSID_CHANGED - The SSID of the network changed',
        1: 'CONNECTION_LOST - The connection to the network was lost',
        2: 'CONNECTION_FAILED - The connection failed for an unknown reason',
        3: 'CONNECTION_INTERRUPTED - The connection was interrupted',
        4: 'INVALID_CREDENTIALS - The connection failed due to invalid credentials',
        5: 'NO_SSID - The SSID does not exist',
        6: 'UNKNOWN - Any other error.'
      };
      this._wifi = new Wifi();
      this._network = new Network();
      this.wifiStatus = false;
      this._wifiIcon = true;
      this._activateWiFi();
      this._setState('Switch');
      if (this.wiFiStatus) {
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
      }
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this._network.activate().then(result => {
        if (result) {
          this.wifiStatus = true;
          this._network.registerEvent('onIPAddressStatusChanged', notification => {
            console.log(JSON.stringify(notification));
            if (notification.status == 'LOST') {
              if (notification.interface === 'WIFI') {
                this._wifi.setInterface('ETHERNET', true).then(res => {
                  if (res.success) {
                    this._wifi.setDefaultInterface('ETHERNET', true);
                  }
                });
              }
            }
          });
          this._network.registerEvent('onDefaultInterfaceChanged', notification => {
            if (notification.newInterfaceName === 'ETHERNET') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
            if (notification.newInterfaceName == 'ETHERNET' || notification.oldInterfaceName == 'WIFI') {
              this._wifi.disconnect();
              this.wifiStatus = false;
              this.tag('Networks').visible = false;
              this.tag('JoinAnotherNetwork').visible = false;
              this.tag('Switch.Loader').visible = false;
              this.wifiLoading.stop();
              this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this._setState('Switch');
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            }
            if (notification.newInterfaceName == '' && notification.oldInterfaceName == 'WIFI') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            }
          });
          this._network.registerEvent('onConnectionStatusChanged', notification => {
            if (notification.interface === 'ETHERNET' && notification.status === 'CONNECTED') {
              this._wifi.setInterface('ETHERNET', true).then(res => {
                if (res.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
          });
        }
      });
    }

    /**
     * Function to be executed when the Wi-Fi screen is enabled.
     */
    _enable() {
      if (this.wifiStatus) {
        this._wifi.discoverSSIDs();
      }
    }

    /**
     * Function to be executed when the Wi-Fi screen is disabled.
     */
    _disable() {
      this._wifi.stopScan();
    }
    pairedDevices() {
      this._pairedNetworks.tag('List').items = [];
      this._availableNetworks.tag('List').items = [];
    }

    /**
     * Function to render list of Wi-Fi networks.
     */
    renderDeviceList(ssids) {
      this._pairedList = [];
      this._pairedNetworks.h = 0;
      this._pairedNetworks.tag('List').items = [];
      this._pairedNetworks.tag('List').h = 0;
      this._wifi.getConnectedSSID().then(result => {
        console.log("getconnectedSSID response", result);
        if (result.ssid != '') {
          this._pairedList = [result];
          this._pairedNetworks.h = this._pairedList.length * 90;
          this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
          this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
            item.connected = true;
            return {
              ref: 'Paired' + index,
              w: 1920 - 300,
              h: 90,
              type: WiFiItem,
              item: item
            };
          });
        }
        this._otherList = ssids.filter(device => {
          console.log("SSID filter", device);
          result = this._pairedList.map(a => a.ssid);
          if (result.includes(device.ssid)) {
            return false;
          } else return device;
        });
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        //this._availableNetworks.tag('List').y = this._pairedNetworks.tag('List').h
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          item.connected = false;
          return {
            ref: 'Other' + index,
            w: 1620,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
      });
    }
    _handleBack() {
      Router.navigate('settings/network/interface');
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Network Configuration  Network Interface  WiFi'));
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.tag('Switch.Button').scaleX = 1;
          }
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          if (this.wifiStatus === true) {
            this._setState('JoinAnotherNetwork');
          }
        }
        _handleEnter() {
          this.switch();
        }
      }, class PairedDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('Switch.Button').scaleX = -1;
          }
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          Router.navigate('settings/network/interface/wifi/connect', {
            wifiItem: this._pairedNetworks.tag('List').element._item
          });
        }
      }, class AvailableDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('Switch.Button').scaleX = -1;
          }
        }
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          console.log("SSID check", this._availableNetworks.tag('List').element._item);
          let item = this._availableNetworks.tag('List').element._item;
          console.log("enter connect method");
          this._wifi.getSSIDKey().then(response => {
            console.log("ssid check");
            if (response === item.ssid) {
              this._wifi.connect().then(response => {
                console.log(response);
              }).catch(err => {
                Router.navigate('settings/network/interface/wifi/connect', {
                  wifiItem: this._availableNetworks.tag('List').element._item
                });
                this._wifi.SaveSSIDKey("").then(() => {});
              });
            } else {
              Router.navigate('settings/network/interface/wifi/connect', {
                wifiItem: this._availableNetworks.tag('List').element._item
              });
            }
          });
          //Router.navigate('settings/network/interface/wifi/connect', { wifiItem: this._availableNetworks.tag('List').element._item })
        }
      }, class JoinAnotherNetwork extends this {
        $enter() {
          this.tag('JoinAnotherNetwork')._focus();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleEnter() {
          if (this.wifiStatus) {
            Router.navigate('settings/network/interface/wifi/another');
          }
        }
        _handleDown() {
          if (this.wifiStatus) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('JoinAnotherNetwork')._unfocus();
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */

    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          this._wifi.discoverSSIDs();
          this._setState('JoinAnotherNetwork');
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) {
            this._setState('AvailableDevices');
          }
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) {
            this._setState('PairedDevices');
          } else {
            this._setState('JoinAnotherNetwork');
          }
        }
      }
    }
    /**
     * Function to turn on and off Wi-Fi.
     */
    switch() {
      if (this.wifiStatus) {
        this._wifi.disconnect();
        console.log('turning off wifi');
        this._wifi.setInterface('ETHERNET', true).then(result => {
          if (result.success) {
            this._wifi.setDefaultInterface('ETHERNET', true).then(result => {
              if (result.success) {
                this._wifi.disconnect();
                this.wifiStatus = false;
                this.tag('Networks').visible = false;
                this.tag('JoinAnotherNetwork').visible = false;
                this.tag('Switch.Loader').visible = false;
                this.wifiLoading.stop();
                this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              }
            });
          }
        });
      } else {
        console.log('turning on wifi');
        this.wifiStatus = true;
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
        this.wifiLoading.play();
        this.tag('Switch.Loader').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this._wifi.discoverSSIDs();
        this.pairedDevices();
      }
    }

    /**
     * Function to activate Wi-Fi plugin.
     */
    _activateWiFi() {
      this._wifi.activate().then(() => {
        this.switch();
      });
      this._wifi.registerEvent('onWIFIStateChanged', notification => {
        console.log(JSON.stringify(notification));
        if (notification.state === 2 || notification.state === 5) {
          this._wifi.discoverSSIDs();
        }
        if (notification.state === 5) {
          this._wifi.getConnectedSSID().then(result => {
            this._wifi.SaveSSIDKey(result.ssid).then(response => {
              console.log(response);
            });
          });
        }
      });
      this._wifi.registerEvent('onError', notification => {
        if (notification.code === 4) {
          this._wifi.clearSSID();
        }
        console.log('on errro');
        this._wifi.discoverSSIDs();
        this._wifi.setInterface('ETHERNET', true).then(res => {
          if (res.success) {
            this._wifi.setDefaultInterface('ETHERNET', true);
          }
        });
        if (this.widgets) {
          this.widgets.fail.notify({
            title: 'WiFi Error',
            msg: this.onError[notification.code]
          });
          Router.focusWidget('Fail');
        }
      });
      this._wifi.registerEvent('onAvailableSSIDs', notification => {
        console.log("Notification[onAvailableSSIDs]:", notification.ssids);
        this.renderDeviceList(notification.ssids);
        if (!notification.moreData) {
          setTimeout(() => {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
          }, 1000);
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const networkRoutes = [{
    path: 'settings/network',
    component: NetworkConfigurationScreen$1,
    widgets: ['Menu', 'Volume']
  }, {
    path: 'settings/network/info',
    component: NetworkInfo$1,
    widgets: ['Menu', 'Volume']
  }, {
    path: 'settings/network/interface',
    component: NetworkInterfaceScreen$1,
    widgets: ['Menu', 'Volume']
  }, {
    path: 'settings/network/interface/wifi',
    component: WiFiScreen$1,
    widgets: ['Menu', 'Fail', 'Volume']
  }, {
    path: 'settings/network/interface/wifi/connect',
    component: WifiPairingScreen$1,
    widgets: ['Volume']
  }, {
    path: 'settings/network/interface/wifi/another',
    component: JoinAnotherNetworkComponent$1,
    widgets: ['Volume']
  }, {
    path: 'settings/bluetooth',
    component: BluetoothScreen$2,
    widgets: ['Menu', 'Fail', 'Volume']
  }, {
    path: 'settings/bluetooth/pairing',
    component: BluetoothPairingScreen$1,
    widgets: ['Volume']
  }];
  var route$1 = {
    network: networkRoutes
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Variable to store the timer
   */
  var timeout;

  /**
   * Class to render the UI controls for the video player.
   */
  class LightningPlayerControls extends lng$1.Component {
    /**
     * Function to create components for the player controls.
     */
    static _template() {
      return {
        TimeBar: {
          x: 90,
          y: 93.5,
          texture: lng$1.Tools.getRoundRect(1740, 20, 10, 0, 0, true, 0xffffffff)
        },
        ProgressWrapper: {
          x: 90,
          y: 93.5,
          w: 0,
          h: 35,
          clipping: true,
          ProgressBar: {
            texture: lng$1.Tools.getRoundRect(1740, 20, 10, 0, 0, true, CONFIG.theme.hex)
            // x: 90,
            // y: 93.5,
          }
        },

        Duration: {
          x: 1690,
          y: 125,
          text: {
            text: "00:00:00",
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: 0xffFFFFFF
          }
        },
        CurrentTime: {
          x: 140,
          // 140 = 90 + 50 | 50 is approzimately 1/2 of length(in px) of the text "00:00:00" and 90 is padding from left
          y: 60,
          mountX: 0.5,
          text: {
            text: "00:00:00",
            fontFace: CONFIG.language.font,
            fontSize: 25,
            textColor: 0xffFFFFFF
          }
        },
        Buttons: {
          x: 820,
          y: 125,
          children: [{
            src: Utils.asset('images/Media Player/Icon_Back_White_16k.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/Media Player/Icon_Pause_White_16k.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/Media Player/Icon_Next_White_16k.png'),
            x: 17,
            y: 17
          }].map((item, idx) => ({
            x: idx * 75,
            // texture: Lightning.Tools.getRoundRect(80, 80, 40, 0, 0, true, 0xff8e8e8e),
            ControlIcon: {
              x: item.x,
              y: item.y,
              texture: lng$1.Tools.getSvgTexture(item.src, 50, 50)
            }
          }))
        }
      };
    }
    _init() {
      /**
       * Variable to store the duration of the video content.
       */
      this.videoDuration = 0;
      this.tag('Buttons').children[0].patch({
        alpha: 1
      });
      this.tag('Buttons').children[2].patch({
        alpha: 1
      });
      this.toggle = false;
    }

    /**
     * Function to set focus to player controls when the player controls are shown.
     */
    _focus() {
      this._index = 1;
      this._setState('PlayPause');
    }

    /**
     * Function to handle the player controls when they are hidden.
     */
    _unfocus() {
      this._setState('Hidden');
      clearTimeout(timeout);
    }
    /**
     * Function to set the duration of the video.
     * @param {String} duration video duration to be set.
     */
    set duration(duration) {
      console.log("duration was set = ".concat(duration));
      this.videoDuration = duration;
      this.tag('Duration').text.text = this.SecondsTohhmmss(duration);
    }

    /**
     * Function to set the current video time.
     * @param {String} currentTime current time to be set.
     */
    set currentTime(currentTime) {
      let value = 1740 * currentTime / this.videoDuration;
      this.tag('ProgressWrapper').patch({
        w: value
      });
      this.tag('CurrentTime').text.text = this.SecondsTohhmmss(currentTime);
      if (value >= 50 && value <= 1690) {
        // 1740 - 50 = 1690
        this.tag('CurrentTime').x = 90 + value; //90 is padding from left
      } else if (currentTime === 0) {
        this.tag('CurrentTime').x = 140; //initial position 140 = 90 + 50
      }
    }

    /**
     * Function to convert time in seconds to hh:mm:ss format.
     * @param {String} totalSeconds time in seconds.
     */
    SecondsTohhmmss(totalSeconds) {
      this.hours = Math.floor(totalSeconds / 3600);
      this.minutes = Math.floor((totalSeconds - this.hours * 3600) / 60);
      this.seconds = totalSeconds - this.hours * 3600 - this.minutes * 60;
      this.seconds = Math.round(totalSeconds) - this.hours * 3600 - this.minutes * 60;
      this.result = this.hours < 10 ? '0' + this.hours : this.hours;
      this.result += ':' + (this.minutes < 10 ? '0' + this.minutes : this.minutes);
      this.result += ':' + (this.seconds < 10 ? '0' + this.seconds : this.seconds);
      return this.result;
    }

    /**
     * Function to hide player controls.
     */
    hideLightningPlayerControls() {
      this.signal('hide');
    }
    hideNextPrevious() {
      this.isChannel = true;
      this.tag('Buttons').children[0].visible = false;
      this.tag('Buttons').children[2].visible = false;
    }
    showNextPrevious() {
      this.isChannel = false;
      this.tag('Buttons').children[0].visible = true;
      this.tag('Buttons').children[2].visible = true;
    }
    /**
     * Timer function to track the inactivity of the player controls.
     */
    timer() {
      clearTimeout(timeout);
      timeout = setTimeout(this.hideLightningPlayerControls.bind(this), 5000);
    }

    /**
     * Function that defines the different states of the player controls.
     */
    static _states() {
      return [class PlayPause extends this {
        $enter() {
          this.focus = this.toggle ? Utils.asset('images/Media Player/Icon_Play_Orange_16k.png') : Utils.asset('images/Media Player/Icon_Pause_Orange_16k.png');
          this.timer();
          this.tag('Buttons').children[1].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(this.focus, 50, 50)
          });
        }
        $exit() {
          this.unfocus = this.toggle ? Utils.asset('images/Media Player/Icon_Play_White_16k.png') : Utils.asset('images/Media Player/Icon_Pause_White_16k.png');
          this.tag('Buttons').children[1].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(this.unfocus, 50, 50)
          });
        }
        _handleEnter() {
          if (this.toggle) {
            //this.fireAncestors('$play');
            this.signal('play');
          } else {
            //this.fireAncestors('$pause');
            this.signal('pause');
          }
          this.toggle = !this.toggle;
          this.focus = this.toggle ? Utils.asset('images/Media Player/Icon_Play_Orange_16k.png') : Utils.asset('images/Media Player/Icon_Pause_Orange_16k.png');
          this.timer();
          this.tag('Buttons').children[1].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(this.focus, 50, 50)
          });
        }
        _handleRight() {
          if (!this.isChannel) {
            this._setState('Forward');
          }
        }
        _handleLeft() {
          if (!this.isChannel) {
            this._setState('Rewind');
          }
        }
        _getFocused() {
          this.timer();
        }
      }, class Forward extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[2].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Next_Orange_16k.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[2].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Next_White_16k.png'), 50, 50)
          });
        }
        _handleRight() {
          // this._setState('Extras')
        }
        _handleLeft() {
          this._setState('PlayPause');
        }
        _handleEnter() {
          this.toggle = false;
          this.signal('nextTrack');
        }
        _getFocused() {
          this.timer();
        }
      }, class Rewind extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[0].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Back_Orange_16k.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[0].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Back_White_16k.png'), 50, 50)
          });
        }
        _handleLeft() {
          // this._setState('AudioOptions')
        }
        _handleRight() {
          this._setState('PlayPause');
        }
        _handleEnter() {
          this.toggle = false;
          this.signal('prevTrack');
        }
        _getFocused() {
          this.timer();
        }
      }, class Hidden extends this {
        _getFocused() {}
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ChannelItem$1 extends lng$1.Component {
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 232,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 232,
          h: 81
        },
        BottomLine: {
          y: 81,
          mountY: 0.5,
          w: 232,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    set item(item) {
      //  this.shows = item.shows;
      this._item = item;
      this.tag('Item').patch({
        Title: {
          x: 10,
          y: 45,
          mountY: 0.5,
          text: {
            text: this.index + 1 + "\t\t\t\t" + item.shortname,
            fontFace: CONFIG.language.font,
            fontSize: 21,
            textColor: 0xffFFFFFF,
            wordWrap: false,
            wordWrapWidth: 232 - 20,
            maxLines: 1,
            textOverflow: '...'
          } // update the text
        }
      });
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.tag('TopLine').h = 5;
      this.tag('BottomLine').h = 5;
      this.tag('Item.Title').text.fontStyle = "bold";
      this.patch({
        zIndex: 2
      });
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
      this.tag('Item.Title').text.fontStyle = "normal";
      this.patch({
        zIndex: 1
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ChannelOverlay extends lng$1.Component {
    /**
     * Function to create components for the player controls.
     */
    static _template() {
      return {
        Wrapper: {
          x: -235,
          y: 90,
          clipping: true,
          w: 232,
          h: 900,
          Channels: {
            y: 5,
            w: 232,
            h: 891,
            type: lng$1.components.ListComponent,
            // clipping:true,
            itemSize: 81,
            roll: true,
            horizontal: false,
            invertDirection: true,
            itemScrollOffset: -10
          }
        }
      };
    }
    _init() {
      this.activeChannelIdx = 0; //this must be initialised in init
    }

    _firstEnable() {
      this.dtvApi = new DTVApi();
      this.options = [];
      this.overlayTimeout = null;
      this.timeoutDuration = 10000;
      this.dtvApi.serviceList().then(channels => {
        const [amazon, netflix, youtube, ...others] = channels; //to remove apps from the channel overlay
        this.options = others;
        this.tag('Channels').items = this.options.map((item, index) => {
          return {
            type: ChannelItem$1,
            index: index,
            item: item,
            ref: "Channel" + index
          };
        });
      }).catch(err => {
        console.log("Failed to fetch channels: ", JSON.stringify(err));
      });
      this._overlayAnimation = this.tag("Wrapper").animation({
        delay: 0.3,
        duration: 0.3,
        stopMethod: "reverse",
        //so that .stop will play the transition towards left
        actions: [{
          p: "x",
          v: {
            0: -235,
            1: 0
          }
        }]
      });
    }
    _focus() {
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
      this.$focusChannel(this.activeChannelIdx);
      this._overlayAnimation.start();
    }
    _unfocus() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
      this._overlayAnimation.stop();
    }
    resetTimeout() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
    }
    $focusChannel(index) {
      this.activeChannelIdx = index;
      this.tag('Channels').setIndex(this.activeChannelIdx);
    }
    _getFocused() {
      return this.tag('Channels').element; // add logic to focus on current channel
    }

    _handleDown() {
      this.resetTimeout();
      this.tag('Channels').setNext();
    }
    _handleUp() {
      this.resetTimeout();
      this.tag('Channels').setPrevious();
    }
    _handleBack() {
      Router.focusPage();
    }
    _handleLeft() {
      this._handleBack();
    }
    _handleRight() {
      this._handleBack();
    }
    _handleEnter() {
      this.resetTimeout();
      let focusedChannelIdx = this.tag("Channels").index;
      if (focusedChannelIdx !== this.activeChannelIdx) {
        this.dtvApi.exitChannel().then(res => {
          console.log("Current channel exit successful, launching new channel: ", JSON.stringify(res));
          this.dtvApi.launchChannel(this.options[focusedChannelIdx].dvburi).then(res => {
            console.log("Change Channel successfull: ", JSON.stringify(res));
            this.activeChannelIdx = focusedChannelIdx;
          }).catch(err => {
            console.log("Failed to launch new channel", JSON.stringify(err));
          });
        }).catch(err => {
          console.log("Failed to exit current playing channel: ", JSON.stringify(err));
        });
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render AAMP video player.
   */
  class AAMPVideoPlayer extends lng$1.Component {
    /**
     * Function to render player controls.
     */

    set params(args) {
      this.currentIndex = args.currentIndex;
      this.data = args.list;
      if (args.isUSB) {
        this.isUSB = args.isUSB;
      } else if (args.isChannel) {
        this.isChannel = args.isChannel;
        this.channelName = args.channelName;
        this.showName = args.showName;
        this.showDescription = args.description;
        this.channelIndex = args.channelIndex;
      }
      let url = args.url ? args.url : 'https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8';
      if (args.isAudio) {
        this.tag('Image').alpha = 1;
      }
      try {
        this.load({
          title: 'Parkour event',
          url: url,
          drmConfig: null
        });
        this.setVideoRect(0, 0, 1920, 1080);
      } catch (error) {
        console.error('Playback Failed ' + error);
      }
    }
    static _template() {
      return {
        Image: {
          alpha: 0,
          x: 960,
          y: 560,
          mount: 0.5,
          texture: {
            type: lng$1.textures.ImageTexture,
            src: 'static/images/Media Player/Audio_Background_16k.jpg',
            resizeMode: {
              type: 'contain',
              w: 1920,
              h: 1080
            }
          }
        },
        InfoOverlay: {
          x: 90,
          y: 820,
          alpha: 0,
          zIndex: 3,
          ShowName: {
            text: {
              text: "Show Name",
              fontFace: CONFIG.language.font,
              fontSize: 48,
              fontStyle: 'bold',
              textColor: 0xffFFFFFF,
              wordWrap: true,
              wordWrapWidth: 1350,
              maxLines: 1
            }
          },
          ChannelName: {
            y: 50,
            visible: false,
            text: {
              text: "Channel Name",
              fontFace: CONFIG.language.font,
              fontSize: 35,
              textColor: 0xffFFFFFF,
              wordWrap: true,
              wordWrapWidth: 1350,
              maxLines: 1
            }
          }
        },
        PlayerControlsWrapper: {
          alpha: 0,
          h: 330,
          w: 1920,
          y: 750,
          rect: true,
          colorBottom: 0xFF000000,
          colorTop: 0x00000000,
          PlayerControls: {
            y: 70,
            type: LightningPlayerControls,
            signals: {
              pause: 'pause',
              play: 'play',
              hide: 'hidePlayerControls',
              fastfwd: 'fastfwd',
              fastrwd: 'fastrwd',
              nextTrack: 'nextTrack',
              prevTrack: 'prevTrack'
            }
          }
        },
        ChannelWrapper: {
          h: 1080,
          w: 350,
          x: -360,
          rect: true,
          colorLeft: 0xFF000000,
          colorRight: 0x00000000,
          ChannelOverlay: {
            type: ChannelOverlay,
            x: 50,
            y: 92
          }
        }
      };
    }
    _init() {
      this.x = 0;
      this.y = 0;
      this.w = 0;
      this.h = 0;
      this.videoEl = document.createElement('video');
      this.videoEl.setAttribute('id', 'video-player');
      this.videoEl.style.position = 'absolute';
      this.videoEl.style.zIndex = '1';
      this.videoEl.setAttribute('width', '100%');
      this.videoEl.setAttribute('height', '100%');
      this.videoEl.setAttribute('type', 'video/ave');
      document.body.appendChild(this.videoEl);
      this.playbackSpeeds = [-16, -8, -4, -2, 1, 2, 4, 8, 16];
      this.playerStatesEnum = {
        idle: 0,
        initializing: 1,
        playing: 8,
        paused: 6,
        seeking: 7
      };
      this.player = null;
      this.playbackRateIndex = this.playbackSpeeds.indexOf(1);
      this.defaultInitConfig = {
        initialBitrate: 2500000,
        offset: 0,
        networkTimeout: 10,
        preferredAudioLanguage: 'en',
        liveOffset: 15,
        drmConfig: null
      };
    }

    /**
     * Function to set video coordinates.
     * @param {int} x x position of video
     * @param {int} y y position of video
     * @param {int} w width of video
     * @param {int} h height of video
     */
    setVideoRect(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }

    /**
     * Event handler to store the current playback state.
     * @param  event playback state of the video.
     */
    _playbackStateChanged(event) {
      switch (event.state) {
        case this.player.playerStatesEnum.idle:
          this.playerState = this.player.playerStatesEnum.idle;
          break;
        case this.player.playerStatesEnum.initializing:
          this.playerState = this.player.playerStatesEnum.initializing;
          break;
        case this.player.playerStatesEnum.playing:
          this.playerState = this.player.playerStatesEnum.playing;
          break;
        case this.player.playerStatesEnum.paused:
          this.playerState = this.player.playerStatesEnum.paused;
          break;
        case this.player.playerStatesEnum.seeking:
          this.playerState = this.player.playerStatesEnum.seeking;
          break;
      }
    }

    /**
     * Event handler to handle the event of completion of a video playback.
     */
    _mediaEndReached() {
      this.load(this.videoInfo);
      this.setVideoRect(this.x, this.y, this.w, this.h);
    }

    /**
     * Event handler to handle the event of changing the playback speed.
     */
    _mediaSpeedChanged() {}

    /**
     * Event handler to handle the event of bit rate change.
     */
    _bitrateChanged() {}

    /**
     * Function to handle the event of playback failure.
     */
    _mediaPlaybackFailed() {
      this.load(this.videoInfo);
    }

    /**
     * Function to handle the event of playback progress.
     * @param event playback event.
     */
    _mediaProgressUpdate(event) {
      this.position = event.positionMiliseconds / 1000;
      this.tag('PlayerControls').currentTime = this.position;
    }

    /**
     * Function to handle the event of starting the playback.
     */
    _mediaPlaybackStarted() {
      this.tag('PlayerControls').reset();
      this.tag('PlayerControlsWrapper').setSmooth('alpha', 1);
      this.tag('PlayerControlsWrapper').setSmooth('y', 750, {
        duration: 1
      });
      if (this.isUSB) {
        this.tag("InfoOverlay").setSmooth('alpha', 1);
      }
      this.timeout = setTimeout(this.hidePlayerControls.bind(this), 5000);
    }

    /**
     * Function to handle the event of change in the duration of the playback content.
     */
    _mediaDurationChanged() {}

    /**
     * Function to create the video player instance for video playback and its initial settings.
     */
    createPlayer() {
      if (this.player !== null) {
        this.destroy();
        this.player = null;
      }
      try {
        this.player = new AAMPMediaPlayer();
        this.player.addEventListener('playbackStateChanged', this._playbackStateChanged);
        this.player.addEventListener('playbackCompleted', this._mediaEndReached.bind(this));
        this.player.addEventListener('playbackSpeedChanged', this._mediaSpeedChanged);
        this.player.addEventListener('bitrateChanged', this._bitrateChanged);
        this.player.addEventListener('playbackFailed', this._mediaPlaybackFailed.bind(this));
        this.player.addEventListener('playbackProgressUpdate', this._mediaProgressUpdate.bind(this));
        this.player.addEventListener('playbackStarted', this._mediaPlaybackStarted.bind(this));
        this.player.addEventListener('durationChanged', this._mediaDurationChanged);
        this.playerState = this.playerStatesEnum.idle;
      } catch (error) {
        console.error('AAMPMediaPlayer is not defined');
      }
    }

    /**
     * Loads the player with video URL.
     * @param videoInfo the url and the info regarding the video like title.
     */
    load(videoInfo) {
      this.createPlayer();
      this.videoInfo = videoInfo;
      this.configObj = this.defaultInitConfig;
      this.configObj.drmConfig = this.videoInfo.drmConfig;
      this.player.initConfig(this.configObj);
      this.player.load(videoInfo.url);
      this.tag('PlayerControls').title = videoInfo.title;
      this.tag('PlayerControls').duration = this.player.getDurationSec();
      console.log('Dureation of video', this.player.getDurationSec());
      this.tag('PlayerControls').currentTime = 0;
      this.play();
    }

    /**
     * Starts playback when enough data is buffered at play head.
     */
    play() {
      this.player.play();
      this.playbackRateIndex = this.playbackSpeeds.indexOf(1);
    }

    /**
     * Pauses playback.
     */
    pause() {
      this.player.pause();
    }

    /**
     * Stop playback and free resources.
     */
    stop() {
      this.player.stop();
      this.hidePlayerControls();
    }
    $changeChannel(url, showName, channelName) {
      this.stop();
      this.destroy();
      try {
        this.load({
          title: showName,
          url: url,
          drmConfig: null
        });
        this.tag('ShowName').text.text = showName;
        this.tag('ChannelName').text.text = channelName;
        this.setVideoRect(0, 0, 1920, 1080);
      } catch (error) {
        console.error('Playback Failed ' + error);
      }
    }
    nextTrack() {
      if (this.data[this.currentIndex + 1]) {
        this.currentIndex += 1;
        this.stop();
        this.destroy();
        try {
          this.load({
            title: 'Parkour event',
            url: this.data[this.currentIndex].data.uri,
            drmConfig: null
          });
          this.updateInfo();
          this.setVideoRect(0, 0, 1920, 1080);
        } catch (error) {
          console.error('Playback Failed ' + error);
        }
      }
    }
    prevTrack() {
      if (this.data[this.currentIndex - 1]) {
        this.currentIndex -= 1;
        this.stop();
        this.destroy();
        try {
          this.load({
            title: 'Parkour event',
            url: this.data[this.currentIndex].data.uri,
            drmConfig: null
          });
          this.updateInfo();
          this.setVideoRect(0, 0, 1920, 1080);
        } catch (error) {
          console.error('Playback Failed ' + error);
        }
      }
    }

    /**
     * Function to perform fast forward of the video content.
     */
    fastfwd() {
      if (this.playbackRateIndex < this.playbackSpeeds.length - 1) {
        this.playbackRateIndex++;
      }
      this.rate = this.playbackSpeeds[this.playbackRateIndex];
      this.player.setPlaybackRate(this.rate);
    }

    /**
     * Function to perform fast rewind of the video content.
     */
    fastrwd() {
      if (this.playbackRateIndex > 0) {
        this.playbackRateIndex--;
      }
      this.rate = this.playbackSpeeds[this.playbackRateIndex];
      this.player.setPlaybackRate(this.rate);
    }

    /**
     * Function that returns player instance.
     * @returns player instance.
     */
    getPlayer() {
      return this.player;
    }

    /**
     * Function to release the video player instance when not in use.
     */
    destroy() {
      if (this.player.getCurrentState() !== this.playerStatesEnum.idle) {
        this.player.stop();
      }
      this.player.removeEventListener('playbackStateChanged', this._playbackStateChanged);
      this.player.removeEventListener('playbackCompleted', this._mediaEndReached);
      this.player.removeEventListener('playbackSpeedChanged', this._mediaSpeedChanged);
      this.player.removeEventListener('bitrateChanged', this._bitrateChanged);
      this.player.removeEventListener('playbackFailed', this._mediaPlaybackFailed.bind(this));
      this.player.removeEventListener('playbackProgressUpdate', this._mediaProgressUpdate.bind(this));
      this.player.removeEventListener('playbackStarted', this._mediaPlaybackStarted.bind(this));
      this.player.removeEventListener('durationChanged', this._mediaDurationChanged);
      this.player.release();
      this.player = null;
      this.hidePlayerControls();
    }

    /**
     * Function to hide the player controls.
     */
    hidePlayerControls() {
      this.tag('PlayerControlsWrapper').setSmooth('y', 1080, {
        duration: 0.7
      });
      this.tag('PlayerControlsWrapper').setSmooth('alpha', 0, {
        duration: 0.7
      });
      this._setState('HideControls');
      this.hideInfo();
    }

    /**
     * Function to show the player controls.
     */
    showPlayerControls() {
      // this.tag('PlayerControls').reset()
      this.tag('PlayerControlsWrapper').setSmooth('alpha', 1);
      this.tag('PlayerControlsWrapper').setSmooth('y', 750, {
        duration: 0.7
      });
      this._setState('ShowControls');
      this.timeout = setTimeout(this.hidePlayerControls.bind(this), 5000);
    }
    showInfo() {
      if (this.isUSB || this.isChannel) {
        this.tag("InfoOverlay").setSmooth('alpha', 1, {
          duration: 0.3,
          delay: 0.7
        });
      }
    }
    hideInfo() {
      if (this.isUSB || this.isChannel) {
        this.tag("InfoOverlay").setSmooth('alpha', 0, {
          duration: 0.3
        });
      }
    }
    updateInfo() {
      if (this.isUSB) {
        this.tag('ShowName').text.text = this.data[this.currentIndex].data.displayName;
      } else if (this.isChannel) {
        this.tag('ShowName').text.text = this.showName;
        this.tag('ChannelName').text.text = this.channelName;
      }
    }
    /**
     * Function to display player controls on down key press.
     */

    /**
     *Function to hide player control on up key press.
     */

    _handleBack() {
      Router.back();
    }
    _inactive() {
      this.tag('Image').alpha = 0;
      this.tag('InfoOverlay').alpha = 0;
      this.isUSB = false;
      this.isChannel = false;
      this.stop();
      this.destroy();
    }
    _focus() {
      this._setState('HideControls');
      this.updateInfo();
      if (this.isChannel) {
        this.tag('ChannelOverlay').$focusChannel(this.channelIndex);
        this.tag('InfoOverlay').y = 790;
        this.tag('ChannelName').visible = true;
        this.tag('PlayerControls').hideNextPrevious();
      } else {
        this.tag('InfoOverlay').y = 820;
        this.tag('ChannelName').visible = false;
        this.tag('PlayerControls').showNextPrevious();
      }
    }
    /**
     * Function to define the different states of the video player.
     */
    static _states() {
      return [class ShowControls extends this {
        _getFocused() {
          return this.tag('PlayerControls');
        }
        _handleDown() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _handleUp() {
          if (this.isChannel) {
            this.hidePlayerControls();
            this._setState('ChannelOverlay');
          }
        }
      }, class HideControls extends this {
        // _handleBack(){
        //   console.log('go back from hidecontrol')
        // }
        _handleUp() {
          // this.tag('PlayerControlsWrapper').setSmooth('alpha', 1, { duration: 1 })
          // this.tag('PlayerControlsWrapper').setSmooth('y', 820, { duration: 1 })
          this.showPlayerControls();
          this._setState('ShowControls');
          this.showInfo();
          clearTimeout(this.timeout);
        }
        _handleLeft() {
          if (this.isChannel) {
            this._setState('ChannelOverlay');
          }
        }
      }, class ChannelOverlay extends this {
        $enter() {
          this.tag('ChannelWrapper').setSmooth('x', 0, {
            duration: 1
          });
        }
        $exit() {
          this.tag('ChannelWrapper').setSmooth('x', -360, {
            duration: 1
          });
        }
        _handleLeft() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _handleRight() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _getFocused() {
          return this.tag('ChannelOverlay');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Other Settings Screen.
   */

  class OtherSettingsScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        OtherSettingsScreenContents: {
          x: 200,
          y: 275,
          SleepTimer: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Sleep Timer: Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          RemoteControl: {
            alpha: 0.3,
            // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          ScreenSaver: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Screen-Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          EnergySaver: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Energy Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Language: {
            //alpha: 0.3, // disabled
            y: 450 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Language'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Privacy: {
            //alpha: 0.3, // disabled
            y: 540 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Privacy'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AdvancedSettings: {
            y: 630 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Advanced Settings'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('SleepTimer');
    }
    $updateStandbyMode(standbyMode) {
      this.tag("EnergySaver.Title").text.text = Language.translate("Energy Saver: ") + standbyMode;
    }
    $sleepTimerText(text) {
      this.tag('SleepTimer.Title').text.text = Language.translate('Sleep Timer: ') + text;
    }
    _focus() {
      this._setState(this.state);
      if (Storage.get('TimeoutInterval')) {
        this.tag('SleepTimer.Title').text.text = Language.translate('Sleep Timer: ') + Storage.get('TimeoutInterval');
      } else {
        this.tag('SleepTimer.Title').text.text = Language.translate('Sleep Timer: ') + 'Off';
      }
      this._appApi.getPreferredStandbyMode().then(result => {
        var currentStandbyMode = "";
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          currentStandbyMode = "Light Sleep";
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          currentStandbyMode = "Deep Sleep";
        }
        this.tag("EnergySaver.Title").text.text = Language.translate("Energy Saver: ") + currentStandbyMode;
      });
    }
    _handleBack() {
      Router.navigate('settings');
    }
    static _states() {
      return [class SleepTimer extends this {
        $enter() {
          this.tag('SleepTimer')._focus();
        }
        $exit() {
          this.tag('SleepTimer')._unfocus();
        }
        _handleUp() {
          // this._setState('AdvancedSettings')
        }
        _handleDown() {
          // this._setState('RemoteControl')
          this._setState('EnergySaver');
        }
        _handleEnter() {
          Router.navigate('settings/other/timer');
        }
      }, class RemoteControl extends this {
        $enter() {
          this.tag('RemoteControl')._focus();
        }
        $exit() {
          this.tag('RemoteControl')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('ScreenSaver');
        }
        _handleEnter() {}
      }, class ScreenSaver extends this {
        $enter() {
          this.tag('ScreenSaver')._focus();
        }
        $exit() {
          this.tag('ScreenSaver')._unfocus();
        }
        _handleUp() {
          this._setState('RemoteControl');
        }
        _handleDown() {
          this._setState('EnergySaver');
        }
        _handleEnter() {
          // 
        }
      }, class EnergySaver extends this {
        $enter() {
          this.tag('EnergySaver')._focus();
        }
        $exit() {
          this.tag('EnergySaver')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          // this._setState('Theme')
          this._setState('Language');
        }
        _handleEnter() {
          Router.navigate('settings/other/energy');
        }
      }, class Language extends this {
        $enter() {
          this.tag('Language')._focus();
        }
        $exit() {
          this.tag('Language')._unfocus();
        }
        _handleUp() {
          this._setState('EnergySaver');
        }
        _handleDown() {
          this._setState('Privacy');
        }
        _handleEnter() {
          Router.navigate('settings/other/language');
        }
      }, class Privacy extends this {
        $enter() {
          this.tag('Privacy')._focus();
        }
        $exit() {
          this.tag('Privacy')._unfocus();
        }
        _handleUp() {
          this._setState('Language');
        }
        _handleDown() {
          this._setState('AdvancedSettings');
        }
        _handleEnter() {
          Router.navigate('settings/other/privacy');
        }
      }, class AdvancedSettings extends this {
        $enter() {
          this.tag('AdvancedSettings')._focus();
        }
        $exit() {
          this.tag('AdvancedSettings')._unfocus();
        }
        _handleUp() {
          this._setState('Privacy');
        }
        _handleDown() {
          // this._setState('SleepTimer')
        }
        _handleEnter() {
          Router.navigate('settings/advanced');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SleepTimerScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Sleep Timer'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        SleepTimer: {
          y: 275,
          x: 200,
          List: {
            w: 1920 - 300,
            type: lng$1.components.ListComponent,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -5
          }
        }
      };
    }
    _firstEnable() {
      this.lastElement = false;
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '1 Hour',
        tick: false
      }, {
        value: '1.5 Hours',
        tick: false
      }, {
        value: '2 Hours',
        tick: false
      }, {
        value: '3 Hours',
        tick: false
      }];
      this.tag('List').h = this.options.length * 90;
      let timeoutInterval = Storage.get('TimeoutInterval');
      if (!timeoutInterval) {
        timeoutInterval = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (timeoutInterval === item.value) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this.fireAncestors('$registerInactivityMonitoringEvents').then(res => {
        this.fireAncestors('$resetSleepTimer', timeoutInterval);
      }).catch(err => {
        console.error("error while registering the inactivity monitoring event");
      });
      this._setState('Options');
    }
    _handleBack() {
      Router.navigate('settings/other');
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          this.options.forEach((element, idx) => {
            //if (element.tick) {
            this.tag('List').getElement(idx).tag('Tick').visible = false;
            //this.options[idx].tick = false
            //}
          });

          this.tag('List').element.tag('Tick').visible = true;
          //this.options[this.tag('List').index].tick = true
          this.fireAncestors('$sleepTimerText', this.options[this.tag('List').index].value);
          this.fireAncestors('$resetSleepTimer', this.options[this.tag('List').index].value);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class EnergySavingsItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90,
          rect: true,
          color: 0x00000000
        },
        BottomLine: {
          y: 0 + 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {
      if (this.isTicked) {
        this.fireAncestors("$resetPrevTickObject", this);
      }
      this.appApi = new AppApi();
    }
    _handleEnter() {
      var self = this;
      var standbyMode = "";
      if (this._item === "Deep Sleep") {
        standbyMode = "DEEP_SLEEP";
      } else if (this._item === "Light Sleep") {
        standbyMode = "LIGHT_SLEEP";
      }
      this.appApi.setPreferredStandbyMode(standbyMode).then(result => {
        console.log("setPreferredStandbyMode " + JSON.stringify(result));
        self.fireAncestors("$resetPrevTickObject", self);
        this.fireAncestors("$updateStandbyMode", this._item);
        self.tag("Item.Tick").visible = true;
      });
    }
    set item(item) {
      this._item = item;
      var self = this;
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: self.isTicked ? true : false //implement the logic to show the tick
        },

        Left: {
          x: 50,
          y: 45,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: 0xffFFFFFF,
            fontFace: CONFIG.language.font
          } // update the text
        }
      });
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class EnergySavingsScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Energy Saver'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        EnerygySavingContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    _handleBack() {
      Router.navigate('settings/other');
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          // this.tag("List").element.patch({ "Item.Tick.visible": true });
          this.tag("List").element.tag("Tick").visible = true;
          // enable the tick mark in VideoAudioItem.js
          //to update the resolution value on Video Screen
        }
      }];
    }

    _firstEnable() {
      this._appApi = new AppApi();
      this.options = [Language.translate("Deep Sleep"), Language.translate("Light Sleep")];
      this.tag('EnerygySavingContents').h = this.options.length * 90;
      this.tag('EnerygySavingContents.List').h = this.options.length * 90;
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _focus() {
      this.loadingAnimation.start();
      var standbyMode = "";
      this._appApi.getPreferredStandbyMode().then(result => {
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          standbyMode = Language.translate("Light Sleep");
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          standbyMode = Language.translate("Deep Sleep");
        }
        this.tag('List').items = this.options.map((item, index) => {
          return {
            ref: 'Option' + index,
            w: 1920 - 300,
            h: 90,
            type: EnergySavingsItem,
            isTicked: standbyMode === item ? true : false,
            item: item,
            energyItem: true
          };
        });
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
        this._setState("Options");
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class LanguageItem extends SettingsItem {
    static _template() {
      return {
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {}

    /**
     * Function to set contents of an item in the Language screen.
     */
    set item(item) {
      // console.log(item)
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          w: 32.5,
          h: 32.5,
          src: Utils.asset('images/settings/Tick.png'),
          color: 0xffffffff,
          visible: localStorage.getItem('Language') === item ? true : item === 'English' && localStorage.getItem('Language') === null ? true : false
        },
        Left: {
          x: 60,
          y: 45,
          mountY: 0.5,
          text: {
            text: Language.translate(item),
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _focus() {
      this.tag("Item").color = COLORS.hightlightColor;
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$9 = new AppApi();
  const thunder$a = thunderJS({
    host: '127.0.0.1',
    port: 9998,
    default: 1
  });
  const loader$2 = 'Loader';
  class LanguageScreen$2 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Language'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        LanguageScreenContents: {
          x: 200,
          y: 275,
          Languages: {
            flexItem: {
              margin: 0
            },
            List: {
              type: lng$1.components.ListComponent,
              w: 1920 - 300,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -4
            }
          }
        }
      };
    }
    _init() {
      this._Languages = this.tag('LanguageScreenContents.Languages');
      this._Languages.h = availableLanguages.length * 90;
      this._Languages.tag('List').h = availableLanguages.length * 90;
      this._Languages.tag('List').items = availableLanguages.map((item, index) => {
        return {
          ref: 'Lng' + index,
          w: 1620,
          h: 90,
          type: LanguageItem,
          item: item
        };
      });
      appApi$9.deactivateResidentApp(loader$2);
      appApi$9.setVisibility('ResidentApp', true);
      thunder$a.call('org.rdk.RDKShell', 'moveToFront', {
        client: 'ResidentApp'
      }).then(result => {
        console.log('ResidentApp moveToFront Success');
      });
      thunder$a.call('org.rdk.RDKShell', 'setFocus', {
        client: 'ResidentApp'
      }).then(result => {
        console.log('ResidentApp moveToFront Success');
      }).catch(err => {
        console.log('Error', err);
      });
    }
    _focus() {
      this._setState('Languages');
    }
    _handleBack() {
      Router.navigate('settings/other');
    }
    static _states() {
      return [class Languages extends this {
        $enter() {}
        _getFocused() {
          return this._Languages.tag('List').element;
        }
        _handleDown() {
          this._navigate('down');
        }
        _handleUp() {
          this._navigate('up');
        }
        _handleEnter() {
          if (localStorage.getItem('Language') !== availableLanguages[this._Languages.tag('List').index]) {
            localStorage.setItem('Language', availableLanguages[this._Languages.tag('List').index]);
            let path = location.pathname.split('index.html')[0];
            let url = path.slice(-1) === '/' ? "static/loaderApp/index.html" : "/static/loaderApp/index.html";
            let notification_url = location.origin + path + url;
            console.log(notification_url);
            appApi$9.launchResident(notification_url, loader$2).catch(err => {});
            appApi$9.setVisibility('ResidentApp', false);
            location.reload();
          }
        }
      }];
    }
    _navigate(dir) {
      let list = this._Languages.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Privacy Screen.
   */

  const xcastApi$1 = new XcastApi();
  class PrivacyScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Privacy'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        PrivacyScreenContents: {
          x: 200,
          y: 275,
          LocalDeviceDiscovery: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Local Device Discovery'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          UsbMediaDevices: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('USB Media Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          AudioInput: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Audio Input'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          ClearCookies: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Clear Cookies and App Data'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          PrivacyPolicy: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Privacy Policy and License'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _firstEnable() {
      this._setState('LocalDeviceDiscovery');
      this.checkLocalDeviceStatus();
      this.USBApi = new UsbApi();
      this.AppApi = new AppApi();
    }
    _focus() {
      this._setState(this.state);
      this.checkLocalDeviceStatus();
      this.checkUSBDeviceStatus();
    }
    _handleBack() {
      Router.navigate('settings/other');
    }
    checkUSBDeviceStatus() {
      if (!Storage.get('UsbMedia')) {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        Storage.set('UsbMedia', 'ON');
      } else if (Storage.get('UsbMedia') === 'ON') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
      } else if (Storage.get('UsbMedia') === 'OFF') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      }
    }
    checkLocalDeviceStatus() {
      xcastApi$1.getEnabled().then(res => {
        if (res.enabled) {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        } else {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
        }
      }).catch(err => {
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    toggleLocalDeviceDiscovery() {
      xcastApi$1.getEnabled().then(res => {
        if (!res.enabled) {
          xcastApi$1.activate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            }
          });
        } else {
          xcastApi$1.deactivate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            }
          });
        }
      }).catch(err => {
        console.log('Service not active');
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    static _states() {
      return [class LocalDeviceDiscovery extends this {
        $enter() {
          this.tag('LocalDeviceDiscovery')._focus();
        }
        $exit() {
          this.tag('LocalDeviceDiscovery')._unfocus();
        }
        _handleUp() {
          // this._setState('PrivacyPolicy')
        }
        _handleDown() {
          this._setState('UsbMediaDevices');
        }
        _handleEnter() {
          this.toggleLocalDeviceDiscovery();
        }
      }, class UsbMediaDevices extends this {
        $enter() {
          this.tag('UsbMediaDevices')._focus();
        }
        $exit() {
          this.tag('UsbMediaDevices')._unfocus();
        }
        _handleUp() {
          this._setState('LocalDeviceDiscovery');
        }
        _handleDown() {
          this._setState('AudioInput');
        }
        _handleEnter() {
          let _UsbMedia = Storage.get('UsbMedia');
          if (_UsbMedia === 'ON') {
            this.fireAncestors('$deRegisterUsbMount');
            this.USBApi.deactivate().then(res => {
              Storage.set('UsbMedia', 'OFF');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this.widgets.menu.refreshMainView();
            }).catch(err => {
              console.error("error while disabling the usb plugin = ".concat(err));
              this.fireAncestors('$registerUsbMount');
            });
          } else if (_UsbMedia === 'OFF') {
            this.USBApi.activate().then(res => {
              Storage.set('UsbMedia', 'ON');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
              this.fireAncestors('$registerUsbMount');
              this.widgets.menu.refreshMainView();
            });
          }
        }
      }, class AudioInput extends this {
        $enter() {
          this.tag('AudioInput')._focus();
        }
        $exit() {
          this.tag('AudioInput')._unfocus();
        }
        _handleUp() {
          this._setState('UsbMediaDevices');
        }
        _handleDown() {
          this._setState('ClearCookies');
        }
        _handleEnter() {
          // 
        }
      }, class ClearCookies extends this {
        $enter() {
          this.tag('ClearCookies')._focus();
        }
        $exit() {
          this.tag('ClearCookies')._unfocus();
        }
        _handleUp() {
          this._setState('AudioInput');
        }
        _handleDown() {
          this._setState('PrivacyPolicy');
        }
        _handleEnter() {
          this.AppApi.clearCache().then(() => {
            //location.reload(true)
          });
        }
      }, class PrivacyPolicy extends this {
        $enter() {
          this.tag('PrivacyPolicy')._focus();
        }
        $exit() {
          this.tag('PrivacyPolicy')._unfocus();
        }
        _handleUp() {
          this._setState('ClearCookies');
        }
        _handleDown() {
          // this._setState('LocalDeviceDiscovery')
        }
        _handleEnter() {
          Router.navigate('settings/other/privacyPolicy');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const _privacyPolicy$1 = "Privacy\n Welcome to RDKCentral.com, a website owned and operated by RDK Management, LLC (\u201CRDK Management,\u201D \u201Cwe,\u201D or \u201Cus\u201D). This privacy policy discloses the privacy practices for this website only, including an explanation of:\n \n the categories of personally identifiable information about you that may be collected and how that information is used;\n how we collect and use non-personally identifiable information about your use of the website;\n the categories of persons or entities with whom the information may be shared;\n the choices that are available to you regarding collection, use, and distribution of the information;\n how you can opt out of RDK-related promotional e-mail;\n the kind of security procedures that are in place to protect the loss, misuse or alteration of information;\n how you can review and request changes to the information; and\n how we notify users of this website of changes to this privacy policy.\n Questions regarding this policy should be directed to \u201CRDK Management \u2013 Privacy Feedback\u201D and can be submitted via e-mail to info@rdkcentral.com.\n \n \n What categories of information do we collect?\n The information collected by RDK Management falls into two categories: (1) information voluntarily supplied by users of the website and (2) tracking information recorded as users navigate through the website. Some of this information is personally identifiable information (i.e., information that identifies a particular person, such as e-mail address), but much of it is not.\n \n To make use of some features on our website, like the RDK Wiki, users need to register and provide certain information as part of the registration process. We may ask, for example, for your name, e-mail address, street address, and zip code. We might also request information about your employer and the type of work that you do, in order to determine whether your employer is a member of the RDK program, to help us ensure that you are given access to the correct portions of the website, and to tailor our website content and e-mail (if you\u2019ve registered to receive e-mail) to your interests to make it more useful to you. If you are a registered user, our systems will remember some of this information the next time you log in and use our website, but you can always review and change your information by logging in and editing your profile here.\n \n The more you tell us about yourself, the more value we can offer you. Supplying this information is entirely voluntary. But if you choose not to supply the information, we may be unable to provide you with access to all of the features of this website. There are certain features of this website, including the Wiki and requesting to receive RDK-related promotional e-mail, that you will not be able to use unless you provide certain personally identifiable information about yourself. When you submit any personally identifiable information over this website, RDK Management (i) will use the information for the purposes described at the time you submit it and (ii) may use the information to contact you, subject to the contact preferences in your profile. If you want to remain completely anonymous, you\u2019re still free to take advantage of the publicly available content on our website without registration.\n \n Does RDK Management analyze my interaction with this website?\n Some of the third-party service providers that RDK Management uses to deliver services, like analytics providers, may collect information on this website as disclosed in this privacy policy. This information may include personally identifiable information or may be used to contact you online.\n \n We and our service providers may use cookies to provide these services. The World Wide Web Consortium (W3C) has started a process to develop a \u201CDo Not Track\u201D Standard. Since the definitions and rules for such a standard have not yet been defined, RDK Management does not yet respond to \u201CDo Not Track\u201D signals sent from browsers.\n \n You may opt out of receiving cookies from the companies that provide services on this website by going to www.networkadvertising.org/consumer/opt_out.asp or http://www.aboutads.info/choices.\n \n What categories of persons or entities do we share personally identifiable information with?\n We consider the personally identifiable information contained in our business records to be confidential. We may sometimes disclose personally identifiable information about you to our affiliates or to others who work for us. We may also disclose personally identifiable information about you to service providers and vendors, and to others who provide products and services to us. For example, when you use certain functions on this website you may notice that the website actually collecting or processing the information may be other than an RDK Management website. We may be required by law or legal process to disclose certain personally identifiable information about you to lawyers and parties in connection with litigation and to law enforcement personnel. For example, we may be required by law to disclose personally identifiable information about you without your consent and without notice in order to comply with a valid legal process such as a subpoena, court order, or search warrant.\n \n What do we do to personalize your use of this website?\n We, or our service providers, may customize this website based on non-personal information including: (i) the IP address associated with your computer for purposes of determining your approximate geographic location; (ii) the type of web page that is being displayed; or (iii) the content on the page that is shown. Because this activity automatically applies to all users and it is purely contextual, this type of content delivery cannot be customized or controlled by individual users. We may also personalize this website based on the information that you provided us during registration. You may modify this information as further described in this Privacy Policy.\n \n To help make our website more responsive to the needs of our users, we use a standard feature of browser software called a \u201Ccookie.\u201D We use cookies to help us tailor our website to your needs, to deliver a better, more personalized service, and to remember certain choices you\u2019ve made so you don\u2019t have to re-enter them.\n \n RDK Management uses cookies, among other things, to remember your username and password, if you choose to store them, as well as to remember some of your personalization preferences and website features. RDK Management does not store your name or other personal information in cookies. You may read about enabling, disabling, and deleting cookies here. Of course, if you set your browser not to accept cookies or you delete them, you may not be able to take advantage of the personalized features enjoyed by other users of our website.\n \n The cookies we use don\u2019t directly identify users of our website as particular persons. Rather, they contain information sufficient to simplify and improve a user\u2019s experience on our website. For example, we may use session-based cookies to track the pages on our website visited by our users. We can build a better website if we know which pages our users are visiting and how often. Or, we may use persistent cookies to simplify access to a user\u2019s account information over our website, for example.\n \n In connection with the standard operation of RDK Management\u2019s systems, certain non-personally identifiable information about users of this website is recorded. This information is used primarily to tailor and enhance users\u2019 experience using the website. We may use this information in an aggregate, non-personally identifiable form to, among other things, measure the use of our website and determine which pages are the most popular with website users.\n \n We may also use one or more audience segmenting technology providers to help present content on this website. These providers uses cookies, web beacons, or similar technologies on your computer or mobile or other device to serve you advertisements or content tailored to interests you have shown by browsing on this and other websites you have visited. It also helps determine whether you have seen a particular piece of content before and in order to avoid sending you duplicates. In doing so, these providers collect non-personally identifiable information such as your browser type, your operating system, web pages visited, time of visits, content viewed, ads viewed, and other click stream data. When you visit this website, these providers may use cookies or web beacons to note which product and service descriptions your browser visited. The use of cookies, web beacons, or similar technologies by these providers is subject to their own privacy policies, not RDK Management\u2019s privacy policy for this website. If you do not want the benefits of the cookies used by these providers, you may opt-out of them by visiting http://www.networkadvertising.org/consumer/opt_out.asp or by visiting their opt-out pages.\n \n Your Access to and Control over your information?\n You may opt out of any future contacts from us at any time. You can do the following at any time via email to support@rdkcentral.com or info@rdkcentral.com or unsubscribe to emails.\n \n Request to see all the information stored in the system\n Accuracy of your data can be checked or corrected.\n Personal data will be archived, in case user does not access our system for 90 days. However, user can request for deletion by writing to us at support@rdkcentral.com\n Express any concern you have about our use of your data\n Opt out from receiving emails by clicking unsubscribe.\n How do users opt out of RDK-related promotional e-mail?\n You can opt out of receiving RDK-related promotional e-mail from RDK Management using the opt-out link found in the footer of any of these e-mails. You can also e-mail the request to the attention of \u201CRDK Management \u2013 E-mail Opt Out\u201D via e-mail to info@rdkcentral.com.\n \n Other Websites\n \n To make our website more valuable to our users, we may offer some features in conjunction with other providers. Our website may also include links to other websites whose privacy policies and practices we don\u2019t control. Once you leave our website by linking to another one (you can tell where you are by checking the address \u2013 known as a URL \u2013 in the location bar on your browser), use of any information you provide is governed by the privacy policy of the operator of the website you\u2019re visiting. That policy may differ from ours. If you can\u2019t find the privacy policy of any of these websites via a link from the site\u2019s homepage, you should contact the website directly for more information.\n \n Security\n \n All information gathered on our website is stored within a database accessible only to RDK Management, its affiliates, and their specifically-authorized contractors and vendors. However, as effective as any security measure implemented by RDK Management may be, no security system is impenetrable. We cannot guarantee the complete security of our database, nor can we guarantee that information you supply won\u2019t be intercepted while being transmitted to us over the Internet. If you don\u2019t want us to know any particular information about you, don\u2019t include it in anything that you submit or post to this website or send to us in e-mail. We will retain and use your information to the extent necessary to comply with our legal obligations, resolve disputes, and enforce our policies.\n \n Changes to this Privacy Policy\n \n We may change this privacy policy from time to time. If we change this privacy policy at some point in the future, we\u2019ll post the changes on our website and by continuing to use the website after we post any changes, you accept and agree to this privacy statement, as modified.\n \n A Special Note About Children\n \n This website is not directed to children under the age of 13, and RDK Management does not knowingly collect personally identifiable information from anyone under the age of 18 on this website.\n \n Contacting us:\n \n If you have any questions about RDK Management, LLC privacy policy, the data we hold on you, or you would like to exercise one of your data protection rights, please do not hesitate to contact us.\n \n Data Protection Officer:  Herman-Jan Smith\n \n Email us at: hj.smith@rdkcentral.com\n \n Contacting the appropriate authority:\n \n Should you wish to report a complaint or if you feel that Our Company has not addressed your concern in a satisfactory manner, you may contact the Information Commissioner\u2019s Office.\n \n Email: compliance_team@rdkcentral.com\n \n Address:  1701 JFK Boulevard, Philadelphia, PA 19103 U.S.A";
  class PrivacyPolicyScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Privacy  Policy'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        clipping: true,
        PrivacyPolicy: {
          x: 200,
          y: 270,
          Title: {
            x: 10,
            y: 45,
            mountY: 0.5,
            text: {
              text: "Privacy Policy",
              textColor: COLORS.titleColor,
              fontFace: CONFIG.language.font,
              fontStyle: "bold",
              fontSize: 40
            }
          },
          Content: {
            x: 10,
            y: 100,
            text: {
              text: _privacyPolicy$1,
              textColor: COLORS.titleColor,
              fontFace: CONFIG.language.font,
              fontSize: 20,
              wordWrapWidth: 1500,
              wordWrap: true
            }
          }
        }
      };
    }
    _handleDown() {
      if (this.tag("PrivacyPolicy").y > -2400) {
        this.tag("PrivacyPolicy").y -= 35;
      }
    }
    _handleBack() {
      Router.navigate('settings/other/privacy');
    }
    _handleUp() {
      if (this.tag("PrivacyPolicy").y <= 235) {
        this.tag("PrivacyPolicy").y += 35;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$9 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  const thunder$9 = thunderJS(config$9);
  class CECApi {
    activate() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.HdmiCec_2';
        thunder$9.Controller.activate({
          callsign: systemcCallsign
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log('CEC Error Activation', err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.HdmiCec_2';
        thunder$9.Controller.deactivate({
          callsign: systemcCallsign
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log('CEC Error Deactivation', err);
        });
      });
    }
    getEnabled() {
      return new Promise((resolve, reject) => {
        thunder$9.call('org.rdk.HdmiCec_2', 'getEnabled').then(result => {
          resolve(result);
        }).catch(err => {
          resolve({
            enabled: false
          });
        });
      });
    }
    setEnabled() {
      return new Promise((resolve, reject) => {
        thunder$9.call('org.rdk.HdmiCec_2', 'setEnabled', {
          enabled: true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('CEC Set Enabled', err);
          resolve({
            success: false
          });
        });
      });
    }
    performOTP() {
      return new Promise((resolve, reject) => {
        thunder$9.call('org.rdk.HdmiCec_2', 'performOTPAction').then(result => {
          resolve(result);
        }).catch(err => {
          console.error('CEC Otp Error', err);
          resolve({
            success: false
          });
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$8 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  thunderJS(config$8);
  /**
   * Class for AdvancedSettings screen.
   */

  class AdvanceSettingsScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Advanced Settings'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        AdvanceScreenContents: {
          x: 200,
          y: 275,
          TTSOptions: {
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('TTS Options'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CECControl: {
            y: 90,
            // alpha: 0.3, // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('CEC Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Bug: {
            y: 180,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Bug Report'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Contact: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Contact Support'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Device: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this.cecApi = new CECApi();
      this.cecApi.activate().then(() => {
        this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.performOTPAction();
      });
      this._setState('CECControl');
    }
    _focus() {
      this._setState(this.state);
    }
    _handleBack() {
      Router.navigate('settings/other');
    }
    performOTPAction() {
      this.cecApi.setEnabled().then(res => {
        if (res.success) {
          this.cecApi.performOTP().then(otpRes => {
            if (otpRes.success) {
              console.log('Otp Action success full');
            }
          });
        }
      });
    }
    toggleCEC() {
      this.cecApi.getEnabled().then(res => {
        console.log(res);
        if (res.enabled) {
          this.cecApi.deactivate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          });
        } else {
          this.cecApi.activate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
          });
        }
      });
    }
    static _states() {
      return [class UIVoice extends this {
        $enter() {
          this.tag('UIVoice')._focus();
        }
        $exit() {
          this.tag('UIVoice')._unfocus();
        }
        _handleUp() {
          //this._setState('Reset');
        }
        _handleDown() {
          //this._setState('TTSOptions')
        }
        _handleEnter() {}
      }, class TTSOptions extends this {
        $enter() {
          this.tag('TTSOptions')._focus();
        }
        $exit() {
          this.tag('TTSOptions')._unfocus();
        }
        _handleUp() {
          //this._setState('UIVoice');
        }
        _handleDown() {
          //this._setState('CECControl')
        }
        _handleEnter() {}
      }, class CECControl extends this {
        $enter() {
          this.tag('CECControl')._focus();
        }
        $exit() {
          this.tag('CECControl')._unfocus();
        }
        _handleUp() {
          //this._setState('TTSOptions');
        }
        _handleDown() {
          this._setState('Device');
        }
        _handleEnter() {
          this.toggleCEC();
        }
      }, class Bug extends this {
        $enter() {
          this.tag('Bug')._focus();
        }
        $exit() {
          this.tag('Bug')._unfocus();
        }
        _handleUp() {
          //this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('Contact')
        }
        _handleEnter() {}
      }, class Contact extends this {
        $enter() {
          this.tag('Contact')._focus();
        }
        $exit() {
          this.tag('Contact')._unfocus();
        }
        _handleUp() {
          //this._setState('Bug');
        }
        _handleDown() {
          //this._setState('Device')
        }
        _handleEnter() {}
      }, class Device extends this {
        $enter() {
          this.tag('Device')._focus();
        }
        $exit() {
          this.tag('Device')._unfocus();
        }
        _handleUp() {
          this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('UI Voice')
        }
        _handleEnter() {
          Router.navigate('settings/advanced/device');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video and Audio screen.
   */

  class DeviceScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Advanced Settings  Device'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        DeviceScreenContents: {
          x: 200,
          y: 275,
          Info: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TimeZone: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Time Zone'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Firmware: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Check for Firmware Update'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Reboot: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Reboot'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Reset: {
            y: 360,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Factory Reset'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._network = new Network();
      this._setState('Info');
    }
    _focus() {
      this._setState(this.state);
    }
    _handleBack() {
      Router.navigate('settings/advanced');
    }
    static _states() {
      return [class Info extends this {
        $enter() {
          this.tag('Info')._focus();
        }
        $exit() {
          this.tag('Info')._unfocus();
        }
        _handleUp() {
          // this._setState('Reboot');
        }
        _handleDown() {
          this._setState('TimeZone');
        }
        _handleEnter() {
          Router.navigate('settings/advanced/device/info');
        }
      }, class TimeZone extends this {
        $enter() {
          this.tag('TimeZone')._focus();
        }
        $exit() {
          this.tag('TimeZone')._unfocus();
        }
        _handleUp() {
          this._setState('Info');
        }
        _handleDown() {
          this._setState('Firmware');
        }
        _handleEnter() {
          Router.navigate('settings/advanced/device/timezone');
        }
      }, class Firmware extends this {
        $enter() {
          this.tag('Firmware')._focus();
        }
        $exit() {
          this.tag('Firmware')._unfocus();
        }
        _handleUp() {
          this._setState('TimeZone');
        }
        _handleDown() {
          this._setState('Reboot');
        }
        _handleEnter() {
          Router.navigate('settings/advanced/device/firmware');
        }
      }, class Reboot extends this {
        $enter() {
          this.tag('Reboot')._focus();
        }
        $exit() {
          this.tag('Reboot')._unfocus();
        }
        _handleUp() {
          this._setState('Firmware');
        }
        _handleDown() {
          // this._setState('Info')
        }
        _handleEnter() {
          Router.navigate('settings/advanced/device/reboot');
        }
      }, class Reset extends this {
        $enter() {
          this.tag('Reset')._focus();
        }
        $exit() {
          this.tag('Reset')._unfocus();
        }
        _handleUp() {
          //this._setState('Reboot');
        }
        _handleDown() {
          //this._setState('Info')
        }
        _handleEnter() {}
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video and Audio screen.
   */

  class DeviceInformationScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Advanced Settings  Device  Info'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: 0xCC000000,
        DeviceInfoContents: {
          x: 200,
          y: 275,
          Line1: {
            y: 0,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          ChipSet: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate("Chipset"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 45,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line2: {
            y: 90,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          SerialNumber: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language.translate("Serial Number"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 135,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line3: {
            y: 180,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          Location: {
            Title: {
              x: 10,
              y: 225,
              mountY: 0.5,
              text: {
                text: Language.translate("Location"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 225,
              mountY: 0.5,
              text: {
                text: "City: N/A , Country: N/A ",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line4: {
            y: 270,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          SupportedDRM: {
            Title: {
              x: 10,
              y: 360,
              mountY: 0.5,
              text: {
                text: Language.translate("Supported DRM & Key-System"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1600,
                wordWrap: true,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 360,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1200,
                wordWrap: true,
                fontSize: 25
              }
            }
          },
          Line5: {
            y: 450,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          FirmwareVersions: {
            Title: {
              x: 10,
              y: 540,
              mountY: 0.5,
              text: {
                text: Language.translate("Firmware version"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 540,
              mountY: 0.5,
              text: {
                text: "UI Version: ".concat(Settings.get('platform', 'version'), ", Build Version: , Timestamp: "),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line6: {
            y: 630,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          AppVersions: {
            Title: {
              x: 10,
              y: 720,
              mountY: 0.5,
              text: {
                text: Language.translate("App Info"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 720,
              mountY: 0.5,
              text: {
                text: "Youtube:\nAmazon Prime:\nNetflix ESN:",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line7: {
            y: 810,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          }
        }
      };
    }
    _init() {
      this._network = new Network();
      this.appApi = new AppApi();
    }
    _focus() {
      this._setState('DeviceInformationScreen');
      this.appApi.getSerialNumber().then(result => {
        this.tag("SerialNumber.Value").text.text = "".concat(result.serialNumber);
      });
      this.appApi.getSystemVersions().then(res => {
        this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings.get('platform', 'version'), " \nBuild Version - ").concat(res.stbVersion, " \nTime Stamp - ").concat(res.stbTimestamp, " ");
      }).catch(err => {
        console.error("error while getting the system versions");
      });
      this.appApi.getDRMS().then(result => {
        console.log('from device info supported drms ' + JSON.stringify(result));
        var drms = "";
        result.forEach(element => {
          drms += "".concat(element.name, " :");
          if (element.keysystems) {
            drms += "\t";
            element.keysystems.forEach(keySystem => {
              drms += "".concat(keySystem, ", ");
            });
            drms += "\n";
          } else {
            drms += "\n";
          }
        });
        this.tag('SupportedDRM.Value').text.text = "".concat(drms.substring(0, drms.length - 1));
      });
      this._network.isConnectedToInternet().then(result => {
        if (result.connectedToInternet === true) {
          this.appApi.getLocation().then(result => {
            console.log("getLocation from device info " + JSON.stringify(result));
            var locationInfo = "";
            if (result.city.length !== 0) {
              locationInfo = "City: " + result.city;
            } else {
              locationInfo = "City: N/A ";
            }
            if (result.country.length !== 0) {
              locationInfo += ", Country: " + result.country;
            } else {
              locationInfo += ", Country: N/A ";
            }
            this.tag('Location.Value').text.text = "".concat(locationInfo);
          });
        } else {
          this.tag('Location.Value').text.text = "City: N/A, Country: N/A";
        }
      });
      this.appApi.getDeviceIdentification().then(result => {
        console.log('from device Information screen getDeviceIdentification: ' + JSON.stringify(result));
        this.tag('ChipSet.Value').text.text = "".concat(result.chipset);
        // this.tag('FirmwareVersions.Value').text.text = `${result.firmwareversion}`
      });

      let self = this;
      if (Storage.get('Netflix_ESN')) {
        self.tag('AppVersions.Value').text.text = "Youtube: NA\nAmazon Prime: NA\nNetflix ESN: ".concat(Storage.get('Netflix_ESN'));
      } else {
        self.appApi.getPluginStatus('Netflix').then(result => {
          let sel = self;
          console.log("Netflix : plugin status : ", JSON.stringify(result));
          if (result[0].state === 'deactivated' || result[0].state === 'deactivation') {
            sel.appApi.launchPremiumAppInSuspendMode("Netflix").then(res => {
              console.log("Netflix : netflix launch for esn value in suspend mode returns : ", JSON.stringify(res));
              let se = sel;
              se.appApi.getNetflixESN().then(res => {
                Storage.set('Netflix_ESN', res);
                console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
                se.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
              }).catch(err => {
                console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
              });
            }).catch(err => {
              console.error("Netflix : error while launching netflix in suspendMode : ", JSON.stringify(err));
            });
          } else {
            self.appApi.getNetflixESN().then(res => {
              Storage.set('Netflix_ESN', res);
              console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
              self.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
            }).catch(err => {
              console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
            });
          }
        }).catch(err => {
          console.error("Netflix : error while getting netflix plugin status ie. ", JSON.stringify(err));
        });
      }
      this.appApi.registerChangeLocation();
    }
    set netflixESN(v) {
      console.log("setting netflix ESN value to ".concat(v));
      this.tag('AppVersions.Value').text.text = v;
    }
    _handleBack() {
      Router.navigate('settings/advanced/device');
    }
    _handleDown() {
      if (this.tag("DeviceInfoContents").y > 215) {
        this.tag("DeviceInfoContents").y -= 20;
      }
    }
    _handleUp() {
      if (this.tag("DeviceInfoContents").y < 275) {
        this.tag("DeviceInfoContents").y += 20;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Firmware screen.
   */

  class FirmwareScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Advanced Settings  Device  Firmware Update'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        FirmwareContents: {
          x: 200,
          y: 270,
          State: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Firmware State: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          Version: {
            Title: {
              x: 10,
              y: 90,
              mountY: 0.5,
              text: {
                text: Language.translate('Firmware Versions: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedVersion: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language.translate("Downloaded Firmware Version: "),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedPercent: {
            Title: {
              x: 10,
              y: 180,
              mountY: 0.5,
              text: {
                text: "",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          FirmwareUpdate: {
            RectangleDefault: {
              x: 110,
              y: 200,
              w: 300,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: CONFIG.theme.hex,
              Update: {
                x: 170,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Check for Update"),
                  fontFace: CONFIG.language.font,
                  fontSize: 24
                }
              }
            }
          }
        }
      };
    }
    _firstEnable() {
      let state = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      const thunder = thunderJS(config);
      const systemcCallsign = "org.rdk.System.1";
      thunder.Controller.activate({
        callsign: systemcCallsign
      }).then(res => {
        thunder.on(callsign, "onFirmwareUpdateStateChange", notification => {
          console.log("Tanjirou's notification : on Firmware update state changed notifcation = ".concat(JSON.stringify(notification)));
          if (state[notification.firmwareUpdateStateChange] == "Downloading") {
            this.downloadInterval = setInterval(() => {
              console.log("Downloading...");
              this.getDownloadPercent();
            }, 1000);
          } else if (state[notification.firmwareUpdateStateChange] != "Downloading" && this.downloadInterval) {
            clearInterval(this.downloadInterval);
            this.downloadInterval = null;
          }
        }, err => {
          console.error("error while fetching notification ie. ".concat(err));
        });
      }).catch(err => {
        console.error("error while activating the system plugin");
      });
    }
    _unfocus() {
      if (this.downloadInterval) {
        clearInterval(this.downloadInterval);
        this.downloadInterval = null;
      }
    }
    _focus() {
      this.downloadInterval = null;
      this._appApi = new AppApi();
      const downloadState = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      this._appApi.getFirmwareUpdateState().then(res => {
        console.log("getFirmwareUpdateState from firmware screen " + JSON.stringify(res));
        this.tag('State.Title').text.text = Language.translate("Firmware State: ") + downloadState[res.firmwareUpdateState];
      });
      this._appApi.getDownloadFirmwareInfo().then(res => {
        console.log("getDownloadFirmwareInfo from firmware screen " + JSON.stringify(res));
        this.tag('Version.Title').text.text = Language.translate("Firmware Versions: ") + res.currentFWVersion;
      });
      this._setState('FirmwareUpdate');
    }
    getDownloadPercent() {
      this._appApi.getFirmwareDownloadPercent().then(res => {
        console.log("getFirmwareDownloadPercent : ".concat(JSON.stringify(res)));
        if (res.downloadPercent < 0) {
          this.tag('DownloadedPercent.Title').text.text = "";
        } else {
          this.tag('DownloadedPercent.Title').text.text = Language.translate("Download Progress: ") + res.downloadPercent + "%";
        }
      }).catch(err => {
        console.error(err);
      });
    }
    getDownloadFirmwareInfo() {
      this._appApi.updateFirmware().then(res => {
        this._appApi.getDownloadFirmwareInfo().then(result => {
          console.log("getDownloadFirmwareInfo : ".concat(JSON.stringify(result.downloadFWVersion)));
          this.tag('DownloadedVersion.Title').text.text = Language.translate('Downloaded Firmware Version: ') + "".concat(result.downloadFWVersion ? result.downloadFWVersion : 'NA');
        }).catch(err => {
          console.error(err);
        });
      }).catch(err => {
        console.error(err);
      });
    }
    _handleBack() {
      Router.navigate('settings/advanced/device');
    }
    static _states() {
      return [class FirmwareUpdate extends this {
        _handleEnter() {
          this.getDownloadFirmwareInfo();
          this.getDownloadPercent();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$8 = new AppApi();
  /**
   * Class for Reboot Confirmation Screen.
   */
  class RebootConfirmationScreen extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language.translate("Reboot"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language.translate("Click Confirm to reboot!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _focus() {
      this._setState('Confirm');
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _handleBack() {
      Router.navigate('settings/advanced/device');
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          appApi$8.reboot().then(result => {
            console.log('device rebooting' + JSON.stringify(result));
            this._setState('Rebooting');
          });
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _focus() {
          this.tag('Confirm').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Confirm').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          Router.back();
        }
        _handleLeft() {
          this._setState('Confirm');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Rebooting extends this {
        $enter() {
          this.loadingAnimation.start();
          this.tag("Loader").visible = true;
          this.tag("Title").text.text = "Rebooting...";
          this.tag('Buttons').visible = false;
          this.tag('Info').visible = false;
        }
        _handleEnter() {
          // do nothing
        }
        _handleLeft() {
          // do nothing
        }
        _handleRight() {
          // do nothing
        }
        _handleBack() {
          // do nothing
        }
        _handleUp() {
          // do nothing
        }
        _handleDown() {
          // do nothing
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeZoneItem extends lng$1.Component {
    _construct() {
      this.Arrow = Utils.asset('/images/settings/Arrow.png');
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Right: {
          y: 45,
          x: 1600,
          mountX: 1,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Arrow, 45, 45),
          color: 0xffffffff
        },
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item[2]
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item[0],
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _handleEnter() {
      console.log('enter', this._item[1]);
      Router.navigate('settings/advanced/device/timezone/item', {
        time_region: this._item[1],
        zone: this._item[0],
        isActive: this.zone
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  class TimeZone$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Other Settings  Advanced Settings  Device  Time'));
    }

    /**
     * @param {object} args
     */
    set params(args) {
      if (args.refresh) {
        this._firstEnable();
      }
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: CONFIG.theme.background,
        TimeZone: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -1
          },
          Error: {
            alpha: 0,
            x: 560,
            y: 340,
            mountX: 0.5,
            MSG: {
              text: {
                text: 'TimeZone API not present',
                fontFace: CONFIG.language.font,
                fontSize: 40,
                textColor: 0xffffffff
              }
            }
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        }
      };
    }
    async _firstEnable() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.loadingAnimation.start();
      this.tag('Loader').visible = true;
      this.appApi = new AppApi();
      this.resp = await this.appApi.fetchTimeZone();
      let data = [];
      this.zone = await this.appApi.getZone();
      try {
        console.log(this.resp, this.zone);
        delete this.resp.Etc;
        for (const i in this.resp) {
          if (typeof this.resp[i] === 'object') {
            data.push([i, this.resp[i], this.zone !== undefined ? this.zone.split('/')[0] === i : false]);
          }
        }
      } catch (error) {
        console.log('no api present', error);
      }
      console.log(data);
      if (data.length > 1) {
        this.tag('List').h = data.length * 90;
        this.tag('List').items = data.map((item, idx) => {
          return {
            ref: 'Time' + idx,
            w: 1620,
            h: 90,
            type: TimeZoneItem,
            item: item,
            zone: this.zone !== undefined ? this.zone.split('/')[1] : ''
          };
        });
      } else {
        this.tag('Error').alpha = 1;
      }
      this.loadingAnimation.stop();
      this.tag('Loader').visible = false;
    }
    _getFocused() {
      return this.tag('List').element;
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
      }
    }
    _handleDown() {
      this.tag('List').setNext();
    }
    _handleUp() {
      this.tag('List').setPrevious();
    }
    _handleBack() {
      Router.navigate('settings/advanced/device');
    }
    static _states() {
      return [];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item[1]
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item[0],
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeItems extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: CONFIG.theme.background,
        Time: {
          x: 200,
          y: 185,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            itemScrollOffset: -2
          }
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set params(item) {
      console.log(item);
      this._item = item;
      this.tag('List').h = Object.keys(item.time_region).length * 90;
      this.tag('List').items = Object.keys(item.time_region).map((ele, idx) => {
        return {
          ref: 'Time' + idx,
          w: 1620,
          h: 90,
          type: TimeItem,
          item: [ele, ele === item.isActive]
        };
      });
    }
    _init() {
      this.appApi = new AppApi();
    }
    _handleDown() {
      this.tag('List').setNext();
    }
    _handleUp() {
      this.tag('List').setPrevious();
    }
    _handleEnter() {
      console.log("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      this.widgets.menu.updateTimeZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      this.appApi.setZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      Router.navigate('settings/advanced/device/timezone', {
        refresh: true
      });
    }
    _getFocused() {
      return this.tag('List').element;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var otherSettingsRoutes = {
    otherSettingsRoutes: [{
      path: 'settings/other',
      component: OtherSettingsScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/other/timer',
      component: SleepTimerScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/other/energy',
      component: EnergySavingsScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/other/language',
      component: LanguageScreen$2,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/other/privacy',
      component: PrivacyScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/other/privacyPolicy',
      component: PrivacyPolicyScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/advanced',
      component: AdvanceSettingsScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/advanced/device',
      component: DeviceScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/advanced/device/info',
      component: DeviceInformationScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/advanced/device/timezone',
      component: TimeZone$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/advanced/device/timezone/item',
      component: TimeItems,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/advanced/device/firmware',
      component: FirmwareScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/advanced/device/reboot',
      component: RebootConfirmationScreen
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Audio screen.
   */

  class AudioScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Audio'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        Wrapper: {
          x: 200,
          y: 275,
          AudioOutput: {
            alpha: 0.3,
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Audio Output: ') + " HDMI",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputMode: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Output Mode: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          DynamicRange: {
            alpha: 0.3,
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Full Dynamic Range'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AudioLanguage: {
            y: 270,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Audio Language: ') + "Auto",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NavigationFeedback: {
            y: 360,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Navigation Feedback'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 66,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOnWhite.png')
            }
          },
          Bluetooth: {
            alpha: 0.3,
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Bluetooth: ') + "None",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this.appApi = new AppApi();
      this._setState('OutputMode');
    }
    _focus() {
      this._setState(this.state);
      this.appApi.getSoundMode().then(result => {
        this.tag('OutputMode.Title').text.text = Language.translate('Output Mode: ') + result.soundMode;
      });
    }
    hide() {
      this.tag('Wrapper').visible = false;
    }
    show() {
      this.tag('Wrapper').visible = true;
    }
    _handleBack() {
      Router.navigate('settings');
    }
    static _states() {
      return [class AudioOutput extends this {
        $enter() {
          this.tag('AudioOutput')._focus();
        }
        $exit() {
          this.tag('AudioOutput')._unfocus();
        }
        _handleDown() {
          this._setState('OutputMode');
        }
        _handleEnter() {
          Router.navigate('settings/audio/output');
        }
      }, class OutputMode extends this {
        $enter() {
          this.tag('OutputMode')._focus();
        }
        $exit() {
          this.tag('OutputMode')._unfocus();
        }
        _handleUp() {
          // this._setState('AudioOutput')
        }
        _handleDown() {
          // this._setState('DynamicRange');
        }
        _handleEnter() {
          Router.navigate('settings/audio/output');
        }
      }, class DynamicRange extends this {
        $enter() {
          this.tag('DynamicRange')._focus();
        }
        $exit() {
          this.tag('DynamicRange')._unfocus();
        }
        _handleUp() {
          this._setState('OutputMode');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          /**
           * This handle Enter has api calls -
           * 1 - get DRC Mode which doesnot return a drc mode and the success value is mostly false
           * 2- set Volume - able to set the value to 100
           * 3- get Volume - able to get the volume successfully as well
           * 4- 
           * 
           */
          //console.log(`Enter input was given to dynamic range ... `);
          // gets the drc mode
          this.appApi.getDRCMode().then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.setVolumeLevel("HDMI0", 100).then(res => {
            this.appApi.getVolumeLevel().catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
          this.appApi.getConnectedAudioPorts().then(res => {}).catch(err => {
            console.log(err);
          });
          // gets the enabled Audio Port
          this.appApi.getEnableAudioPort("HDMI0").then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.getSupportedAudioPorts().catch(err => {
            console.log("Error while getting the supported Audio ports ie. ".concat(err));
          });

          // set enable Audio POrt
          this.appApi.setEnableAudioPort("HDMI0").then(res => {
            this.appApi.getEnableAudioPort("HDMI0").then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });

          // set zoom setting ,possible values : FULL, NONE, Letterbox 16x9, Letterbox 14x9, CCO, PanScan, Letterbox 2.21 on 4x3, Letterbox 2.21 on 16x9, Platform, Zoom 16x9, Pillarbox 4x3, Widescreen 4x3
          this.appApi.setZoomSetting("FULL").then(res => {
            this.appApi.getZoomSetting().then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
        }
      }, class NavigationFeedback extends this {
        $enter() {
          this.tag('NavigationFeedback')._focus();
        }
        $exit() {
          this.tag('NavigationFeedback')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          //
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag('Bluetooth')._focus();
        }
        $exit() {
          this.tag('Bluetooth')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class VideoAndAudioItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90,
          rect: true,
          color: 0x00000000
        },
        BottomLine: {
          y: 0 + 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {
      if (this.isTicked) {
        this.fireAncestors("$resetPrevTickObject", this);
      }
      this.appApi = new AppApi();
    }
    _handleEnter() {
      if (this.videoElement === true) {
        this.appApi.setResolution(this._item).catch(err => {
          console.log("there was an error while setting the resolution.");
        });
      } else {
        this.appApi.setSoundMode(this._item).then(result => {
          if (result.success === true) {
            this.fireAncestors("$resetPrevTickObject", this);
            this.tag("Item.Tick").visible = true;
            // this.tag('HdmiAudioOutputStereo.Title').text.text = 'HdmiAudioOutputStereo: ' + soundMode
          }
          //this.tag('HdmiAudioOutputStereo.Title').text.text = 'HdmiAudioOutputStereo: ' + result.soundMode
          this.fireAncestors("$updateSoundMode", this._item);
        }).catch(err => {
          console.log('Some error while setting the sound mode ', err);
        });
      }
    }
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: this.isTicked ? true : false //implement the logic to show the tick
        },

        Left: {
          x: 50,
          y: 45,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: 0xffFFFFFF,
            fontFace: CONFIG.language.font
          } // update the text
        }
      });
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for HDMI Output Screen.
   */
  var appApi$7 = new AppApi();
  class HdmiOutputScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Audio  Output Mode'));
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xCC000000,
        HdmiOutputScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _init() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this.loadingAnimation.start();
      var options = [];
      appApi$7.getSoundMode().then(result => {
        appApi$7.getSupportedAudioModes().then(res => {
          options = [...res.supportedAudioModes];
          this.tag('HdmiOutputScreenContents').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').items = options.map((item, index) => {
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: result.soundMode === item ? true : false,
              item: item,
              videoElement: false
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this._setState("Options");
        }).catch(err => {
          console.log('error', err);
        });
      }).catch(err => {
        console.log('error', JSON.stringify(err));
      });
    }
    _handleBack() {
      Router.navigate('settings/audio');
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('HdmiOutputScreenContents.List').element;
        }
        _handleDown() {
          this.tag('HdmiOutputScreenContents.List').setNext();
        }
        _handleUp() {
          this.tag('HdmiOutputScreenContents.List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$8 = thunderJS({
    host: '127.0.0.1',
    port: 9998,
    default: 1
  });

  /**
   * Class for Resolution Screen.
   */

  class ResolutionScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Video  Resolution'));
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xCC000000,
        ResolutionScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.appApi.activateDisplaySettings();
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      thunder$8.on('org.rdk.DisplaySettings', 'resolutionChanged', notification => {
        const items = this.tag('List').items;
        items.forEach(element => {
          element.tag('Item.Tick').visible = false;
          if (element._item === notification.resolution) {
            element.tag('Item.Tick').visible = true;
          }
        });
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _handleBack() {
      Router.navigate('settings/video');
    }
    _focus() {
      this.loadingAnimation.start();
      var options = [];
      var sIndex = 0;
      this.appApi.getResolution().then(resolution => {
        this.appApi.getSupportedResolutions().then(res => {
          options = [...res];
          this.tag('ResolutionScreenContents').h = options.length * 90;
          this.tag('ResolutionScreenContents.List').h = options.length * 90;
          this.tag('List').items = options.map((item, index) => {
            var bool = false;
            if (resolution === item) {
              bool = true;
              sIndex = index;
            }
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: bool,
              item: item,
              videoElement: true
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this.tag('List').setIndex(sIndex);
          this._setState("Options");
        }).catch(err => {
          console.log("error while fetching the supported resolution ".concat(err));
        });
      });
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video screen.
   */

  class VideoScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings  Video'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        VideoScreenContents: {
          x: 200,
          y: 275,
          Resolution: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Resolution: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDR: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('High Dynamic Range: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MatchContent: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Match Content: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputFormat: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Output Format:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Chroma: {
            alpha: 0.3,
            // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Chroma:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDCP: {
            y: 450,
            h: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('HDCP Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('Resolution');
    }
    _focus() {
      this._appApi.getResolution().then(resolution => {
        this.tag("Resolution.Title").text.text = Language.translate('Resolution: ') + resolution;
      }).catch(err => {
        console.log("Error fetching the Resolution");
      });
      this._appApi.getHDCPStatus().then(result => {
        if (result.isHDCPCompliant && result.isHDCPEnabled) {
          this.tag("HDCP.Title").text.text = "".concat(Language.translate('HDCP Status: '), "Enabled, Version: ").concat(result.currentHDCPVersion);
        } else {
          this.tag("HDCP.Title").text.text = "".concat(Language.translate('HDCP Status: '), "Not Supported ");
        }
      });
      this._appApi.getHDRSetting().then(result => {
        const availableHDROptions = {
          "HdrOff": "Off",
          "Hdr10": "HDR 10",
          "Hdr10Plus": "HDR 10+",
          "HdrHlg": "HLG",
          "HdrDolbyvision": "Dolby Vision",
          "HdrTechnicolor": "Technicolor HDR"
        };
        this.tag("HDR.Title").text.text = Language.translate('High Dynamic Range: ') + availableHDROptions[result];
      });
      this._setState(this.state);
    }
    _handleBack() {
      Router.navigate('settings');
    }
    static _states() {
      return [class Resolution extends this {
        $enter() {
          this.tag('Resolution')._focus();
        }
        $exit() {
          this.tag('Resolution')._unfocus();
        }
        _handleDown() {
          this._setState('HDR');
        }
        _handleEnter() {
          Router.navigate('settings/video/resolution');
        }
      }, class HDR extends this {
        $enter() {
          this.tag('HDR')._focus();
        }
        $exit() {
          this.tag('HDR')._unfocus();
        }
        _handleUp() {
          this._setState('Resolution');
        }
        _handleDown() {
          this._setState('HDCP');
        }
      }, class MatchContent extends this {
        $enter() {
          this.tag('MatchContent')._focus();
        }
        $exit() {
          this.tag('MatchContent')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleDown() {
          this._setState('OutputFormat');
        }
        _handleEnter() {
          //
        }
      }, class OutputFormat extends this {
        $enter() {
          this.tag('OutputFormat')._focus();
        }
        $exit() {
          this.tag('OutputFormat')._unfocus();
        }
        _handleUp() {
          this._setState('MatchContent');
        }
        _handleDown() {
          this._setState('Chroma');
        }
        _handleEnter() {
          //
        }
      }, class Chroma extends this {
        $enter() {
          this.tag('Chroma')._focus();
        }
        $exit() {
          this.tag('Chroma')._unfocus();
        }
        _handleUp() {
          this._setState('OutputFormat');
        }
        _handleDown() {
          // this._setState('HDCP') 
        }
        _handleEnter() {
          //
        }
      }, class HDCP extends this {
        // class not required
        $enter() {
          this.tag('HDCP')._focus();
        }
        $exit() {
          this.tag('HDCP')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleEnter() {
          //
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var audioScreenRoutes = {
    audioScreenRoutes: [{
      path: 'settings/audio',
      component: AudioScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/audio/output',
      component: HdmiOutputScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/video',
      component: VideoScreen$1,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'settings/video/resolution',
      component: ResolutionScreen$1,
      widgets: ['Menu', 'Volume']
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const errorTitle$1 = 'Error Title';
  const errorMsg$1 = 'Error Message';
  class Failscreen extends lng$1.Component {
    notify(args) {
      console.log(args);
      if (args.title && args.msg) {
        this.tag('FailScreen.Title').text.text = args.title;
        this.tag('FailScreen.Message').text.text = Language.translate(args.msg);
      }
    }
    pageTransition() {
      return 'left';
    }
    _focus() {
      this.alpha = 1;
    }
    _unfocus() {
      this.alpha = 0;
      this.tag('FailScreen.Title').text.text = errorTitle$1;
      this.tag('FailScreen.Message').text.text = errorMsg$1;
    }
    static _template() {
      return {
        alpha: 0,
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xff000000,
        FailScreen: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: errorTitle$1,
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Message: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: errorMsg$1,
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          RectangleDefault: {
            x: 0,
            y: 200,
            w: 200,
            mountX: 0.5,
            h: 50,
            rect: true,
            color: CONFIG.theme.hex,
            Ok: {
              x: 100,
              y: 25,
              mount: 0.5,
              text: {
                text: Language.translate("OK"),
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    set item(error) {
      this.tag('Pairing').text = error;
    }
    _handleEnter() {
      Router.focusPage();
    }
    _handleBack() {
      Router.focusPage();
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in main view.
   */
  class UsbListItem extends lng$1.Component {
    /**
     * Function to render various elements in the main view item.
     */
    static _template() {
      return {
        Item: {
          Shadow: {
            alpha: 0
          },
          y: 20,
          Image: {},
          Info: {}
        }
      };
    }
    _init() {
      this.tag('Shadow').patch({
        color: CONFIG.theme.hex,
        rect: true,
        h: this.h + 24,
        w: this.w,
        x: this.x,
        y: this.y - 12
      });
      if (this.data.url.startsWith('/images')) {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: Utils.asset(this.data.url),
          scale: this.unfocus
        });
      } else {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: this.data.url
        });
      }

      /* Used static data for develpment purpose ,
      it wil replaced with Dynamic data once implimetation is completed.*/
      this.tag('Info').patch({
        x: this.x - 20,
        y: this.y + this.h + 10,
        w: this.w,
        h: 140,
        alpha: 0,
        PlayIcon: {
          Label: {
            x: this.idx === 0 ? this.x + 20 : this.x + 10,
            y: this.y + 10,
            text: {
              fontFace: CONFIG.language.font,
              text: this.data.displayName,
              fontSize: 20,
              maxLines: 2,
              wordWrapWidth: this.w
            }
          }
        }
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        zIndex: 1,
        scale: this.focus
      });
      this.tag('Info').alpha = 1;
      this.tag('Item').patch({
        zIndex: 2
      });
      this.tag('Shadow').patch({
        scale: this.focus,
        alpha: 1
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus
      });
      this.tag('Item').patch({
        zIndex: 0
      });
      this.tag('Info').alpha = 0;
      this.tag('Shadow').patch({
        alpha: 0
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var usbApi = new UsbApi();
  class UsbAppsScreen extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText('USB');
    }
    static _template() {
      return {
        UsbAppsScreenContents: {
          rect: true,
          color: 0xff000000,
          x: 200,
          y: 270,
          w: 1765,
          h: 1250,
          clipping: true,
          Wrapper: {
            x: 0,
            w: 1765,
            h: 1250,
            clipping: true,
            Text1: {
              y: 0,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: "Videos",
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row1: {
              y: 30,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: lng$1.components.ListComponent,
              w: 1745,
              h: 300,
              itemSize: 277,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            },
            Text2: {
              // x: 10 + 25,
              y: 243,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: "Audio",
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row2: {
              y: 273,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: lng$1.components.ListComponent,
              w: 1745,
              h: 300,
              itemSize: 171,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            },
            Text3: {
              // x: 10 + 25,
              y: 486,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: "Photos",
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row3: {
              y: 516,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: lng$1.components.ListComponent,
              w: 1745,
              h: 400,
              itemSize: 165,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            },
            Text4: {
              // x: 10 + 25,
              y: 729,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: "Folders",
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row4: {
              y: 759,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: lng$1.components.ListComponent,
              w: 1745,
              h: 400,
              itemSize: 165,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            }
          },
          NoUSB: {
            x: 0,
            w: 1765,
            h: 800,
            clipping: true,
            visible: false,
            Image: {
              x: 800,
              y: 400,
              mount: 0.5,
              texture: {
                type: lng$1.textures.ImageTexture,
                src: 'static/images/usb/Unsupported_file_640x360.jpg',
                resizeMode: {
                  type: 'contain',
                  w: 640,
                  h: 360
                }
              }
            }
          }
        },
        AudioInfo: {
          zIndex: 2,
          visible: false,
          h: 1080,
          w: 1920,
          // x: -200,
          // y: -286,
          Image: {
            scale: 0.5,
            x: 960,
            y: 560,
            mount: 0.5,
            texture: {
              type: lng$1.textures.ImageTexture,
              src: 'static/images/Media Player/Audio_Background_16k.jpg'
            }
          },
          Title: {
            x: 960,
            y: 900,
            mount: 0.5,
            text: {
              fontFace: CONFIG.language.font,
              text: 'file_name.mp3',
              fontSize: 35
            }
          }
        },
        PlayerControls: {
          type: LightningPlayerControls,
          y: 810,
          alpha: 0,
          signals: {
            pause: 'pause',
            play: 'play',
            hide: 'hidePlayerControls',
            fastfwd: 'fastfwd',
            fastrwd: 'fastrwd'
          },
          zIndex: 4
        }
      };
    }
    _handleBack() {
      if (!(this.cwd.length === 0)) {
        let clone = [...this.cwd];
        clone.pop();
        let cwdname = clone.join("/");
        usbApi.cd(cwdname).then(res => {
          this.cwd.pop();
          this.loadData();
        }).catch(err => {
          console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
        });
      } else {
        Router.navigate('menu');
      }
    }
    reset() {
      for (let i = this.tag('Row1').index; i > 0; i--) {
        this.tag('Row1').setPrevious();
      }
      for (let i = this.tag('Row2').index; i > 0; i--) {
        this.tag('Row2').setPrevious();
      }
      for (let i = this.tag("Row3").index; i > 0; i--) {
        this.tag('Row3').setPrevious();
      }
      for (let i = this.tag("Row3").index; i > 0; i--) {
        this.tag('Row4').setPrevious();
      }
    }
    hide() {
      this.tag('UsbAppsScreenContents').visible = false;
      this.fireAncestors('$hideAllforVideo');
    }
    show() {
      this.tag('UsbAppsScreenContents').visible = true;
      this.fireAncestors('$showAllforVideo');
    }
    traverseMinus() {
      this.index = (this.traversableRows.length + --this.index) % this.traversableRows.length;
      this._setState(this.traversableRows[this.index]);
    }
    traversePlus() {
      this.index = ++this.index % this.traversableRows.length;
      this._setState(this.traversableRows[this.index]);
    }
    static _states() {
      return [class Video extends this {
        $enter() {
          this.scroll(0);
        }
        _getFocused() {
          this.tag('Text1').text.fontStyle = 'bold';
          if (this.tag('Row1').length) {
            return this.tag('Row1').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleRight() {
          if (this.tag('Row1').length - 1 != this.tag('Row1').index) {
            this.tag('Row1').setNext();
            return this.tag('Row1').element;
          }
        }
        _handleEnter() {
          Router.navigate('usb/player', {
            url: this.tag('Row1').element.data.uri,
            currentIndex: this.tag('Row1').element.idx,
            list: this.tag('Row1').items,
            isUSB: true
          });
        }
        _handleLeft() {
          this.tag('Text1').text.fontStyle = 'normal';
          if (0 != this.tag('Row1').index) {
            this.tag('Row1').setPrevious();
            return this.tag('Row1').element;
          } else {
            this.reset();
          }
        }
      }, class Audio extends this {
        $enter() {
          this.scroll(0);
        }
        _getFocused() {
          this.tag('Text2').text.fontStyle = 'bold';
          if (this.tag('Row2').length) {
            return this.tag('Row2').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleEnter() {
          Router.navigate('usb/player', {
            url: this.tag('Row2').element.data.uri,
            isAudio: true,
            list: this.tag('Row2').items,
            currentIndex: this.tag('Row2').element.idx,
            isUSB: true
          });
        }
        _handleRight() {
          if (this.tag('Row2').length - 1 != this.tag('Row2').index) {
            this.tag('Row2').setNext();
            return this.tag('Row2').element;
          }
        }
        _handleLeft() {
          this.tag('Text2').text.fontStyle = 'normal';
          if (0 != this.tag('Row2').index) {
            this.tag('Row2').setPrevious();
            return this.tag('Row2').element;
          } else {
            this.reset();
          }
        }
      }, class Picture extends this {
        $enter() {
          this.scroll(0);
        }
        _getFocused() {
          this.tag('Text3').text.fontStyle = 'bold';
          if (this.tag('Row3').length) {
            return this.tag('Row3').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleEnter() {
          // console.log(this.tag('Row3').items)
          Router.navigate('usb/image', {
            src: this.tag('Row3').element.data.uri,
            currentIndex: this.tag('Row3').element.idx,
            list: this.tag('Row3').items,
            cwd: this.cwd
          });
        }
        _handleRight() {
          if (this.tag('Row3').length - 1 != this.tag('Row3').index) {
            this.tag('Row3').setNext();
            return this.tag('Row3').element;
          }
        }
        _handleLeft() {
          this.tag('Text3').text.fontStyle = 'normal';
          if (0 != this.tag('Row3').index) {
            this.tag('Row3').setPrevious();
            return this.tag('Row3').element;
          } else {
            this.reset();
          }
        }
      }, class Folder extends this {
        $enter() {
          if (this.traversableRows.length > 3) {
            this.scroll(-243);
          }
        }
        _getFocused() {
          this.tag('Text4').text.fontStyle = 'bold';
          if (this.tag('Row4').length) {
            return this.tag('Row4').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleEnter() {
          //do something after folder click.
          let dname = this.cwd.join("/") + "/" + this.tag('Row4').element.data.displayName;
          usbApi.cd(dname).then(res => {
            this.cwd.push(this.tag('Row4').element.data.displayName);
            // console.log(`loading the data from the directory ${this.cwd}

            // and its data = music:${JSON.stringify(musicListInfo)}

            // Pictures : ${JSON.stringify(imageListInfo)}

            // videos : ${JSON.stringify(videoListInfo)}

            // folders : ${JSON.stringify(UsbInnerFolderListInfo)}

            // `);
            this.loadData();
          }).catch(err => {
            console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
          });
        }
        _handleRight() {
          if (this.tag('Row4').length - 1 != this.tag('Row4').index) {
            this.tag('Row4').setNext();
            return this.tag('Row4').element;
          }
        }
        _handleLeft() {
          this.tag('Text4').text.fontStyle = 'normal';
          if (0 != this.tag('Row4').index) {
            this.tag('Row4').setPrevious();
            return this.tag('Row4').element;
          } else {
            this.reset();
          }
        }
      }];
    }
    set params(args) {
      this.currentIndex = args.currentIndex;
      this.thisDir = args.cwd;
    }
    set Row1Items(items) {
      this.tag('Row1').items = items.map((info, idx) => {
        return {
          w: 257,
          h: 145,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row1').start();
    }
    set Row2Items(items) {
      this.tag('Row2').items = items.map((info, idx) => {
        return {
          w: 151,
          h: 151,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row2').start();
    }
    set Row3Items(items) {
      this.tag('Row3').items = items.map((info, idx) => {
        return {
          w: 145,
          h: 145,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row3').start();
    }
    set Row4Items(items) {
      this.tag('Row4').items = items.map((info, idx) => {
        return {
          w: 145,
          h: 145,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row4').start();
    }
    scroll(y) {
      this.tag('Wrapper').setSmooth('y', y, {
        duration: 0.5
      });
    }
    loadData() {
      // console.log(`loading data from the directory ${this.cwd}`);
      let sumY = 0;
      this.index = 0;
      this.traversableRows = [];
      this.Row1Items = videoListInfo;
      this.Row2Items = musicListInfo;
      this.Row3Items = imageListInfo;
      this.Row4Items = UsbInnerFolderListInfo;
      let text1 = this.tag("Text1");
      let row1 = this.tag('Row1');
      let text2 = this.tag("Text2");
      let row2 = this.tag('Row2');
      let text3 = this.tag("Text3");
      let row3 = this.tag('Row3');
      let text4 = this.tag('Text4');
      let row4 = this.tag('Row4');
      if (videoListInfo.length === 0 && musicListInfo.length === 0 && imageListInfo.length === 0 && UsbInnerFolderListInfo.length === 0) {
        this.tag('NoUSB').visible = true;
        text1.visible = false;
        row1.visible = false;
        text2.visible = false;
        row2.visible = false;
        text3.visible = false;
        row3.visible = false;
        text4.visible = false;
        row4.visible = false;
        //either the usb is not mounted or there aren't any videos , images or audio files. 
      } else {
        this.tag('NoUSB').visible = false;
        if (videoListInfo.length === 0) {
          text1.visible = false;
          row1.visible = false;
        } else {
          this.traversableRows.push("Video");
          text1.visible = true;
          row1.visible = true;
          text1.y = sumY;
          row1.y = sumY + 30;
          sumY += 243;
        }
        if (musicListInfo.length === 0) {
          text2.visible = false;
          row2.visible = false;
        } else {
          this.traversableRows.push("Audio");
          text2.visible = true;
          row2.visible = true;
          text2.y = sumY;
          row2.y = sumY + 30;
          sumY += 243;
        }
        if (imageListInfo.length === 0) {
          text3.visible = false;
          row3.visible = false;
        } else {
          this.traversableRows.push("Picture");
          text3.visible = true;
          row3.visible = true;
          text3.y = sumY;
          row3.y = sumY + 30;
          sumY += 243;
        }
        if (UsbInnerFolderListInfo.length === 0) {
          text4.visible = false;
          row4.visible = false;
        } else {
          this.traversableRows.push("Folder");
          text4.visible = true;
          row4.visible = true;
          text4.y = sumY;
          row4.y = sumY + 30;
          sumY += 243;
        }
        this._setState(this.traversableRows[0]);
      }
    }
    _focus() {
      if (this.thisDir) {
        if (this.thisDir.length > 0) {
          this.cwd = [...this.thisDir];
          let dname = this.cwd.join("/");
          usbApi.cd(dname).then(res => {
            this.loadData();
            this._setState(this.traversableRows[this.index] + ".".concat(this.currentIndex)); //focus on first element
          }).catch(err => {
            console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
          });
        }
      } else {
        this.index = 0;
        this.traversableRows = [];
        this.cwd = [];
        usbApi.retrieUsb().then(res => {
          this.loadData();
          this._setState(this.traversableRows[this.index]);
        }).catch(err => {
          console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
        });
      }
      // this._setState(this.traversableRows[this.index])
    }

    _unfocus() {
      //this.exitFunctionality()
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const defaultImage = 'static/images/usb/USB_Photo_Placeholder.jpg';
  class ImageViewer extends lng$1.Component {
    set params(args) {
      this.currentIndex = args.currentIndex;
      this.data = args.list;
      this.cwd = args.cwd;
      if (this.data != undefined && this.data.length > 1) {
        this.tag('Controls').alpha = 1;
      } else {
        this.tag('Controls').alpha = 0;
      }
      if (args.src) {
        this.tag('Image').texture.src = args.src;
      }
    }
    _handleRight() {
      if (this.data[this.currentIndex + 1]) {
        this.currentIndex += 1;
        this.tag('Image').texture.src = this.data[this.currentIndex].data.uri;
      }
    }
    _handleLeft() {
      if (this.data[this.currentIndex - 1]) {
        this.currentIndex -= 1;
        this.tag('Image').texture.src = this.data[this.currentIndex].data.uri;
      }
    }
    _handleBack() {
      if (this.cwd) {
        Router.navigate('usb', {
          currentIndex: this.currentIndex,
          cwd: this.cwd
        });
      } else {
        Router.back();
      }
    }
    _unfocus() {
      this.tag('Image').texture.src = defaultImage;
    }
    static _template() {
      return {
        h: 1080,
        w: 1920,
        rect: true,
        color: 0xff000000,
        zIndex: 2,
        visible: false,
        Image: {
          x: 960,
          y: 540,
          mount: 0.5,
          texture: {
            type: lng$1.textures.ImageTexture,
            src: defaultImage,
            resizeMode: {
              type: 'contain',
              w: 1920,
              h: 1080
            }
          }
        },
        Controls: {
          x: 960,
          y: 930,
          h: 75,
          w: 100,
          Previous: {
            x: -50,
            w: 75,
            h: 75,
            mount: 0.5,
            texture: {
              type: lng$1.textures.ImageTexture,
              src: 'static/images/Media Player/Icon_Back_White_16k.png'
            }
          },
          Next: {
            x: 50,
            w: 75,
            h: 75,
            mount: 0.5,
            texture: {
              type: lng$1.textures.ImageTexture,
              src: 'static/images/Media Player/Icon_Next_White_16k.png'
            }
          }
        }
      };
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class LogoScreen extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        Logo: {
          mount: 0.5,
          x: 960,
          y: 540,
          src: Utils.asset('/images/splash/RDKLogo.png')
        },
        Sub: {
          mountY: 1,
          mountX: 0.5,
          x: 960,
          y: 1000,
          w: 216,
          h: 121,
          src: Utils.asset('/images/splash/gracenote.png')
        }
      };
    }
    pageTransition() {
      return 'right';
    }
    _init() {
      this.btApi = new BluetoothApi();
    }
    checkPath(path) {
      if (path === 'ui') {
        return 'ui';
      }
      return 'menu';
    }
    _firstEnable() {
      console.timeEnd('PerformanceTest');
      console.log('Splash Screen timer end - ', new Date().toUTCString());
    }
    _focus() {
      let path = 'splash/bluetooth';
      var map = {
        37: false,
        38: false,
        39: false,
        40: false
      };
      this.handler = e => {
        if (e.keyCode in map) {
          map[e.keyCode] = true;
          if (map[37] && map[38] && map[39] && map[40]) {
            path = 'ui';
          }
        }
      };
      Registry.addEventListener(document, 'keydown', this.handler);
      this.btApi.getPairedDevices().then(devices => {
        console.log(devices);
        if (devices.length > 0 || Storage.get('setup')) {
          path = this.checkPath(path);
        }
      }).catch(() => {
        console.log('Paired Device Error');
        path = this.checkPath(path);
      });
      setTimeout(() => {
        Router.navigate(path);
      }, 5000);
    }
    _unfocus() {
      Registry.removeEventListener(document, 'keydown', this.handler);
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var appApi$6 = new AppApi();
  var bluetoothApi = new BluetoothApi();
  const config$7 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  const _thunder = thunderJS(config$7);
  class BluetoothScreen$1 extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Bluetooth: {
          x: 960,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: "Pairing Your Remote",
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex,
              fontStyle: 'bold'
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 135,
            mountX: 0.5,
            text: {
              text: "Please put the remote in pairing mode, scanning will start in a minute.",
              fontFace: CONFIG.language.font,
              fontSize: 25
            },
            visible: true
          },
          Timer: {
            x: 0,
            y: 200,
            mountX: 0.5,
            text: {
              text: "0:10",
              fontFace: CONFIG.language.font,
              fontSize: 80
            },
            visible: true
          },
          Loader: {
            x: 0,
            y: 200,
            mountX: 0.5,
            w: 110,
            h: 110,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          },
          Buttons: {
            Continue: {
              x: 0,
              y: 210,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: "Continue Setup",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: false
            }
          },
          BorderBottom: {
            x: 0,
            y: 350,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _PairingApis() {
      //bluetoothApi.btactivate().then(enableResult =>{
      //  console.log('1')
      bluetoothApi.enable().then(res => {
        console.log("1.5 enable result: ", res);
        bluetoothApi.startScanBluetooth().then(startScanresult => {
          console.log('2: ', startScanresult);
          var SubscribeEvent = _thunder.on('org.rdk.Bluetooth', 'onDiscoveredDevice', notification => {
            bluetoothApi.getDiscoveredDevices().then(getdocoveredInfo => {
              console.log('onDiscoveredDevice', getdocoveredInfo[0].name);
              this.tag('Info').text.text = "pairing this device ".concat(getdocoveredInfo[0].name);
              bluetoothApi.connect(getdocoveredInfo[0].deviceID, getdocoveredInfo[0].deviceType).then(connectresult => {
                console.log("connectresult", connectresult);
                bluetoothApi.pair(getdocoveredInfo[0].deviceID).then(Pairresult => {
                  console.log("Pairresult", Pairresult);
                  bluetoothApi.getConnectedDevices().then(getCdresult => {
                    console.log("getConnectedDevices", getCdresult);
                    bluetoothApi.getPairedDevices().then(getpairedDevices => {
                      console.log("getpairedDevices", getpairedDevices);
                      bluetoothApi.stopScan().then(stopScan => {
                        console.log("stopscan", stopScan);
                        SubscribeEvent.dispose();
                        //bluetoothApi.disable().then(disable =>{
                        //console.log("disable")
                        bluetoothApi.deactivateBluetooth().then(deactivateBluetooth => {
                          console.log("DeactivatedBluetooth", deactivateBluetooth);
                          Router.navigate('splash/language');
                        });
                      }).catch(err => {
                        console.error("cant stopscan device : ".concat(JSON.stringify(err)));
                      });
                    }).catch(err => {
                      console.error("cant getpaired device : ".concat(JSON.stringify(err)));
                    });
                  }).catch(err => {
                    console.error("Can't getconnected device : ".concat(JSON.stringify(err)));
                  });
                }).catch(err => {
                  console.error("Can't pair device : ".concat(JSON.stringify(err)));
                });
              }).catch(err => {
                console.error("Can't connect : ".concat(JSON.stringify(err)));
              });
            });
            // })
          });
        }).catch(err => {
          console.error("Can't scan enable : ".concat(JSON.stringify(err)));
        });
      });
    }
    _firstEnable() {
      console.log("checking");
      appApi$6.getPluginStatus('org.rdk.RemoteControl').then(result => {
        appApi$6.activateAutoPairing().then(result => {
          console.log("paired devices result", result);
          //this.initTimer();
          Router.navigate('splash/language');
        });
      }).catch(err => {
        console.log(' remote autoPair plugin error:', JSON.stringify(err));
        appApi$6.getPluginStatusParams('org.rdk.Bluetooth').then(pluginresult => {
          console.log("status", pluginresult[1]);
          if (pluginresult[1] === 'deactivated') {
            bluetoothApi.btactivate().then(result => {
              console.log("pairing bluetooth");
              this._PairingApis();
            });
          } else {
            this._PairingApis();
          }
        });
      });
    }
    _focus() {
      this.initTimer();
    }
    pageTransition() {
      return 'left';
    }
    _unfocus() {
      if (this.timeInterval) {
        Registry.clearInterval(this.timeInterval);
      }
      //this.tag('Timer').text.text = '0:10'
    }

    getTimeRemaining(endtime) {
      const total = Date.parse(endtime) - Date.parse(new Date());
      const seconds = Math.floor(total / 1000 % 60);
      return {
        total,
        seconds
      };
    }
    initTimer() {
      const endTime = new Date(Date.parse(new Date()) + 10000);
      const timerText = this.tag('Timer');
      this.timeInterval = Registry.setInterval(() => {
        const time = this.getTimeRemaining(endTime);
        timerText.text.text = "0:0".concat(time.seconds);
        if (time.total <= 0) {
          Registry.clearInterval(this.timeInterval);
          // Router.navigate('splash/language')
        }
      }, 1000);
    }
    static _states() {
      return [class RemotePair extends this {
        $enter() {
          this.tag('Timer').visible = true;
          this.tag('Info').text.text = 'Please put the remote in pairing mode, scanning will start in a minute.';
        }
        _handleRight() {
          this._setState('Scanning');
        }
        $exit() {
          this.tag('Timer').visible = false;
          this.tag('Info').text.text = '';
        }
      }, class Scanning extends this {
        $enter() {
          this.tag('Loader').visible = true;
          this.tag('Info').text.text = 'Scanning';
        }
        _handleRight() {
          this._setState('PairComplete');
        }
        _handleLeft() {
          this._setState('RemotePair');
        }
        $exit() {
          this.tag('Loader').visible = false;
          this.tag('Info').text.text = '';
        }
      }, class PairComplete extends this {
        $enter() {
          this.tag('Buttons.Continue').visible = true;
          this.tag('Info').text.text = 'Pairing complete';
        }
        _handleLeft() {
          this._setState('Scanning');
        }
        _handleRight() {
          Router.navigate('splash/language');
        }
        $exit() {
          this.tag('Buttons.Continue').visible = false;
          this.tag('Info').text.text = '';
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$5 = new AppApi();
  const loader$1 = 'Loader';
  class LanguageScreen$1 extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Language: {
          x: 960,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language.translate("Language"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1600,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language.translate("Select a language"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          LanguageScreenContents: {
            x: 200 - 1000,
            y: 270,
            Languages: {
              flexItem: {
                margin: 0
              },
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            Continue: {
              x: 820,
              y: 250,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language.translate("Continue Setup"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: true
            }
          }
        }
      };
    }
    _init() {
      this._Languages = this.tag('LanguageScreenContents.Languages');
      this._Languages.h = availableLanguages.length * 90;
      this._Languages.tag('List').h = availableLanguages.length * 90;
      this._Languages.tag('List').items = availableLanguages.map((item, index) => {
        return {
          ref: 'Lng' + index,
          w: 1620,
          h: 90,
          type: LanguageItem,
          item: item
        };
      });
    }
    pageTransition() {
      return 'left';
    }
    _focus() {
      this._setState('Languages');
    }
    _handleBack() {}
    static _states() {
      return [class Languages extends this {
        $enter() {}
        _getFocused() {
          return this._Languages.tag('List').element;
        }
        _handleUp() {
          this._navigate('up');
        }
        _handleDown() {
          if (this._Languages.tag('List').index < availableLanguages.length - 1) {
            this._navigate('down');
          } else {
            this._setState('Continue');
          }
        }
        _handleEnter() {
          if (localStorage.getItem('Language') !== availableLanguages[this._Languages.tag('List').index]) {
            localStorage.setItem('Language', availableLanguages[this._Languages.tag('List').index]);
            let path = location.pathname.split('index.html')[0];
            let url = path.slice(-1) === '/' ? "static/loaderApp/index.html" : "/static/loaderApp/index.html";
            let notification_url = location.origin + path + url;
            console.log(notification_url);
            appApi$5.launchResident(notification_url, loader$1).catch(err => {});
            appApi$5.setVisibility('ResidentApp', false);
            location.reload();
          }
        }
      }, class Continue extends this {
        $enter() {
          this._focus();
        }
        _focus() {
          this.tag('Continue').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Continue.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Continue').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Continue.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        _handleUp() {
          this._setState('Languages');
        }
        _handleEnter() {
          Router.navigate('splash/network');
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
    _navigate(dir) {
      let list = this._Languages.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$3 = new Wifi();
  const network = new Network();
  class NetworkScreen extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Network: {
          x: 960,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language.translate("Network Configuration"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1600,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language.translate("Select a network interface"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          NetworkInterfaceList: {
            x: 200 - 1000,
            y: 270,
            WiFi: {
              y: 0,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate('WiFi'),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Ethernet: {
              y: 90,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate('Ethernet'),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Skip: {
              x: 820,
              y: 250,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language.translate("Skip"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: true
            }
          }
        }
      };
    }
    _init() {}
    pageTransition() {
      return 'left';
    }
    _focus() {
      Storage.set('setup', true);
      this._setState('WiFi');
    }
    static _states() {
      return [class WiFi extends this {
        $enter() {
          this.tag('WiFi')._focus();
        }
        $exit() {
          this.tag('WiFi')._unfocus();
        }
        _handleDown() {
          this._setState('Ethernet');
        }
        _handleEnter() {
          // this._setState('WiFiScreen')
          wifi$3.setInterface('WIFI', true).then(res => {
            if (res.success) {
              wifi$3.setDefaultInterface('WIFI', true).then(() => {
                Router.navigate('splash/networkList');
              });
            }
          });
          console.log("Wifi");
        }
      }, class Ethernet extends this {
        $enter() {
          this.tag('Ethernet')._focus();
        }
        $exit() {
          this.tag('Ethernet')._unfocus();
        }
        _handleEnter() {
          wifi$3.setInterface('ETHERNET', true).then(res => {
            if (res.success) {
              wifi$3.setDefaultInterface('ETHERNET', true).then(() => {
                network.getInterfaces().then(res => {
                  let eth = res.filter(item => item.interface == 'ETHERNET');
                  if (eth[0].interface == 'ETHERNET' && eth[0].enabled == true && eth[0].connected == true) {
                    Router.navigate('menu');
                  } else if (eth[0].interface == 'ETHERNET' && eth[0].connected == false) {
                    Router.navigate('splash/networkPrompt');
                  }
                });
              });
            }
          });
        }
        _handleDown() {
          this._setState('Skip');
        }
        _handleUp() {
          this._setState('WiFi');
        }
      }, class Skip extends this {
        $enter() {
          this._focus();
        }
        _focus() {
          this.tag('Skip').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Skip.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Skip').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Skip.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        _handleEnter() {
          Router.navigate('menu');
        }
        _handleUp() {
          this._setState('Ethernet');
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  new AppApi();
  /**
   * Class for Reboot Confirmation Screen.
   */
  class NetworkPromptScreen extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        PromptScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language.translate("Note"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 120,
            InfoTitle: {
              x: 0,
              y: 0,
              mountX: 0.5,
              text: {
                text: Language.translate("Ethernet cable is not connected"),
                fontFace: CONFIG.language.font,
                fontSize: 30
              }
            }
          },
          Buttons: {
            x: 200,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            TryAgain: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Try Again"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _focus() {
      this._setState('TryAgain');
    }
    _handleBack() {
      Router.navigate('splash/networkPrompt');
    }
    static _states() {
      return [class TryAgain extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          Router.navigate('splash/network');
        }
        _focus() {
          this.tag('TryAgain').patch({
            color: CONFIG.theme.hex
          });
          this.tag('TryAgain.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('TryAgain').patch({
            color: 0xFFFFFFFF
          });
          this.tag('TryAgain.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$2 = new Wifi();
  class NetworkList extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        NetworkList: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language.translate("Network Configuration"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1600,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language.translate("Select a wifi network"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Loader: {
            visible: false,
            h: 45,
            w: 45,
            x: 0,
            // x: 320,
            mountX: 1,
            y: 200,
            mountY: 0.5,
            src: Utils.asset('images/settings/Loading.png')
          },
          Networks: {
            x: -800,
            y: 340,
            flex: {
              direction: 'column'
            },
            PairedNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            AvailableNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            visible: false
          },
          JoinAnotherNetwork: {
            x: -800,
            y: 250,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Join Another Network'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        }
      };
    }
    pageTransition() {
      return 'left';
    }
    _firstEnable() {
      this.wifiLoading = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: Math.PI * 2
          }
        }]
      });
      this.onError = {
        0: 'SSID_CHANGED - The SSID of the network changed',
        1: 'CONNECTION_LOST - The connection to the network was lost',
        2: 'CONNECTION_FAILED - The connection failed for an unknown reason',
        3: 'CONNECTION_INTERRUPTED - The connection was interrupted',
        4: 'INVALID_CREDENTIALS - The connection failed due to invalid credentials',
        5: 'NO_SSID - The SSID does not exist',
        6: 'UNKNOWN - Any other error.'
      };
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this._wifi = new Wifi();
      this._network = new Network();
      this.wifiStatus = true;
      this._wifiIcon = true;
      this._activateWiFi();
      if (this.wiFiStatus) {
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
      }
      this._setState('JoinAnotherNetwork');
      this._network.activate().then(result => {
        if (result) {
          this._network.registerEvent('onIPAddressStatusChanged', notification => {
            console.log(JSON.stringify(notification));
            if (notification.status == 'ACQUIRED') ; else if (notification.status == 'LOST') {
              if (notification.interface === 'WIFI') {
                this._wifi.setInterface('ETHERNET', true).then(res => {
                  if (res.success) {
                    this._wifi.setDefaultInterface('ETHERNET', true);
                  }
                });
              }
            }
          });
          this._network.registerEvent('onDefaultInterfaceChanged', notification => {
            console.log(JSON.stringify(notification));
            if (notification.newInterfaceName === 'ETHERNET') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            } else if (notification.newInterfaceName == 'ETHERNET' || notification.oldInterfaceName == 'WIFI') {
              this._wifi.disconnect();
              this.wifiStatus = false;
              this.tag('Networks').visible = false;
              this.tag('JoinAnotherNetwork').visible = false;
              this.tag('Switch.Loader').visible = false;
              this.wifiLoading.stop();
              this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this._setState('Switch');
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            } else if (notification.newInterfaceName === "" && notification.oldInterfaceName === "WIFI") {
              console.log('emplty new old wifi');
              this._wifi.setDefaultInterface('ETHERNET', true);
            }
          });
          this._network.registerEvent('onConnectionStatusChanged', notification => {
            if (notification.interface === 'ETHERNET' && notification.status === 'CONNECTED') {
              this._wifi.setInterface('ETHERNET', true).then(res => {
                if (res.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
          });
        }
      });
    }

    /**
    * Function to be executed when the Wi-Fi screen is enabled.
    */
    _focus() {
      if (this.wifiStatus) {
        this._wifi.discoverSSIDs();
      }
    }

    /**
     * Function to be executed when the Wi-Fi screen is disabled.
     */
    _unfocus() {
      this._wifi.stopScan();
    }

    /**
     * Function to render list of Wi-Fi networks.
     */
    renderDeviceList(ssids) {
      this._wifi.getConnectedSSID().then(result => {
        if (result.ssid != '') {
          this._pairedList = [result];
        } else {
          this._pairedList = [];
        }
        this._pairedNetworks.h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
          item.connected = true;
          return {
            ref: 'Paired' + index,
            w: 1920 - 300,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
        this._otherList = ssids.filter(device => {
          result = this._pairedList.map(a => a.ssid);
          if (result.includes(device.ssid)) {
            return false;
          } else return device;
        });
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          item.connected = false;
          return {
            ref: 'Other' + index,
            w: 1620,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
      });
    }
    static _states() {
      return [class AvailableDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Loader').visible = false;
            this.wifiLoading.stop();
          }
        }
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          console.log(this._availableNetworks.tag('List').element._item);
          Router.navigate('settings/network/interface/wifi/connect', {
            wifiItem: this._availableNetworks.tag('List').element._item
          });
        }
      }, class JoinAnotherNetwork extends this {
        $enter() {
          this.tag('JoinAnotherNetwork')._focus();
        }
        _handleUp() {
          // this._setState('AvailableDevices')
        }
        _handleEnter() {
          if (this.wifiStatus) {
            Router.navigate('settings/network/interface/wifi/another');
          }
        }
        _handleDown() {
          this._setState('AvailableDevices');
        }
        $exit() {
          this.tag('JoinAnotherNetwork')._unfocus();
        }
      }];
    }

    /**
    * Function to navigate through the lists in the screen.
    * @param {string} listname
    * @param {string} dir
    */

    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          wifi$2.discoverSSIDs();
          this._setState('JoinAnotherNetwork');
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) {
            this._setState('AvailableDevices');
          }
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) {
            this._setState('PairedDevices');
          } else {
            this._setState('JoinAnotherNetwork');
          }
        }
      }
    }

    /**
    * Function to turn on and off Wi-Fi.
    */
    switch() {
      if (!this.wifiStatus) {
        this._wifi.disconnect();
        console.log('turning off wifi');
        this._wifi.setInterface('ETHERNET', true).then(result => {
          if (result.success) {
            this._wifi.setDefaultInterface('ETHERNET', true).then(result => {
              if (result.success) {
                this._wifi.disconnect();
                this.wifiStatus = false;
                this.tag('Networks').visible = false;
                this.tag('JoinAnotherNetwork').visible = false;
                this.tag('Loader').visible = false;
                this.wifiLoading.stop();
              }
            });
          }
        });
      } else {
        console.log('turning on wifi');
        //this.wifiStatus = true
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
        this.wifiLoading.play();
        this.tag('Loader').visible = true;
        this._wifi.discoverSSIDs();
      }
    }

    /**
    * Function to activate Wi-Fi plugin.
    */
    _activateWiFi() {
      this._wifi.activate().then(() => {
        this.switch();
      });
      this._wifi.registerEvent('onWIFIStateChanged', notification => {
        console.log(JSON.stringify(notification));
        if (notification.state === 5 && Router.getActiveRoute().includes('splash')) {
          Registry.setTimeout(() => {
            Router.navigate('menu');
          }, 2000);
        }
      });
      this._wifi.registerEvent('onError', notification => {
        this._wifi.discoverSSIDs();
        this._wifi.setInterface('ETHERNET', true).then(res => {
          if (res.success) {
            this._wifi.setDefaultInterface('ETHERNET', true);
          }
        });
      });
      this._wifi.registerEvent('onAvailableSSIDs', notification => {
        this.renderDeviceList(notification.ssids);
        if (!notification.moreData) {
          setTimeout(() => {
            this.tag('Loader').visible = false;
            this.wifiLoading.stop();
          }, 1000);
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var splashScreenRoutes = {
    splashScreenRoutes: [{
      path: 'splash',
      component: LogoScreen,
      widgets: ['Volume']
    }, {
      path: 'splash/bluetooth',
      component: BluetoothScreen$1,
      widgets: ['Volume']
    }, {
      path: 'splash/language',
      component: LanguageScreen$1,
      widgets: ['Volume']
    }, {
      path: 'splash/network',
      component: NetworkScreen,
      widgets: ['Volume']
    }, {
      path: 'splash/networkPrompt',
      component: NetworkPromptScreen,
      widgets: ['Volume']
    }, {
      path: 'splash/networkList',
      component: NetworkList,
      widgets: ['Volume']
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for rendering items in UI list.
   */
  class Item extends lng$1.Component {
    static _template() {
      return {
        Item: {
          w: 300,
          h: 150,
          rect: true,
          color: 0xFFDBEBFF,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 10
          }
        },
        OperatorLogo: {},
        Shadow: {
          alpha: 0,
          zIndex: 2,
          x: -25,
          y: -25,
          color: 0x66000000,
          texture: lng.Tools.getShadowRect(350, 180, 10, 10, 20)
        }
      };
    }

    /**
     * Function to set contents for an item in UI list.
     */
    set item(item) {
      this._item = item;
      this.tag('OperatorLogo').patch({
        Logo: {
          w: 300,
          h: 150,
          zIndex: 3,
          src: Utils.asset(this._item.url)
        }
      });
    }
    _focus() {
      this.tag('Item').zIndex = 3;
      this.tag('Item').scale = 1.2;
      this.tag('Item').color = 0xFFFFFFFF;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 1
        }
      });
    }
    _unfocus() {
      this.tag('Item').zIndex = 1;
      this.tag('Item').scale = 1;
      this.tag('Item').color = 0xFFDBEBFF;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 0
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const homeApi$2 = new HomeApi();
  class UIList extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        src: Utils.asset('images/splash/Splash-Background.jpg'),
        UI: {
          x: 200,
          y: 465,
          type: List,
          spacing: 20,
          direction: 'row',
          scroll: {
            after: 4
          }
        }
      };
    }
    pageTransition() {
      return 'right';
    }
    _firstEnable() {
      this.tag('UI').add(homeApi$2.getUIInfo().map((element, idx) => {
        return {
          ref: 'UI' + idx,
          w: 300,
          h: 150,
          type: Item,
          item: element,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      }));
    }
    _getFocused() {
      return this.tag('UI');
    }
    _handleEnter() {
      if (this.tag('UI').currentItem._item.title != 'DEFAULT') {
        console.log('Redirect to url');
        return;
      }
      Router.navigate('menu');
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Grid
   *
   * Contains global grid style information to easily maintain consistency throughout components.
   */

  /**
   * Sets up spacing configurations to correctly position Items and Rows.
   */
  const GRID = {
    gutters: {
      horizontal: 80,
      // space between rows
      vertical: 40 // space between columns (items)
    },

    margin: {
      x: 80,
      y: 112
    },
    spacingIncrement: 8,
    // the grid is built on an 8-point system
    columnWidth: 110
  };

  /**
   * Establishes the screen size to be 1080p resolution (1920x1080).
   */
  const SCREEN = {
    w: 1920,
    h: 1080
  };

  /**
   * Determines the width and height of an item based off the data passed into the item
   * (either all necessary parameters to calculate the dimensions dynamically,
   * OR all the necessary parameters to hard set the dimensions).
   *
   * @param { object } obj
   * @param { object } fallback
   *
   * @return { { number, number } }
   */
  function getDimensions() {
    let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let {
      w,
      h,
      ratioX,
      ratioY,
      upCount
    } = obj;
    let fallbackW = fallback.w || 0;
    let fallbackH = fallback.h || 0;
    let dimensions = {};

    // hard set width and height values were passed in and should override other params
    if (w && h) {
      dimensions = {
        w,
        h: h
      };
    }
    // hard set height and ratio values were passed in, meaning the row has items with mixed ratios,
    // so the width needs to be calculated
    else if (h && ratioX && ratioY) {
      dimensions = {
        w: Math.round(h * ratioX / ratioY),
        h: h
      };
    }
    // calculate dynamic width and height based off item ratios
    else if (ratioX && ratioY && upCount) {
      dimensions = getItemRatioDimensions(ratioX, ratioY, upCount);
    }
    // calculate dynamic width based off a row upcount and a given height
    else if (h && upCount) {
      dimensions = {
        w: Math.round(calculateColumnWidth(upCount)),
        h: h
      };
    } else if (h) {
      dimensions = {
        w: fallbackW,
        h: h
      };
    } else if (w) {
      dimensions = {
        w: w,
        h: fallbackH
      };
    }
    // not enough information was provided to properly size the component
    else {
      dimensions = {
        w: fallbackW,
        h: fallbackH
      };
    }
    dimensions = {
      ...dimensions,
      ratioX,
      ratioY,
      upCount
    };
    return dimensions;
  }

  /**
   * Calculates the width and height of an item based off the given ratios
   * and number of columns across the screen that should be visible before peaking
   *
   * @param { number } ratioX
   * @param { number } ratioY
   * @param { number } upCount
   *
   * @return { { number, number } }
   */
  function getItemRatioDimensions(ratioX, ratioY, upCount) {
    let w, h;
    if (ratioX && ratioY && upCount) {
      w = Math.round(calculateColumnWidth(upCount));
      h = Math.round(w / ratioX * ratioY);
    } else {
      w = 0;
      h = 0;
    }
    return {
      w,
      h
    };
  }

  /**
   * Calculates the width of an item given how many columns are requested
   *
   * @param { number } upCount
   *
   * @return { number }
   */
  function calculateColumnWidth(upCount) {
    // the screen width, minus the margin x on each side
    let rowWidth = SCREEN.w - GRID.margin.x * 2;
    if (upCount) {
      // the total space of column gaps in between items
      let columnGapTotal = (upCount - 1) * GRID.gutters.vertical;

      // the remaining amount of space left for all items
      let totalColumnsWidth = rowWidth - columnGapTotal;

      // the width of each item in that remaining width
      let itemWidth = totalColumnsWidth / upCount;
      return itemWidth;
    }
    return rowWidth;
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Colors
   *
   * Contains global color style information to easily maintain consistency throughout components.
   */

  /**
   * Combines rgb hex string and alpha into argb hexadecimal number
   * @param {string} hex - 6 alphanumeric characters between 0-f
   * @param {number} [alpha] - number between 0-100 (0 is invisible, 100 is opaque)
   */
  function getHexColor(hex) {
    let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    if (!hex) {
      return 0x00;
    }
    let hexAlpha = Math.round(alpha / 100 * 255).toString(16);
    let str = "0x".concat(hexAlpha).concat(hex);
    return parseInt(Number(str), 10);
  }

  /**
   * Returns valid string of HEX color
   *
   * @param {string} color
   * @param {boolean} fill
   */
  function getValidColor(color) {
    if (/^0x[0-9a-fA-F]{8}/g.test(color)) {
      // User enters a valid 0x00000000 hex code
      return Number(color);
    } else if (/^#[0-9a-fA-F]{6}/g.test(color)) {
      // User enters valid #000000 hex code
      return getHexColor(color.substr(1, 6));
    } else if (typeof color === 'string' && /^[0-9]{8,10}/g.test(color)) {
      return parseInt(color);
    } else if (typeof color === 'number' && /^[0-9]{8,10}/g.test(color.toString())) {
      return color;
    } else if (typeof color === 'string' && color.indexOf('rgba') > -1) {
      return rgba2argb(color);
    } else if (typeof color === 'string' && color.indexOf('rgb') > -1) {
      let rgba = [...color.replace(/rgb\(|\)/g, '').split(','), '255'];
      return lng.StageUtils.getArgbNumber(rgba);
    }
    return null;
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  /**
   * Returns a styles object for use by components
   * @param {Object|function} styles - Object or callback that takes theme as an argument, ultimately the returned value
   * @param {Object} theme - theme to be provided to styles
   */
  var createStyles = ((styles, theme) => {
    return typeof styles === 'function' ? styles(theme) : styles;
  });

  /**
   * Copyright 2022 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Merges two objects together and returns the duplicate.
   *
   * @param {Object} target - object to be cloned
   * @param {Object} [object] - secondary object to merge into clone
   */
  function clone(target, object) {
    const _clone = {
      ...target
    };
    if (!object || target === object) return _clone;
    for (const key in object) {
      const value = object[key];
      if (target.hasOwnProperty(key)) {
        _clone[key] = getMergeValue(key, target, object);
      } else {
        _clone[key] = value;
      }
    }
    return _clone;
  }
  function getMergeValue(key, target, object) {
    const targetVal = target[key];
    const objectVal = object[key];
    const targetValType = typeof targetVal;
    const objectValType = typeof objectVal;
    if (targetValType !== objectValType || objectValType === 'function' || Array.isArray(objectVal)) {
      return objectVal;
    }
    if (objectVal && objectValType === 'object') {
      return clone(targetVal, objectVal);
    }
    return objectVal;
  }

  /**
   * Naively looks for dimensional prop (i.e. w, h, x, y, etc.), first searching for
   * a transition target value then defaulting to the current set value
   * @param {string} prop - property key
   * @param {lng.Component} component - Lightning component to operate against
   */
  function getDimension(prop, component) {
    if (!component) return 0;
    const transition = component.transition(prop);
    if (transition.isRunning()) return transition.targetValue;
    return component[prop];
  }
  getDimension.bind(null, 'x');
  getDimension.bind(null, 'y');
  function stringifyCompare(objA, objB) {
    return JSON.stringify(objA) === JSON.stringify(objB);
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  function withStyles(Base, styles, theme) {
    const _theme = theme || Base.theme;
    const _styles = Base.styles ? clone(Base.styles, createStyles(styles, _theme)) : createStyles(styles, _theme);
    return class extends Base {
      static get name() {
        return Base.name;
      }
      static get styles() {
        return _styles;
      }
      get styles() {
        return _styles;
      }
    };
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  function getPropertyDescriptor$1(path) {
    return {
      get() {
        return this.tag(path);
      },
      configurable: true,
      enumerable: true
    };
  }
  function withTags(Base) {
    return class extends Base {
      static get name() {
        return Base.name;
      }
      _construct() {
        const tags = this.constructor.tags || [];
        let name, path;
        tags.forEach(tag => {
          if (typeof tag === 'object') {
            ({
              name,
              path
            } = tag);
          } else {
            name = tag;
            path = tag;
          }
          const key = '_' + name;
          const descriptor = getPropertyDescriptor$1(path);
          Object.defineProperty(Object.getPrototypeOf(this), key, descriptor);
        });
        super._construct && super._construct();
      }
    };
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  function capital(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function getPropertyDescriptor(name, key) {
    return {
      get() {
        const customGetter = this["_get".concat(capital(name))];
        if (customGetter && typeof customGetter === 'function') {
          const value = customGetter.call(this, this[key]);
          this[key] = value;
        }
        return this[key];
      },
      set(value) {
        const oldValue = this[key];
        if (value !== oldValue) {
          const changeHandler = this["_set".concat(capital(name))];
          if (changeHandler && typeof changeHandler === 'function') {
            value = changeHandler.call(this, value);
          }
          this[key] = value;
          this._requestUpdateDebounce();
        }
      },
      configurable: true,
      enumerable: true
    };
  }
  function withUpdates(Base) {
    return class extends Base {
      static get name() {
        return Base.name;
      }
      _construct() {
        let props = this.constructor.properties || [];
        props.forEach(name => {
          const key = '_' + name;
          const descriptor = getPropertyDescriptor(name, key);
          if (descriptor !== undefined) {
            Object.defineProperty(Object.getPrototypeOf(this), name, descriptor);
          }
        });
        this._whenEnabled = new Promise(resolve => {
          this._whenEnabledResolver = resolve;
        });
        this._requestUpdateDebounce = debounce_1.debounce(this._requestUpdate.bind(this), 0);
        super._construct && super._construct();
      }
      _firstEnable() {
        this._readyForUpdates = true;
        this._whenEnabledResolver();
        this._update();
        super._firstEnable && super._firstEnable();
      }
      _detach() {
        super._detach();
        this._requestUpdateDebounce.clear();
      }
      _requestUpdate() {
        if (this._readyForUpdates) {
          this._update();
        }
      }
    };
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  function withHandleKey(Base) {
    return class extends Base {
      static get name() {
        return Base.name;
      }
      _handleKey(keyEvent) {
        return this._processEvent(keyEvent);
      }
      _handleKeyRelease(keyEvent) {
        return this._processEvent(keyEvent, 'Release');
      }
      _processEvent(keyEvent) {
        let suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        let {
          key
        } = keyEvent;
        if (!key) {
          const keyMap = this.stage.application.__keymap || {};
          key = keyMap[keyEvent.keyCode];
        }
        if (key && typeof this["on".concat(key).concat(suffix)] === 'function') {
          return this["on".concat(key).concat(suffix)].call(this, this, keyEvent) || false;
        }
        this.fireAncestors("$on".concat(key).concat(suffix), this, keyEvent);
        return false;
      }
    };
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  function withLayout(Base) {
    return class extends Base {
      get itemLayout() {
        return this._itemLayout;
      }
      set itemLayout(itemLayout) {
        if (!stringifyCompare(this._itemLayout, itemLayout)) {
          this._itemLayout = itemLayout;
          const {
            w,
            h
          } = getDimensions(itemLayout);
          // If there is not enough information passed in args to calculate item size
          // Do not try to set h/w this will cause issues sizing the focus ring
          if (h || w) {
            const {
              w: width,
              h: height
            } = SCREEN;
            this.h = h || w * (height / width);
            this.w = w || h * (width / height);
            super._update && super._update();
          }
        }
      }
    };
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const baseStyles = () => ({
    getUnfocusScale: () => 1
    // getFocusScale: theme.getFocusScale
  });

  class Base extends lng$1.Component {
    _construct() {
      this._whenEnabled = new Promise(resolve => this._whenEnabledResolver = resolve);
      this._getFocusScale = this.styles.getFocusScale || function () {};
      this._getUnfocusScale = this.styles.getUnfocusScale || function () {};
    }
    _firstEnable() {
      this._whenEnabledResolver();
    }
    _init() {
      this._update();
    }
    _update() {}
    _focus() {
      if (this._smooth === undefined) this._smooth = true;
      this._update();
    }
    _unfocus() {
      this._update();
    }
  }
  function withMixins(baseComponent) {
    return withLayout(withUpdates(withTags(withHandleKey(baseComponent))));
  }
  var Base$1 = withMixins(withStyles(Base, baseStyles));

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var styles = {
    h: 8,
    w: 410,
    radius: 4,
    barColor: 0xffceceda,
    progressColor: 4127195135
  };

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class ProgressBar extends withStyles(Base$1, styles) {
    static _template() {
      return {
        Bar: {
          zIndex: 1
        },
        Progress: {
          alpha: 0,
          zIndex: 2
        }
      };
    }
    static get properties() {
      return ['animationDuration', 'barColor', 'progress', 'progressColor', 'radius'];
    }
    static get tags() {
      return ['Bar', 'Progress'];
    }
    _construct() {
      super._construct();
      this._w = this.styles.w;
      this.h = this.styles.h;
      this._progress = 0;
      this._radius = this.styles.radius;
      this._progressColor = this.styles.progressColor;
      this._barColor = this.styles.barColor;
      this._animationDuration = 0;
    }
    _init() {
      this._update();
    }
    set w(w) {
      if (this._w !== w) {
        this._w = w;
        this._update();
      }
    }
    get w() {
      return this._w;
    }
    _update() {
      const p = this.w * this.progress;
      const w = p <= 0 ? 0 : Math.min(p, this._w);
      this._Bar.texture = lng$1.Tools.getRoundRect(
      // getRoundRect adds 2 to the width
      this.w - 2, this.h, this.radius, 0, 0, true, this.barColor);
      this._Progress.texture = lng$1.Tools.getRoundRect(w + 1, this.h, this.radius, 0, 0, true, this.progressColor);
      this._Progress.smooth = {
        w: [w, {
          duration: this._animationDuration
        }],
        alpha: Number(w > 0)
      };
    }
    _setBarColor(barColor) {
      return getValidColor(barColor);
    }
    _setProgressColor(progressColor) {
      return getValidColor(progressColor);
    }
  }

  class AppStoreItem extends lng$1.Component {
    static _template() {
      return {
        Shadow: {
          y: -10,
          alpha: 0,
          rect: true,
          color: CONFIG.theme.hex,
          h: this.height + 20,
          w: this.width
        },
        Image: {
          h: this.height,
          w: this.width
        },
        Overlay: {
          alpha: 0,
          rect: true,
          color: 0xAA000000,
          h: this.height,
          w: this.width,
          OverlayText: {
            alpha: 0,
            mount: 0.5,
            x: this.width / 2,
            y: this.height / 2,
            text: {
              text: Language.translate('Installing'),
              fontFace: CONFIG.language.font,
              fontSize: 20
            },
            ProgressBar: {
              y: 30,
              x: -50,
              type: ProgressBar,
              w: 200,
              progress: 1,
              barColor: 4284637804,
              progressColor: 4127195135,
              animationDuration: 5
            }
          }
        },
        Text: {
          alpha: 0,
          y: this.height + 10,
          text: {
            text: '',
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        }
      };
    }
    set info(data) {
      this.data = data;
      if (data.url.startsWith('/images')) {
        this.tag('Image').patch({
          src: Utils.asset(data.url)
        });
      } else {
        this.tag('Image').patch({
          src: data.url
        });
      }
      this.tag('Text').text.text = data.displayName;
      // this.tag('Shadow').y = this.tag('Shadow').y - 10
    }

    static get width() {
      return 300;
    }
    static get height() {
      return 168;
    }
    _focus() {
      this.scale = 1.15;
      this.zIndex = 2;
      this.tag("Shadow").alpha = 1;
      this.tag("Text").alpha = 1;
    }
    _unfocus() {
      this.scale = 1;
      this.zIndex = 1;
      this.tag("Shadow").alpha = 0;
      this.tag("Text").alpha = 0;
    }
  }

  class OptionsItem extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {
          Text: {
            text: {
              text: '',
              fontFace: CONFIG.language.font,
              fontSize: 35,
              wordWrap: false,
              wordWrapWidth: 230,
              fontStyle: "normal",
              textOverflow: "ellipsis"
            }
          },
          Bar: {
            y: 50,
            texture: lng$1.Tools.getRoundRect(0, 5, 0, 0, CONFIG.theme.hex, true, CONFIG.theme.hex)
          }
        }
      };
    }
    _focus() {
      this.tag('Bar').texture = lng$1.Tools.getRoundRect(this.tag('Text').finalW, 5, 0, 0, CONFIG.theme.hex, true, CONFIG.theme.hex);
      this.tag('Text').text.fontStyle = 'bold';
    }
    _unfocus() {
      this.tag('Bar').texture = lng$1.Tools.getRoundRect(0, 5, 0, 0, CONFIG.theme.hex, true, CONFIG.theme.hex);
      this.tag('Text').text.fontStyle = '';
    }
    static get width() {
      return 250;
    }
    _handleEnter() {
      this.fireAncestors('$selectOption', this.idx, this);
      this._focus();
    }
    _handleDown() {
      this._handleEnter();
    }
    set element(item) {
      this.tag('Text').text.text = Language.translate(item);
      if (this.tag('Text').text.text.length > 11) {
        this.tag('Text').text.fontSize = 25;
      }
    }
  }

  const homeApi$1 = new HomeApi();
  class AppStore extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Apps'));
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: CONFIG.theme.background,
        Container: {
          x: 200,
          y: 270,
          Options: {
            // x: 10,
            type: List,
            direction: 'row',
            spacing: 30
          },
          Apps: {
            x: 20,
            y: 120,
            type: Grid,
            columns: 5,
            itemType: AppStoreItem,
            w: 1920,
            h: (AppStore.height + 90) * 2 + 2 * 20 - 10,
            scroll: {
              after: 2
            },
            spacing: 20
          }
        }
      };
    }
    _firstEnable() {
      let apps = homeApi$1.getAllApps();
      apps.shift();
      const options = ['My Apps', 'App Catalog', 'Manage Apps'];
      this.tag('Apps').add(apps.map(element => {
        return {
          h: AppStoreItem.height + 90,
          w: AppStoreItem.width,
          info: element
        };
      }));
      this.tag('Options').add(options.map((element, idx) => {
        return {
          type: OptionsItem,
          element: element,
          w: OptionsItem.width,
          idx
        };
      }));
      this.options = {
        0: () => {
          this.tag('Apps').add(apps.map(element => {
            return {
              h: AppStoreItem.height + 90,
              w: AppStoreItem.width,
              info: element
            };
          }));
        },
        1: () => {
          this.tag('Apps').clear();
        },
        2: () => {
          this.tag('Apps').clear();
        }
      };
    }
    $selectOption(option, obj) {
      this.tag('Apps').clear();
      obj._focus();
      this.options[option]();
      if (this.tag('Apps').length) {
        this._setState('Apps');
      }
    }
    _handleLeft() {
      Router.focusWidget('Menu');
    }
    pageTransition() {
      return 'up';
    }
    _handleUp() {
      this.widgets.menu.notify('TopPanel');
    }
    _focus() {
      this._setState('Options');
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('Options');
        }
        _handleDown() {
          this._setState('Apps');
        }
      }, class Apps extends this {
        _getFocused() {
          return this.tag('Apps');
        }
        _handleUp() {
          this._setState('Options');
        }
        _handleEnter() {
          let appApi = new AppApi();
          let applicationType = this.tag('Apps').currentItem.data.applicationType;
          let params = {
            url: this.tag('Apps').currentItem.data.uri,
            launchLocation: "appsMenu"
          };
          console.log(params, applicationType);
          appApi.launchApp(applicationType, params).catch(err => {
            console.log(applicationType + ' plugin error: ' + JSON.stringify(err));
          });
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class to render items in Subscription in details screen .
   */
  let index$1 = 0;
  class SubscriptionItem extends lng$1.Component {
    static _template() {
      return {
        SubscriptionItem: {
          Title: {
            y: 40,
            mountY: 0.5,
            text: {
              text: "YouTube",
              fontFace: CONFIG.language.font,
              fontSize: 25,
              // maxLines: 1,
              wordWrap: false,
              wordWrapWidth: 175,
              fontStyle: 'normal',
              textOverflow: 'ellipsis'
            }
          },
          SubscriptionBox: {
            x: 183,
            y: 0,
            Lines: {
              TopLine: {
                y: 0,
                mountY: 0.5,
                w: 484,
                h: 3,
                rect: true,
                color: 0xFFFFFFFF
              },
              BottomLine: {
                y: 77,
                mountY: 0.5,
                w: 484,
                h: 3,
                rect: true,
                color: 0xFFFFFFFF
              }
            },
            Arrows: {
              ArrowBackward: {
                h: 30,
                w: 45,
                x: 0,
                scaleX: -1,
                y: 38,
                mountY: 0.5,
                src: Utils.asset('images/settings/Arrow.png')
              },
              ArrowForward: {
                h: 30,
                w: 45,
                y: 38,
                x: 484,
                mountY: 0.5,
                mountX: 1,
                src: Utils.asset('images/settings/Arrow.png')
              }
            }
          },
          SubscriptionValues: {
            x: 433,
            y: 40,
            mount: 0.5,
            zIndex: 2,
            text: {
              text: 'Youtube',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              wordWrapWidth: 400,
              maxLines: 1,
              textOverflow: 'ellipsis',
              textAlign: 'center'
            }
          }
        }
      };
    }
    set item(item) {
      this._item = item;
      this.tag('Title').text.text = this._item.host["_@attribute"];
      if (Array.isArray(this._item.viewingOptions.viewingOption)) {
        this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption[0]);
        this.tag('Arrows').visible = true;
      } else if (this._item.viewingOptions.viewingOption !== null && typeof this._item.viewingOptions.viewingOption === 'object') {
        this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption);
        this._item.viewingOptions.viewingOption = [this._item.viewingOptions.viewingOption];
        this.tag('Arrows').visible = false;
      }
      // this.tag('SubscriptionValues').text.text=`${this._item.viewingOptions.viewingOption[0].price["_@attribute"]}-${this._item.viewingOptions.viewingOption[0].license}-${this._item.viewingOptions.viewingOption[0].quality}`;
    }

    convertPricing(option) {
      let res = '';
      if (option.license !== undefined) {
        let license = option.license.toLowerCase();
        res = res + license.substr(0, 1).toUpperCase() + license.substr(1) + " ";
      }
      if (option.price !== undefined) {
        res = res + "$" + option.price["_@attribute"] + " ";
      }
      if (option.quality !== undefined) {
        res = res + option.quality;
      }
      return res;
    }
    _focus() {
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("TopLine").h = 5;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").h = 5;
      this.tag("TopLine").zIndex = 10;
      this.tag("BottomLine").zIndex = 10;
      this.tag('Title').text.fontStyle = 'bold';
      this.tag('SubscriptionValues').text.fontStyle = 'bold';
      // console.log(this._item)
    }

    _handleLeft() {
      // index = (3 + (--index)) % 3;
      index$1 = index$1 - 1;
      if (index$1 < 0) {
        index$1 = this._item.viewingOptions.viewingOption.length - 1;
      }
      this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption[index$1]);
    }
    _handleEnter() {
      // this.handleDone()
      if (this._item.host["_@attribute"].toLowerCase() === "youtube") {
        let appApi = new AppApi();
        console.log(this._item.url);
        let params = {
          url: this._item.url,
          launchLocation: "gracenote"
        };
        appApi.launchApp("Cobalt", params).catch(err => {});
      }
    }
    _handleRight() {
      // index = (3 + (++index)) % 3;
      index$1 = index$1 + 1;
      if (index$1 > this._item.viewingOptions.viewingOption.length - 1) {
        index$1 = 0;
      }
      this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption[index$1]);
    }
    _unfocus() {
      this.tag("TopLine").color = 0xFFFFFFFF;
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").color = 0xFFFFFFFF;
      this.tag("BottomLine").h = 3;
      this.tag("TopLine").zIndex = 0;
      this.tag("BottomLine").zIndex = 0;
      this.tag('Title').text.fontStyle = 'normal';
      this.tag('SubscriptionValues').text.fontStyle = 'normal';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var homeApi = new HomeApi();
  class DetailsScreen extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(this.name);
    }
    pageTransition() {
      return "left";
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Details: {
          x: 200,
          y: 270,
          Image: {
            x: 0,
            y: 0,
            h: 493,
            w: 878
          },
          Cast: {
            Title: {
              x: 10,
              y: 520,
              text: {
                text: "",
                fontStyle: "bold",
                fontSize: 22
              }
            }
          },
          Description: {
            Title: {
              x: 10,
              y: 550,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 22,
                wordWrapWidth: 900,
                wordWrap: true
              }
            }
          },
          Subscriptions: {
            x: 950,
            y: 50,
            w: 670,
            h: 395,
            visible: false,
            clipping: true,
            List: {
              type: lng$1.components.ListComponent,
              w: 670,
              h: 390,
              y: 5,
              itemSize: 77,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -4
            }
          },
          Time: {
            y: 520,
            x: 1000,
            Title: {
              // mountX: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Rating: {
            y: 550,
            x: 1000,
            Title: {
              // mountX: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 25,
                wordWrap: true,
                wordWrapWidth: 500
              }
            }
          },
          GracenoteLogo: {
            x: 925,
            y: 510,
            w: 300,
            h: 168,
            src: Utils.asset("images/powered_by_gracenote.png")
          }
        }
      };
    }
    set params(args) {
      this.rootId = args.gracenoteItem.program.tmsid;
      this.name = args.gracenoteItem.program.title;
      let imgUrl = "http://developer.tmsimg.com/" + args.gracenoteItem.program.preferredImage.uri.replace("w=1280&", "w=878&").replace("&h=720", "&h=493") + "&api_key=" + args.key;
      this.tag("Image").src = Utils.proxyUrl(imgUrl);
      this.tag("Cast.Title").text.text = "".concat(args.gracenoteItem.program.topCast[0], " \t ").concat(args.gracenoteItem.program.topCast[1], " \t ").concat(args.gracenoteItem.program.topCast[2]);
      this.tag("Description.Title").text.text = args.gracenoteItem.program.longDescription;
      this.tag("Time.Title").text.text = "".concat(args.gracenoteItem.duration, " Minutes");
      if (args.gracenoteItem.ratings) {
        this.tag("Rating.Title").text.text = "".concat(args.gracenoteItem.ratings[0].body, " \n").concat(args.gracenoteItem.ratings[0].subRating);
      } else {
        this.tag("Rating.Title").text.text = "";
      }
      homeApi.getMovieSubscriptions(args.gracenoteItem.program.tmsId).then(response => {
        let options = response.ovd.movie.videos.video;
        if (options) {
          this.tag("Subscriptions.List").items = options.map((item, index) => {
            return {
              w: 670,
              h: 77,
              type: SubscriptionItem,
              item: item
            };
          });
          this.tag("Subscriptions").visible = true;
        } else {
          this.tag("Subscriptions").visible = false;
        }
        this._setState("Subscriptions");
        this.tag("Subscriptions.List").setIndex(0);
      }).catch(error => console.log(error));
    }
    _init() {}
    _focus() {
      this._setState("DetailsScreen");
      this.tag("Subscriptions.List").setIndex(0);
    }
    _unfocus() {
      this.tag("Subscriptions").visible = false;
    }
    _handleBack() {
      Router.navigate("menu");
    }
    static _states() {
      return [class DetailsScreen extends this {
        _handleDown() {
          this._setState("Subscriptions");
        }
        _handleUp() {
          this._setState("Subscriptions");
        }
        _handleLeft() {
          this._setState("Subscriptions");
        }
        _handleRight() {
          this._setState("Subscriptions");
        }
        _handleEnter() {
          this._setState("Subscriptions");
        }
      }, class Subscriptions extends this {
        _getFocused() {
          return this.tag("Subscriptions.List").element;
        }
        _handleDown() {
          this.tag("Subscriptions.List").setNext();
        }
        _handleUp() {
          this.tag("Subscriptions.List").setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var detailsScreenRoutes = {
    detailsScreenRoutes: [{
      path: 'menu/details',
      component: DetailsScreen,
      widgets: ['Menu', 'Volume']
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class to render items with tick Icon.
   */
  class TickMarkItem extends lng$1.Component {
    /**
     * Function to render Tick mark Icon elements in the settings.
     */

    _construct() {
      this.Tick = Utils.asset("/images/settings/Tick.png");
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xffffffff
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xffffffff
        }
      };
    }
    set isTicked(isTicked) {
      this.tag("Item").patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          h: 32.5,
          w: 32.5,
          src: this.Tick,
          color: 0xffffffff,
          visible: isTicked
        }
      });
    }
    _init() {
      this.tag("Item").patch({
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: this.itemName,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
      this.tag("Item.Tick").on("txError", () => {
        const url = "http://127.0.0.1:50050/lxresui/static/images/settings/Tick.png";
        this.tag("Item.Tick").src = url;
      });
    }
    _handleEnter() {
      this.onHandleEnter(this.uniqID); //expecting a function that gets executed on handleEnter
    }

    _focus() {
      this.tag("Item").color = COLORS.hightlightColor;
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag("TopLine").h = 6;
      this.tag("BottomLine").h = 6;
    }
    _unfocus() {
      this.tag("TopLine").color = 0xffffffff;
      this.tag("BottomLine").color = 0xffffffff;
      this.patch({
        zIndex: 1
      });
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Satellite extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setSatellite", selected);
      this.tag("List").items = this.fireAncestors("$getSatelliteList").map((item, index) => {
        return {
          ref: "Satellite" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected.name === item.name,
          //boolean
          itemName: item.name,
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedSatellite"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Polarity extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setPolarity", selected);
      this.tag("List").items = this.fireAncestors("$getPolarityList").map((item, index) => {
        return {
          ref: "Polarity" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.charAt(0).toUpperCase() + item.slice(1),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedPolarity"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FEC extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setFEC", selected);
      this.tag("List").items = this.fireAncestors("$getFECList").map((item, index) => {
        return {
          ref: "FEC" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.replace("fec", "").replace("_", "/").toUpperCase(),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedFEC"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Modulation extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setModulation", selected);
      this.tag("List").items = this.fireAncestors("$getModulationList").map((item, index) => {
        return {
          ref: "Modulation" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.toUpperCase(),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedModulation"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SearchType extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setSearchType", selected);
      this.tag("List").items = this.fireAncestors("$getSearchTypeList").map((item, index) => {
        return {
          ref: "SearchType" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.charAt(0).toUpperCase() + item.slice(1),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedSearchType"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  const keyMap = {
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    "F1": 112,
    "F2": 113,
    "F3": 114,
    "F4": 115,
    "F5": 116,
    "Amazon": 117,
    //F6
    "Netflix": 118,
    //F7
    "Youtube": 119,
    //F8
    "F11": 122,
    "F12": 123,
    "q": 81,
    "w": 87,
    "e": 69,
    "r": 82,
    "t": 84,
    "y": 89,
    "u": 85,
    "i": 73,
    "o": 79,
    "p": 80,
    "a": 65,
    "s": 83,
    "d": 68,
    "f": 70,
    "g": 71,
    "h": 72,
    "j": 74,
    "k": 75,
    "l": 76,
    "z": 90,
    "x": 88,
    "c": 67,
    "v": 86,
    "b": 66,
    "n": 78,
    "m": 77,
    "Q": 81,
    "W": 87,
    "E": 69,
    "R": 82,
    "T": 84,
    "Y": 89,
    "U": 85,
    "I": 73,
    "O": 79,
    "P": 80,
    "A": 65,
    "S": 83,
    "D": 68,
    "F": 70,
    "G": 71,
    "H": 72,
    "J": 74,
    "K": 75,
    "L": 76,
    "Z": 90,
    "X": 88,
    "C": 67,
    "V": 86,
    "B": 66,
    "N": 78,
    "M": 77,
    "Enter": 13,
    "Space": 32,
    "ArrowUp": 38,
    "ArrowLeft": 37,
    "ArrowRight": 39,
    "ArrowDown": 40,
    "AudioVolumeDown": 174,
    "AudioVolumeUp": 175,
    "AudioVolumeMute": 173,
    "MediaStop": 178,
    "MediaTrackPrevious": 177,
    "MediaPlay": 179,
    "MediaTrackNext": 176,
    "Escape": 27,
    "Pause": 179,
    "Backspace": 8,
    "MediaRewind": 227,
    "MediaFastForward": 228,
    "Power": 116,
    // F5
    "PageUp": 33,
    "PageDown": 34,
    "Home": 36,
    "Settings_Shortcut": 121,
    "Guide_Shortcut": 120,
    "Inputs_Shortcut": 113,
    //F2
    "Picture_Setting_Shortcut": 114 //F3
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class IntegerInput extends lng$1.Component {
    static _template() {
      return {
        x: 200,
        y: 275,
        InputBox: {
          Border: {
            texture: lng$1.Tools.getRoundRect(1600, 90, 0, 3, 0xffffffff, false)
          },
          Arrows: {
            y: 50,
            visible: false,
            RightArrow: {
              h: 50,
              w: 50,
              x: 1600,
              mountX: 1,
              mountY: 0.5,
              color: 0xffffffff,
              src: Utils.asset("images/settings/Arrow.png")
            },
            LeftArrow: {
              h: 50,
              w: 50,
              x: 0,
              mountX: 0,
              mountY: 0.5,
              scaleX: -1,
              color: 0xffffffff,
              src: Utils.asset("images/settings/Arrow.png")
            }
          },
          Content: {
            x: 50,
            y: 50,
            mountY: 0.5,
            text: {
              text: Language.translate("Enter the value and click Done"),
              textColor: COLORS.titleColor,
              fontFace: CONFIG.language.font,
              fontSize: 25,
              wordWrap: false,
              wordWrapWidth: 1500,
              textOverflow: "ellipsis"
            }
          }
        },
        Keyboard: {
          x: 660,
          y: 200,
          type: Keyboard,
          visible: true,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.numbers
        }
      };
    }
    _init() {
      this.numKeyCodes = [keyMap["0"], keyMap["1"], keyMap["2"], keyMap["3"], keyMap["4"], keyMap["5"], keyMap["6"], keyMap["7"], keyMap["8"], keyMap["9"]];
      //console.log(this.numKeyCodes) // above array order is importent as index is used as numeric value
    }

    _focus() {
      this._setState("InputBox");
      this.tag("Content").text.text = this.prevVal === "" ? Language.translate("Enter the value and click Done") : this.prevVal;
      this.inputValue = this.prevVal;
      console.log("presetValues: ", this.presetValues);
      this.presetValuesLength = 0;
      this.presetIdx = -1; //to accomodate previous value of the input field
      if (Array.isArray(this.presetValues)) {
        this.presetValuesLength = this.presetValues.length;
        console.log(this.presetValues, this.presetValuesLength);
        this.tag("Arrows").visible = true;
      } else {
        this.tag("Arrows").visible = false;
      }
    }
    handleDone() {
      // console.log(this.inputValue);
      this.onHandleDone(this.inputValue);
    }
    _handleKey(key) {
      let keyValue = this.numKeyCodes.indexOf(key.keyCode); //index is used as value for numeric keys
      if (keyValue >= 0) {
        this.inputValue += String(keyValue);
        this.tag("Content").text.text = this.inputValue;
      } else {
        return false; //to pass on other keys such as handleBack
      }
    }

    static _states() {
      return [class InputBox extends this {
        $enter() {
          this.tag("InputBox.Border").texture = lng$1.Tools.getRoundRect(1600, 90, 0, 3, CONFIG.theme.hex, false);
          this.tag("RightArrow").color = CONFIG.theme.hex;
          this.tag("LeftArrow").color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag("InputBox.Border").texture = lng$1.Tools.getRoundRect(1600, 90, 0, 3, 0xffffffff, false);
          this.tag("RightArrow").color = 0xffffffff;
          this.tag("LeftArrow").color = 0xffffffff;
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleEnter() {
          this._setState("Keyboard");
        }
        _handleLeft() {
          if (this.presetValuesLength > 0) {
            if (this.presetIdx <= 0) {
              this.presetIdx = this.presetValuesLength - 1;
            } else {
              this.presetIdx -= 1;
            }
            this.inputValue = this.presetValues[this.presetIdx];
            this.tag("Content").text.text = this.inputValue;
          }
        }
        _handleRight() {
          if (this.presetValuesLength > 0) {
            if (this.presetIdx === this.presetValuesLength - 1 || this.presetIdx < 0) {
              this.presetIdx = 0;
            } else {
              this.presetIdx += 1;
            }
            this.inputValue = this.presetValues[this.presetIdx];
            this.tag("Content").text.text = this.inputValue;
          }
        }
        _handleUp() {
          // do nothing
        }
      }, class Keyboard extends this {
        _handleDown() {
          // do nothing
        }
        _handleUp() {
          this._setState("InputBox");
        }
        _getFocused() {
          return this.tag("Keyboard");
        }
        _handleBack() {
          this._setState("InputBox");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === "Done") {
            this.handleDone();
          } else if (key === "Clear") {
            this.inputValue = this.inputValue.substring(0, this.inputValue.length - 1);
          } else if (key === "Delete") {
            this.inputValue = "";
          } else {
            this.inputValue += key;
          }
          this.tag("Content").text.text = this.inputValue;
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const dtvApi$3 = new DTVApi();
  const config$6 = {
    host: "127.0.0.1",
    port: 9998,
    default: 1
  };
  const thunder$7 = thunderJS(config$6);
  const systemcCallsign$1 = "DTV";

  /**
   * Class for DVB Scan screen.
   */
  class DvbSScan$1 extends lng$1.Component {
    _onChanged() {
      this.tag("Scroller").y = 2; //to reset the position when this route is hit
      this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan"));
    }
    pageTransition() {
      return "left";
    }
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        DvbSScanScreenContents: {
          x: 200,
          y: 275,
          Wrapper: {
            y: -3,
            h: 635,
            w: 1700,
            clipping: true,
            Scroller: {
              y: 2,
              Satellite: {
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Satellite"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Frequency: {
                y: 90,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Frequency"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Polarity: {
                y: 180,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Polarity"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SymbolRate: {
                y: 270,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Symbol Rate"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              FEC: {
                y: 360,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("FEC"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              DVBS2: {
                y: 450,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("DVB-S2"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              },
              Modulation: {
                y: 540,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Modulation"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SearchType: {
                y: 630,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Search Mode"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Retune: {
                y: 720,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Clear existing service list"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              }
            }
          },
          StartScan: {
            zIndex: 3,
            x: 10,
            y: 670,
            h: 50,
            w: 200,
            rect: true,
            color: 0xffffffff,
            Title: {
              x: 100,
              y: 27,
              mount: 0.5,
              text: {
                text: Language.translate("Start Scan"),
                textColor: 0xff000000,
                fontFace: CONFIG.language.font,
                fontSize: 24
              }
            }
          },
          ErrorNotification: {
            x: 250,
            y: 670,
            h: 50,
            visible: false,
            Content: {
              x: 10,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language.translate("Error!"),
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            }
          },
          ScanProgress: {
            x: 270,
            y: 670,
            h: 50,
            visible: false,
            Title: {
              visible: false,
              x: 40,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language.translate("Please wait scan in progress") + "...",
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 10,
              mountX: 1,
              y: 25,
              mountY: 0.5,
              src: Utils.asset("images/settings/Loading.png")
            }
          }
        },
        SelectSatellite: {
          type: Satellite,
          visible: false
        },
        SelectFrequency: {
          type: IntegerInput,
          visible: false
        },
        SelectPolarity: {
          type: Polarity,
          visible: false
        },
        SelectSymbolRate: {
          type: IntegerInput,
          visible: false
        },
        SelectFEC: {
          type: FEC,
          visible: false
        },
        SelectModulation: {
          type: Modulation,
          visible: false
        },
        SelectSearchType: {
          type: SearchType,
          visible: false
        }
      };
    }
    _init() {
      this._setState("Satellite");
      this.preventExit = false;
      this.selectedSatellite = {};
      this.selectedFrequency = "";
      this.selectedPolarity = "";
      this.selectedSymbolRate = "";
      this.selectedFEC = "";
      this.selectedDVBS2 = false; //default value is false
      this.selectedModulation = "";
      this.selectedSearchType = "";
      this.selectedRetune = false; //default value is set to false

      this.loadingAnimation = this.tag("ScanProgress.Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.inProgressAnimation = this.tag("ScanProgress.Title").animation({
        duration: 0.6,
        repeat: 0,
        stopMethod: "immediate",
        actions: [{
          p: "text.text",
          v: {
            0: Language.translate("Please wait scan in progress"),
            0.3: Language.translate("Please wait scan in progress") + ".",
            0.6: Language.translate("Please wait scan in progress") + "..",
            0.9: Language.translate("Please wait scan in progress") + "..."
          }
        }]
      });
    }
    setScanInProgress() {
      this.preventExit = true;
      this.loadingAnimation.start();
      this.inProgressAnimation.start();
      this.tag("ScanProgress").visible = true;
    }
    setScanFinished() {
      this.preventExit = false;
      this.loadingAnimation.stop();
      this.inProgressAnimation.stop();
      this.tag("ScanProgress").visible = false;
      this.tag("ScanProgress.Title").visible = false;
    }
    _captureKey() {
      if (this.preventExit) {
        this.tag("ScanProgress.Title").visible = true;
        this.inProgressAnimation.start();
      } else {
        return false;
      }
    }
    consoleLog() {
      //log it everywhere
      console.log("selectedSatellite: ", JSON.stringify(this.selectedSatellite), " selectedFrequency: ", this.selectedFrequency, " selectedPolarity: ", this.selectedPolarity, " selectedSymbolRate: ", this.selectedSymbolRate, " selectedFEC: ", this.selectedFEC, " selectedDVBS2: ", this.selectedDVBS2, " selectedModulation: ", this.selectedModulation, " selectedSearchType: ", this.selectedSearchType, " selectedRetune: ", this.selectedRetune);
    }
    _focus() {
      // console.log("dvbscan screen in focus");
      this.resetForm();
      this._setState("Satellite");
      this.consoleLog();
      // console.log(this.satelliteList);
      // console.log(this.polarityList);
      // console.log(this.fecList);
      // console.log(this.modulationList);
      // console.log(this.searchtypeList);
    }

    _firstActive() {
      thunder$7.on(systemcCallsign$1, "searchstatus", notification => {
        console.log("SearchStatus Notification: ", JSON.stringify(notification));
        if (notification.finished) {
          console.log("notification.finished: ", notification.finished);
          this.setScanFinished();
          dtvApi$3.noOfServices().then(res => {
            this.tag("ErrorNotification.Content").text.text = Language.translate("Found ") + res + Language.translate(" services.");
            this.tag("ErrorNotification").visible = true;
          });
        }
      });

      ///////////////satellite

      this.satelliteList = [];
      dtvApi$3.satelliteList().then(res => {
        this.satelliteList = res;
      });

      ///////////////////polarity

      this.polarityList = [];
      dtvApi$3.polarityList().then(res => {
        this.polarityList = res;
      });

      ///////////////////symbolRate
      //symbol rate has some predefined values additional to custom imput
      this.symbolRateList = [];
      dtvApi$3.symbolRateList().then(res => {
        this.symbolRateList = res;
      });

      ////////////////////FEC

      this.fecList = [];
      dtvApi$3.fecList().then(res => {
        this.fecList = res;
      });

      ///////////////////modulation

      this.modulationList = [];
      dtvApi$3.modulationList().then(res => {
        this.modulationList = res;
      });

      ///////////////////searchtype

      this.searchtypeList = [];
      dtvApi$3.searchtypeList().then(res => {
        this.searchtypeList = res;
      });
    }
    _handleBack() {
      this.resetForm();
      Router.navigate("settings/livetv/scan");
    }
    $getSatelliteList() {
      return this.satelliteList;
    }
    $setSatellite(satellite) {
      this.selectedSatellite = satellite;
      //this.consoleLog();
    }

    $getSelectedSatellite() {
      return this.selectedSatellite;
    }
    $getPolarityList() {
      return this.polarityList;
    }
    $setPolarity(polarity) {
      this.selectedPolarity = polarity;
      //this.consoleLog();
    }

    $getSelectedPolarity() {
      return this.selectedPolarity;
    }
    $getFECList() {
      return this.fecList;
    }
    $setFEC(fec) {
      this.selectedFEC = fec;
      //this.consoleLog();
    }

    $getSelectedFEC() {
      return this.selectedFEC;
    }
    $getModulationList() {
      return this.modulationList;
    }
    $setModulation(modulation) {
      this.selectedModulation = modulation;
      //this.consoleLog();
    }

    $getSelectedModulation() {
      return this.selectedModulation;
    }
    $getSearchTypeList() {
      return this.searchtypeList;
    }
    $setSearchType(searchtype) {
      this.selectedSearchType = searchtype;
      //this.consoleLog();
    }

    $getSelectedSearchType() {
      return this.selectedSearchType;
    }
    setFrequency(frequency) {
      this._setState("Frequency");
      this.selectedFrequency = frequency;
      this.tag("Frequency.Title").text.text = Language.translate("Frequency") + ": " + (this.selectedFrequency !== "" ? this.selectedFrequency : Language.translate("Select a") + " " + Language.translate("Frequency"));
    }
    setSymbolRate(symbolrate) {
      this._setState("SymbolRate");
      this.selectedSymbolRate = symbolrate;
      this.tag("SymbolRate.Title").text.text = Language.translate("Symbol Rate") + ": " + (this.selectedSymbolRate !== "" ? this.selectedSymbolRate : Language.translate("Select a") + " " + Language.translate("Symbol Rate"));
    }
    resetForm() {
      this.setScanFinished();
      //reset the form variables to initial state on exit from this form
      this.selectedSatellite = {};
      this.tag("Satellite.Title").text.text = Language.translate("Satellite");
      this.selectedFrequency = "";
      this.tag("Frequency.Title").text.text = Language.translate("Frequency");
      this.selectedPolarity = "";
      this.tag("Polarity.Title").text.text = Language.translate("Polarity");
      this.selectedSymbolRate = "";
      this.tag("SymbolRate.Title").text.text = Language.translate("Symbol Rate");
      this.selectedFEC = "";
      this.tag("FEC.Title").text.text = Language.translate("FEC");
      this.selectedDVBS2 = false;
      this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.selectedModulation = "";
      this.tag("Modulation.Title").text.text = Language.translate("Modulation");
      this.selectedSearchType = "";
      this.tag("SearchType.Title").text.text = Language.translate("Search Mode");
      this.selectedRetune = false;
      this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.tag("ErrorNotification").visible = false;
    }
    verifyInputs() {
      let errorString = "";
      if (Object.keys(this.selectedSatellite).length === 0) {
        errorString += "| " + Language.translate("Satellite") + " ";
      }
      if (this.selectedFrequency === "") {
        errorString += "| " + Language.translate("Frequency") + " ";
      }
      if (this.selectedPolarity === "") {
        errorString += "| " + Language.translate("Polarity") + " ";
      }
      if (this.selectedSymbolRate === "") {
        errorString += "| " + Language.translate("Symbol Rate") + " ";
      }
      if (this.selectedFEC === "") {
        errorString += "| " + Language.translate("FEC") + " ";
      }
      if (this.selectedModulation === "") {
        errorString += "| " + Language.translate("Modulation") + " ";
      }
      if (this.selectedSearchType === "") {
        errorString += "| " + Language.translate("Search Mode") + " ";
      }
      return errorString;
    }
    static _states() {
      return [class Satellite extends this {
        $enter() {
          this.tag("Satellite")._focus();
        }
        $exit() {
          this.tag("Satellite")._unfocus();
        }
        _handleDown() {
          this._setState("Frequency");
        }
        _handleEnter() {
          if (this.satelliteList.length > 0) {
            this._setState("Satellite.SelectSatellite");
          } else {
            dtvApi$3.satelliteList().then(res => {
              this.satelliteList = res;
            });
          }
        }
        static _states() {
          return [class SelectSatellite extends Satellite {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSatellite").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Satellite"));
            }
            $exit() {
              this.tag("SelectSatellite").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("Satellite.Title").text.text = Language.translate("Satellite") + ": " + (Object.keys(this.selectedSatellite).length !== 0 ? this.selectedSatellite.name : Language.translate("Select a") + " " + Language.translate("Satellite"));
            }
            _getFocused() {
              return this.tag("SelectSatellite");
            }
            _handleBack() {
              this._setState("Satellite");
            }
          }];
        }
      }, class Frequency extends this {
        $enter() {
          this.tag("Frequency")._focus();
        }
        $exit() {
          this.tag("Frequency")._unfocus();
        }
        _handleUp() {
          this._setState("Satellite");
        }
        _handleDown() {
          this._setState("Polarity");
        }
        _handleEnter() {
          this.tag("SelectFrequency").patch({
            prevVal: this.selectedFrequency,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setFrequency.bind(this) //pass a function that will be executed when done is clicked on the keyboard
          });

          this._setState("Frequency.SelectFrequency");
        }
        static _states() {
          return [class SelectFrequency extends Frequency {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFrequency").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Frequency"));
            }
            $exit() {
              this.tag("SelectFrequency").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan"));
            }
            _getFocused() {
              return this.tag("SelectFrequency");
            }
            _handleBack() {
              this.setFrequency(this.selectedFrequency);
            }
          }];
        }
      }, class Polarity extends this {
        $enter() {
          this.tag("Polarity")._focus();
        }
        $exit() {
          this.tag("Polarity")._unfocus();
        }
        _handleUp() {
          this._setState("Frequency");
        }
        _handleDown() {
          this._setState("SymbolRate");
        }
        _handleEnter() {
          this._setState("Polarity.SelectPolarity");
        }
        static _states() {
          return [class SelectPolarity extends Polarity {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectPolarity").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Polarity"));
            }
            $exit() {
              this.tag("SelectPolarity").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("Polarity.Title").text.text = Language.translate("Polarity") + ": " + (this.selectedPolarity !== "" ? this.selectedPolarity.charAt(0).toUpperCase() + this.selectedPolarity.slice(1) : Language.translate("Select a") + " " + Language.translate("Polarity"));
            }
            _getFocused() {
              return this.tag("SelectPolarity");
            }
            _handleBack() {
              this._setState("Polarity");
            }
          }];
        }
      }, class SymbolRate extends this {
        $enter() {
          this.tag("SymbolRate")._focus();
        }
        $exit() {
          this.tag("SymbolRate")._unfocus();
        }
        _handleUp() {
          this._setState("Polarity");
        }
        _handleDown() {
          this._setState("FEC");
        }
        _handleEnter() {
          this.tag("SelectSymbolRate").patch({
            prevVal: this.selectedSymbolRate,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setSymbolRate.bind(this),
            //pass a function that will be executed when done is clicked on the keyboard
            presetValues: this.symbolRateList //can handle a list of predefined values that can be selected using arrow keys
          });

          this._setState("SymbolRate.SelectSymbolRate");
        }
        static _states() {
          return [class SelectSymbolRate extends SymbolRate {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSymbolRate").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Symbol Rate"));
            }
            $exit() {
              this.tag("SelectSymbolRate").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan"));
            }
            _getFocused() {
              return this.tag("SelectSymbolRate");
            }
            _handleBack() {
              this.setSymbolRate(this.selectedSymbolRate);
            }
          }];
        }
      }, class FEC extends this {
        $enter() {
          this.tag("FEC")._focus();
        }
        $exit() {
          this.tag("FEC")._unfocus();
        }
        _handleUp() {
          this._setState("SymbolRate");
        }
        _handleDown() {
          this._setState("DVBS2");
        }
        _handleEnter() {
          this._setState("FEC.SelectFEC");
        }
        static _states() {
          return [class SelectFEC extends FEC {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFEC").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("FEC"));
            }
            $exit() {
              this.tag("SelectFEC").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("FEC.Title").text.text = Language.translate("FEC") + ": " + (this.selectedFEC !== "" ? this.selectedFEC.replace("fec", "").replace("_", "/").toUpperCase() : Language.translate("Select a") + " " + Language.translate("FEC"));
            }
            _getFocused() {
              return this.tag("SelectFEC");
            }
            _handleBack() {
              this._setState("FEC");
            }
          }];
        }
      }, class DVBS2 extends this {
        $enter() {
          this.tag("DVBS2")._focus();
        }
        $exit() {
          this.tag("DVBS2")._unfocus();
        }
        _handleUp() {
          this._setState("FEC");
        }
        _handleDown() {
          this._setState("Modulation");
        }
        _handleEnter() {
          if (!this.selectedDVBS2) {
            this.selectedDVBS2 = true;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedDVBS2 = false;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class Modulation extends this {
        $enter() {
          this.tag("Modulation")._focus();
        }
        $exit() {
          this.tag("Modulation")._unfocus();
        }
        _handleUp() {
          this._setState("DVBS2");
        }
        _handleDown() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleEnter() {
          this._setState("Modulation.SelectModulation");
        }
        static _states() {
          return [class SelectModulation extends Modulation {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectModulation").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Modulation"));
            }
            $exit() {
              this.tag("SelectModulation").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("Modulation.Title").text.text = Language.translate("Modulation") + ": " + (this.selectedModulation !== "" ? this.selectedModulation.toUpperCase() : Language.translate("Select a") + " " + Language.translate("Modulation"));
            }
            _getFocused() {
              return this.tag("SelectModulation");
            }
            _handleBack() {
              this._setState("Modulation");
            }
          }];
        }
      }, class SearchType extends this {
        $enter() {
          this.tag("SearchType")._focus();
        }
        $exit() {
          this.tag("SearchType")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = 2;
          this._setState("Modulation");
        }
        _handleDown() {
          this.tag("Scroller").y = -178;
          this._setState("Retune");
        }
        _handleEnter() {
          this._setState("SearchType.SelectSearchType");
        }
        static _states() {
          return [class SelectSearchType extends SearchType {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSearchType").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Search Mode"));
            }
            $exit() {
              this.tag("SelectSearchType").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("SearchType.Title").text.text = Language.translate("Search Mode") + ": " + (this.selectedSearchType !== "" ? this.selectedSearchType.charAt(0).toUpperCase() + this.selectedSearchType.slice(1) : Language.translate("Select a") + " " + Language.translate("Search Mode"));
            }
            _getFocused() {
              return this.tag("SelectSearchType");
            }
            _handleBack() {
              this._setState("SearchType");
            }
          }];
        }
      }, class Retune extends this {
        $enter() {
          this.tag("Retune")._focus();
        }
        $exit() {
          this.tag("Retune")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleDown() {
          this._setState("StartScan");
        }
        _handleEnter() {
          if (!this.selectedRetune) {
            this.selectedRetune = true;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedRetune = false;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class StartScan extends this {
        $enter() {
          this.tag("StartScan").color = CONFIG.theme.hex;
          this.tag("StartScan.Title").text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag("StartScan").color = 0xffffffff;
          this.tag("StartScan.Title").text.textColor = 0xff000000;
        }
        _handleUp() {
          this._setState("Retune");
        }
        _handleEnter() {
          let errorString = this.verifyInputs();
          if (errorString === "") {
            this.tag("ErrorNotification").visible = false;
            let serviceSearchParams = {
              tunertype: "dvbs",
              searchtype: this.selectedSearchType,
              retune: this.selectedRetune,
              usetuningparams: true,
              dvbstuningparams: {
                satellite: this.selectedSatellite.name,
                frequency: parseInt(this.selectedFrequency),
                polarity: this.selectedPolarity,
                symbolrate: parseInt(this.selectedSymbolRate),
                fec: this.selectedFEC,
                modulation: this.selectedModulation,
                dvbs2: this.selectedDVBS2
              }
            };
            console.log(JSON.stringify(serviceSearchParams));
            dtvApi$3.startServiceSearch(serviceSearchParams).then(res => {
              this.setScanInProgress();
              console.log(res);
              setTimeout(() => {
                this.setScanFinished(); //to give back controls after 30 sec in case searchstatus event fails
                dtvApi$3.noOfServices().then(res => {
                  this.tag("ErrorNotification.Content").text.text = Language.translate("Found ") + res + Language.translate(" services.");
                  this.tag("ErrorNotification").visible = true;
                });
              }, 30000);
            });
          } else {
            this.tag("ErrorNotification.Content").text.text = Language.translate("Please enter the values for the following ") + errorString;
            this.tag("ErrorNotification").visible = true;
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Live TV Scan screen.
   */
  class LiveTVScan$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Settings / Live TV / Scan'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        LiveTVScanScreenContents: {
          x: 200,
          y: 275,
          TScan: {
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('DVB-T Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CScan: {
            alpha: 0.3,
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('DVB-C Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          SScan: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('DVB-S Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this._setState('SScan');
    }
    _focus() {
      this._setState('SScan');
    }
    _handleBack() {
      Router.navigate('settings/livetv');
    }
    static _states() {
      return [class TScan extends this {
        $enter() {
          this.tag('TScan')._focus();
        }
        $exit() {
          this.tag('TScan')._unfocus();
        }
        _handleDown() {
          this._setState('CScan');
        }
        _handleEnter() {
          //Router.navigate()
        }
      }, class CScan extends this {
        $enter() {
          this.tag('CScan')._focus();
        }
        $exit() {
          this.tag('CScan')._unfocus();
        }
        _handleUp() {
          this._setState('TScan');
        }
        _handleDown() {
          this._setState('SScan');
        }
        _handleEnter() {
          // Router.navigate()
        }
      }, class SScan extends this {
        $enter() {
          this.tag('SScan')._focus();
        }
        $exit() {
          this.tag('SScan')._unfocus();
        }
        _handleUp() {
          // this._setState('CScan')
        }
        _handleEnter() {
          Router.navigate('settings/livetv/scan/dvb-s-scan');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let active$1 = true; //expecting dtv plugin is active by default

  /**
   * Class for Live TV settings screen.
   */
  class LiveTVSettings$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate("Settings / Live TV"));
    }
    pageTransition() {
      return "left";
    }
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        LiveTVSettingsScreenContents: {
          x: 200,
          y: 275,
          Activate: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate("Activate / Deactivate"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/ToggleOnOrange.png")
            }
          },
          Scan: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate("Scan"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/Arrow.png")
            }
          }
        }
      };
    }
    _init() {
      this._setState("Activate");
    }
    _firstActive() {
      this.dtvApi = new DTVApi();
    }
    _focus() {
      this._setState(this.state);
      if (active$1) {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
      } else {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      }
    }
    _handleBack() {
      Router.navigate("settings");
    }
    static _states() {
      return [class Activate extends this {
        $enter() {
          this.tag("Activate")._focus();
        }
        $exit() {
          this.tag("Activate")._unfocus();
        }
        _handleDown() {
          this._setState("Scan");
        }
        _handleEnter() {
          if (active$1) {
            this.dtvApi.deactivate().then(res => {
              console.log(res);
              active$1 = false;
              this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
            });
          } else {
            this.dtvApi.activate().then(res => {
              console.log(res);
              active$1 = true;
              this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
            });
          }
        }
      }, class Scan extends this {
        $enter() {
          this.tag("Scan")._focus();
        }
        $exit() {
          this.tag("Scan")._unfocus();
        }
        _handleUp() {
          this._setState("Activate");
        }
        _handleEnter() {
          Router.navigate("settings/livetv/scan");
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const liveTvRoutes = [{
    path: 'settings/livetv',
    component: LiveTVSettings$1,
    widgets: ['Menu', 'Volume']
  }, {
    path: 'settings/livetv/scan',
    component: LiveTVScan$1,
    widgets: ['Menu', 'Volume']
  }, {
    path: 'settings/livetv/scan/dvb-s-scan',
    component: DvbSScan$1,
    widgets: ['Menu', 'Volume']
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for ControlSettings thunder plugin apis.
   */

  class PictureSettingsApi {
    constructor() {
      const config = {
        host: "127.0.0.1",
        port: 9998,
        versions: {
          default: 2,
          Controller: 1,
          ControlSettings: 2
        }
      };
      this._thunder = thunderJS(config);
      this._events = new Map();
      this.callsign = "org.rdk.tv.ControlSettings";
      this.settingsOptions = [{
        id: "_pictureMode",
        name: "Picture Mode",
        value: ["standard", "vivid", "energysaving", "custom", "theater", "game", "sports"]
        // value: ["DemoValue(Api Fail)"] //#forTesting
      }, {
        id: "_colorTemp",
        name: "Color Temperature",
        value: ["Standard", "Warm", "Cold", "User Defined"]
        // value: ["DemoValue(Api Fail)"] //#forTesting
      }, {
        id: "_backlight",
        name: "Backlight",
        value: "0"
      }, {
        id: "_brightness",
        name: "Brightness",
        value: "0"
      }, {
        id: "_contrast",
        name: "Contrast",
        value: "0"
      }, {
        id: "_sharpness",
        name: "Sharpness",
        value: "0"
      }, {
        id: "_saturation",
        name: "Saturation",
        value: "0"
      }];
      this.methodNames = {
        _pictureMode: {
          get: this.getPictureMode.bind(this),
          set: this.setPictureMode.bind(this)
        },
        _colorTemp: {
          get: this.getColorTemperature.bind(this),
          set: this.setColorTemperature.bind(this)
        },
        _backlight: {
          get: this.getBacklight.bind(this),
          set: this.setBacklight.bind(this)
        },
        _brightness: {
          get: this.getBrightness.bind(this),
          set: this.setBrightness.bind(this)
        },
        _contrast: {
          get: this.getContrast.bind(this),
          set: this.setContrast.bind(this)
        },
        _sharpness: {
          get: this.getSharpness.bind(this),
          set: this.setSharpness.bind(this)
        },
        _saturation: {
          get: this.getSaturation.bind(this),
          set: this.setSaturation.bind(this)
        }
      };
    }
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call("Controller", "activate", {
          callsign: this.callsign
        }).then(result => {
          console.log("Activated tv.ControlSettings plugin: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("Failed to activate tv.ControlSettings plugin: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    getSettingsValue(settingsName) {
      console.log("getSettingsValue called for : ", settingsName);
      return new Promise((resolve, reject) => {
        this.methodNames[settingsName].get().then(result => {
          console.log("Result from getSettingsValue API for ".concat(settingsName, " : ").concat(JSON.stringify(result)));
          resolve(result);
        }).catch(err => {
          console.log("Error from getSettingsValue API for ".concat(settingsName, " : ").concat(JSON.stringify(err)));
          reject(err);
        });
      });
    }
    setSettingsValue(settingsName, value) {
      console.log("setSettingsValue called for : ", settingsName, " and for value: ", value);
      return new Promise((resolve, reject) => {
        this.methodNames[settingsName].set(value).then(result => {
          console.log("Result from setSettingsValue API for ".concat(settingsName, " : ").concat(JSON.stringify(result)));
          resolve(result);
        }).catch(err => {
          console.log("Error from setSettingsValue API for ".concat(settingsName, " and value : ").concat(value, " | Error: ").concat(JSON.stringify(err)));
          reject(err);
        });
      });
    }
    getOptions() {
      console.log("getOptions called: ", JSON.stringify(this.settingsOptions));
      return this.settingsOptions;
    }
    getSupportedPictureModes() {
      console.log("getSupportedPictureModes got called");
      return new Promise((resolve, reject) => {
        // resolve(true) //#forTesting
        this._thunder.call(this.callsign, "getSupportedPictureModes").then(result => {
          console.log("getSupportedPictureModes Result: ", JSON.stringify(result));
          if (result.success) {
            this.settingsOptions[0].value = result.SupportedPicmodes;
            resolve(true);
          }
        }).catch(err => {
          // this.settingsOptions[0].value=["tempval1", "tempval2"]  //#forTesting
          console.log("getSupportedPictureModes Error: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    getSupportedColorTemps() {
      console.log("getSupportedColorTemps got called");
      return new Promise((resolve, reject) => {
        // resolve(true) //#forTesting
        this._thunder.call(this.callsign, "getColorTemperature").then(result => {
          console.log("Log from getSupportedColorTemps API: ", JSON.stringify(result));
          if (result.success) {
            this.settingsOptions[1].value = result.ColorTemperature.Options;
            resolve(true);
          }
        }).catch(err => {
          console.log("Error from getSupportedColorTemps API: ", JSON.stringify(err));
          // this.settingsOptions[1].value=["tempval1", "tempval2"]  //#forTesting
          reject(err);
        });
      });
    }
    getPictureMode() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_pictureMode")) //#forTesting
        this._thunder.call(this.callsign, "getPictureMode").then(result => {
          resolve(result.pictureMode);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setPictureMode(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_pictureMode",value)) //#forTesting 
        this._thunder.call(this.callsign, "setPictureMode", {
          "pictureMode": value
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getColorTemperature() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_colorTemp")) //#forTesting 
        this._thunder.call(this.callsign, "getColorTemperature").then(result => {
          resolve(result.ColorTemperature.Selected);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setColorTemperature(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_colorTemp",value)) //#forTesting 
        this._thunder.call(this.callsign, "setColorTemperature", {
          "colorTemp": value
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getBrightness() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_brightness")) //#forTesting 
        this._thunder.call(this.callsign, "getBrightness").then(result => {
          resolve(result.Brightness.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setBrightness(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_brightness",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setBrightness", {
          "brightness": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getContrast() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_contrast")) //#forTesting 
        this._thunder.call(this.callsign, "getContrast").then(result => {
          resolve(result.Contrast.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setContrast(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_contrast",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setContrast", {
          "contrast": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getSharpness() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_sharpness")) //#forTesting 
        this._thunder.call(this.callsign, "getSharpness").then(result => {
          resolve(result.Sharpness.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setSharpness(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_sharpness",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setSharpness", {
          "sharpness": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getSaturation() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_saturation")) //#forTesting 
        this._thunder.call(this.callsign, "getSaturation").then(result => {
          resolve(result.Saturation.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setSaturation(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_saturation",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setSaturation", {
          "saturation": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getBacklight() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_backlight")) //#forTesting 
        this._thunder.call(this.callsign, "getBacklight").then(result => {
          resolve(result.Backlight.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setBacklight(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_backlight",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setBacklight", {
          "backlight": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlaySettingsItem extends lng$1.Component {
    _construct() {
      this.pictureApi = new PictureSettingsApi();
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 500,
          h: 3,
          rect: true,
          color: 0xffffffff
        },
        Item: {
          w: 500,
          h: 90,
          Title: {
            y: 45,
            x: 250,
            mount: 0.5,
            text: {
              text: "Setting: Sample Value",
              fontFace: CONFIG.language.font,
              fontSize: 25,
              wordWrap: false,
              wordWrapWidth: 400,
              fontStyle: "normal",
              textOverflow: "ellipsis"
            }
          },
          LeftArrow: {
            h: 45,
            w: 45,
            x: 0,
            scaleX: -1,
            y: 45,
            mountY: 0.5,
            src: Utils.asset("images/settings/Arrow.png"),
            color: 0xffffffff
          },
          RightArrow: {
            h: 45,
            w: 45,
            y: 45,
            x: 500,
            mountY: 0.5,
            mountX: 1,
            src: Utils.asset("images/settings/Arrow.png"),
            color: 0xffffffff
          }
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 500,
          h: 3,
          rect: true,
          color: 0xffffffff
        }
      };
    }
    _init() {}
    set item(item) {
      this._item = item;
      this.fetchAndUpdateValues();
    }
    fetchAndUpdateValues() {
      console.log("fetchAndUpdateValues got called!!!");
      if (Array.isArray(this._item.value)) {
        this.valueIdx = 0;
        this.valueLength = this._item.value.length;
        this.pictureApi.getSettingsValue(this._item.id).then(res => {
          console.log("getSettingsValue Result from fetchAndUpdateValues(array): ", JSON.stringify(res));
          let tIdx = this._item.value.indexOf(res);
          if (tIdx >= 0) {
            this.valueIdx = tIdx;
          }
          this.updateValue(this.formatItemName(this._item.value[this.valueIdx]));
        }).catch(err => {
          console.log("error from getSettingsValue(value is array) in set(item) in settings Item: ", JSON.stringify(err));
        });
      } else {
        this.pictureApi.getSettingsValue(this._item.id).then(res => {
          console.log("getSettingsValue Result from fetchAndUpdateValues(number): ", JSON.stringify(res));
          this._item.value = +res;
          this.currentVal = +res; //to change to int
          this.updateValue(this._item.value);
        }).catch(err => {
          console.log("error from getSettingsValue(value is number) in set(item) in settings Item: ", JSON.stringify(err));
        });
      }
    }
    updateValue(value) {
      this.tag("Title").text.text = "".concat(Language.translate(this._item.name), ": ").concat(value);
    }
    formatItemName(name) {
      return name.charAt(0).toUpperCase() + name.slice(1);
    }
    changeValueBy(val) {
      try {
        clearTimeout(this.changeValueTimer);
      } catch {
        console.log("CLEANUP ERROR");
      }
      if (this.currentVal + val <= 100 && this.currentVal + val >= 0) {
        this.currentVal += val;
        this.updateValue(this.currentVal);
      }
      this.changeValueTimer = setTimeout(() => {
        console.log("SENDING VALUE:".concat(this.currentVal, " TO API: ").concat(this._item.id));
        ///////////////// call set method and update the value in _item
        this.pictureApi.setSettingsValue(this._item.id, this.currentVal).then(res => {
          console.log(JSON.stringify(res));
          this._item.value = this.currentVal;
          this.updateValue(this.currentVal);
        }).catch(err => {
          console.log(JSON.stringify(err));
          console.log("this._item: ", JSON.stringify(this._item));
        });
      }, 600);
    }
    changePresetValueBy(direction) {
      this.fireAncestors("$moveDownLock", true); //user switching values prevent moving down
      try {
        clearTimeout(this.changePresetTimer);
      } catch {
        console.log("CLEANUP ERROR");
      }
      if (direction === "left") {
        this.valueIdx -= 1;
        if (this.valueIdx < 0) {
          this.valueIdx = this.valueLength - 1;
        }
      } else if (direction === "right") {
        this.valueIdx += 1;
        if (this.valueIdx >= this.valueLength) {
          this.valueIdx = 0;
        }
      }
      this.updateValue(this.formatItemName(this._item.value[this.valueIdx]));
      this.changePresetTimer = setTimeout(() => {
        console.log("SENDING VALUE:".concat(this._item.value[this.valueIdx], " TO API: ").concat(this._item.id));
        ///////// call set method and update the value in _item
        this.pictureApi.setSettingsValue(this._item.id, this._item.value[this.valueIdx]).then(res => {
          console.log(JSON.stringify(res));
          console.log(this._item.value[this.valueIdx]);
          this.updateValue(this.formatItemName(this._item.value[this.valueIdx]));
          this.fireAncestors("$moveDownLock", false); //api call success  user can move down
        }).catch(err => {
          console.log(JSON.stringify(err));
        });
      }, 600);
    }
    _handleLeft() {
      this.fireAncestors('$resetTimeout');
      if (this.valueLength > 0) {
        //value is an array
        this.changePresetValueBy("left");
      } else {
        if (this._item.id !== "_pictureMode" || this._item.id !== "_colorTemp") {
          this.changeValueBy(-1);
        }
      }
    }
    _handleRight() {
      this.fireAncestors('$resetTimeout');
      if (this.valueLength > 0) {
        //value is an array
        this.changePresetValueBy("right");
      } else {
        if (this._item.id !== "_pictureMode" || this._item.id !== "_colorTemp") {
          //except for preset, this condition check can be omitted by considering the value is not an array in this case
          this.changeValueBy(1);
        }
      }
    }
    _handleEnter() {
      this.fireAncestors('$resetTimeout');
    }
    _focus() {
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag("TopLine").h = 6;
      this.tag("BottomLine").h = 6;
      this.fetchAndUpdateValues(); //fetches the value from the api and updates on ui
    }

    _unfocus() {
      this.tag("TopLine").color = 0xffffffff;
      this.tag("BottomLine").color = 0xffffffff;
      this.patch({
        zIndex: 1
      });
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlaySettingsScreen extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          h: 1080,
          w: 500,
          Background: {
            h: 1080,
            w: 500,
            rect: true,
            colorLeft: 0xff000000,
            colorRight: 0x99000000
          },
          Settings: {
            w: 500,
            h: 910,
            clipping: true,
            y: 80,
            List: {
              type: lng$1.components.ListComponent,
              w: 500,
              h: 910,
              y: 5,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -9
            }
          }
        }
      };
    }
    _firstEnable() {
      this.customLock = false; //by default its unlocked | will get locked when user switches any preset value 
      this.pictureApi = new PictureSettingsApi();
      this.options = this.pictureApi.getOptions(); //#byDefault //not required //fetches the defaults dummy values //following api calls fetches the actual values from api here after
      this.pictureApi.getSupportedPictureModes().then(res => {
        if (res) {
          this.options = this.pictureApi.getOptions();
          this.refreshList();
        }
      }).catch(err => {
        console.log("ERROR from settings overlay screen firstEnable: getSupportedPictureModes: ", JSON.stringify(err));
      });
      //the getSupportedColorTemps api call has some issue when working on chrome browser
      this.pictureApi.getSupportedColorTemps().then(res => {
        if (res) {
          this.options = this.pictureApi.getOptions();
          this.refreshList();
        }
      }).catch(err => {
        console.log("ERROR from settings overlay screen firstEnable: getSupportedColorTemps: ", JSON.stringify(err));
      });
    }
    refreshList() {
      console.log("this.refreshList got called");
      this.tag("List").items = this.options.map((item, index) => {
        return {
          w: 500,
          h: 90,
          type: TvOverlaySettingsItem,
          item: item
        };
      });
    }
    _focus() {
      this.fireAncestors('$focusOverlay');
      console.log("index: ", this.tag("List").index);
      // this.tag("List").setIndex(0);//not necessary
    }

    _unfocus() {
      this.fireAncestors('$unfocusOverlay');
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.fireAncestors('$resetTimeout');
      if (this.tag("List").index < this.tag("List").length - 1) {
        //to prevent circular scrolling
        if (this.tag("List").index === 1) {
          //to check if user should be moving to third item
          if (!this.customLock) {
            //customLock value is true means api call is happening wait before moving down
            this.moveDownOnCustom();
          } else {
            console.log("changing the preset value cant moveDown now!!");
          }
        } else {
          this.tag("List").setNext();
        }
      }
    }
    _handleUp() {
      this.fireAncestors('$resetTimeout');
      if (this.tag("List").index > 0) {
        //to prevent circular scrolling
        this.tag("List").setPrevious();
      }
    }
    _handleLeft() {
      // do nothing
    }
    _handleRight() {
      // do nothing
    }
    async moveDownOnCustom() {
      try {
        const pictureMode = await this.pictureApi.getPictureMode();
        const colorTemp = await this.pictureApi.getColorTemperature();
        console.log("picture mode: ", pictureMode, " color temperature: ", colorTemp);
        if (pictureMode === "custom" && colorTemp === "User Defined") {
          this.tag("List").setNext();
        } else {
          this.tag("List").setIndex(1);
        }
      } catch {
        console.log("error occoured in api call");
      }
    }
    $moveDownLock(lock) {
      this.customLock = lock; //prevents user from moving down when a preset value change api call is happening
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlayInputItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset("/images/settings/Tick.png");
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1720,
          h: 3,
          rect: true,
          color: 0xffffffff
        },
        Item: {
          w: 1720,
          h: 90,
          Loader: {
            zIndex: 10,
            h: 45,
            w: 45,
            x: 1720,
            y: 45,
            mountY: 0.5,
            mountX: 1,
            src: Utils.asset("images/settings/Loading.png"),
            color: 0xffffffff,
            visible: false
          },
          InputError: {
            x: 1500,
            y: 45,
            mountY: 0.5,
            text: {
              text: "Input not available",
              fontSize: 25,
              textColor: 0xffffffff,
              fontFace: CONFIG.language.font
            },
            visible: false
          }
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1720,
          h: 3,
          rect: true,
          color: 0xffffffff
        }
      };
    }
    set isTicked(isTicked) {
      this.tag("Item").patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          h: 32.5,
          w: 32.5,
          src: this.Tick,
          color: 0xffffffff,
          visible: isTicked
        }
      });
      this.tag("Item.InputError").visible = false; //to remove the error text, when the list is refreshed.
    }

    _init() {
      console.log("_init from inputItem: list is getting rendered");
      this.hdmiApi = new HDMIApi();
      this.loadingAnimation = this.tag("Item.Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.tag("Item").patch({
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: this.itemName,
            fontSize: 25,
            textColor: 0xffffffff,
            fontFace: CONFIG.language.font
          }
        }
      });
      this.tag("Item.Tick").on("txError", () => {
        const url = "http://127.0.0.1:50050/lxresui/static/images/settings/Tick.png";
        this.tag("Item.Tick").src = url;
      });
      this.tag("Item.Loader").on("txError", () => {
        const url = "http://127.0.0.1:50050/lxresui/static/images/settings/Loading.png";
        this.tag("Item.Loader").src = url;
      });
    }
    _handleEnter() {
      this.fireAncestors('$resetTimeout');
      if (!this.tag("Item.Tick").visible) {
        //to start the loader
        this.loadingAnimation.start();
        this.tag("Item.Loader").visible = true;
        this.tag("Item.InputError").visible = false;
        const minLoaderDuration = 1000; //1 sec min duration to show the loader before the tick mark appears in the ui
        /////////////////
        this.hdmiApi.getHDMIDevices() //api does not throw error, just consider error condition when result is empty
        .then(res => {
          console.log("getHDMIDevices from input Item: ", JSON.stringify(res));
          if (res.length > 0) {
            res.map((item, index) => {
              if (item.id === this.uniqID.id) {
                if (item.connected === "true") {
                  //to check if the current item is connected
                  this.hdmiApi.setHDMIInput(item).then(res => {
                    console.log("input set to: ", JSON.stringify(item));
                    //to stop the loader and show tickmark
                    setTimeout(() => {
                      this.loadingAnimation.stop();
                      this.tag("Item.Loader").visible = false;
                      Storage.set("_currentInputMode", {
                        id: item.id,
                        locator: item.locator
                      });
                      this.fireAncestors("$getInputs"); //getInputs will fetch the inputs from api,
                    }, minLoaderDuration);
                  }).catch(err => {
                    console.log("Failed to setHDMIInput", JSON.stringify(err));
                    //to stop the loader
                    setTimeout(() => {
                      this.loadingAnimation.stop();
                      this.tag("Item.Loader").visible = false;
                    }, minLoaderDuration);
                    ///////////////////////
                    //display the error in the notification
                  });
                } else {
                  console.log("device not connected! item: ", JSON.stringify(item));
                  setTimeout(() => {
                    this.loadingAnimation.stop();
                    this.tag("Item.Loader").visible = false;
                    this.tag("Item.InputError").visible = true;
                  }, minLoaderDuration);
                }
              } else {
                console.log("ID not match! uniqID: ", JSON.stringify(this.uniqID), " item: ", JSON.stringify(item));
              }
            });
          } else {
            console.log("getHDMIDevices returned empty array"); //in case of error, getHDMIDevices api return empty array
            setTimeout(() => {
              this.loadingAnimation.stop();
              this.tag("Item.Loader").visible = false;
            }, minLoaderDuration);
          }
        }).catch(err => {
          console.log("Failed to getHDMIDevices", JSON.stringify(err));
          //to stop the loader
          setTimeout(() => {
            this.loadingAnimation.stop();
            this.tag("Item.Loader").visible = false;
          }, minLoaderDuration);
        });
      } else {
        console.log(Storage.get("_currentInputMode"));
      }
    }
    _focus() {
      //  this.tag("Item").color = COLORS.hightlightColor;
      this.refresh = false; //to check if the list needs a refresh // if connection status is false and user presses enter twice, hdmi input list gets refreshed
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag("TopLine").h = 6;
      this.tag("BottomLine").h = 6;
    }
    _unfocus() {
      this.tag("TopLine").color = 0xffffffff;
      this.tag("BottomLine").color = 0xffffffff;
      this.patch({
        zIndex: 1
      });
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlayInputScreen extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          h: 630,
          w: 1920,
          x: 960,
          mountX: 0.5,
          Background: {
            h: 630,
            w: 1920,
            rect: true,
            colorTop: 0xff000000,
            colorBottom: 0x99000000
          },
          Title: {
            y: 70,
            x: 100,
            text: {
              text: Language.translate("Video Input"),
              fontFace: CONFIG.language.font,
              textColor: CONFIG.theme.hex,
              fontSize: 40,
              wordWrap: false,
              wordWrapWidth: 370,
              fontStyle: "bold",
              textOverflow: "ellipsis"
            }
          },
          Inputs: {
            w: 1720,
            h: 370,
            clipping: true,
            y: 166,
            x: 960,
            mountX: 0.5,
            // rect: true, //
            // color: 0xffff0000, //
            List: {
              type: lng$1.components.ListComponent,
              w: 1720,
              h: 370,
              y: 5,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -3
            }
          },
          BorderLine: {
            y: 630,
            mountY: 1,
            w: 1920,
            h: 3,
            rect: true,
            color: 0xffffffff
          }
        }
      };
    }
    refreshItems(selected) {
      console.log("refreshItems called: rendering the items");
      this.tag("List").items = this.inputItems.map((item, index) => {
        return {
          ref: "Inputs" + index,
          w: 1720,
          h: 90,
          type: TvOverlayInputItem,
          isTicked: selected.id === item.id && selected.locator === item.locator,
          itemName: this.options[index],
          //item.toUpperCase(), //pass the formated item name if required
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _firstEnable() {
      this.options = ["HDMI1", "HDMI2", "HDMI3", "HDMI4"];
      this.inputItems = [{
        id: 0,
        locator: "hdmiin://localhost/deviceid/0",
        connected: true
      }, {
        id: 1,
        locator: "hdmiin://localhost/deviceid/1",
        connected: false
      }, {
        id: 2,
        locator: "hdmiin://localhost/deviceid/2",
        connected: true
      }];
      this.hdmiApi = new HDMIApi();
      this.$getInputs();
    }
    $getInputs() {
      console.log("fetching hdmi input options"); //call get inputs and refresh items after an event

      this.hdmiApi.getHDMIDevices().then(res => {
        this.inputItems = res;
        this.refreshItems(Storage.get("_currentInputMode"));
      }).catch(err => {
        console.log("inputScreen: getHDMIDevices Error: ", JSON.stringify(err));
      });
    }
    _focus() {
      this.fireAncestors('$focusOverlay');
      this.$getInputs(); //fetch the input modes and refresh the list, in case input status changes
    }

    _unfocus() {
      this.fireAncestors('$unfocusOverlay');
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.fireAncestors('$resetTimeout');
      this.tag("List").setNext();
    }
    _handleUp() {
      this.fireAncestors('$resetTimeout');
      this.tag("List").setPrevious();
    }
    _handleLeft() {
      this.fireAncestors('$resetTimeout');
      // do nothing
    }

    _handleRight() {
      this.fireAncestors('$resetTimeout');
      // do nothing
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$5 = {
    host: "127.0.0.1",
    port: 9998,
    default: 1
  };
  var thunder$6 = thunderJS(config$5);
  class TvOverlayScreen extends lng$1.Component {
    set params(args) {
      this._type = args.type;
      console.log("setting to idlestate");
      setTimeout(() => {
        if (this._type === "inputs") {
          this._setState("OverlayInputScreen");
        } else if (this._type === "settings") {
          this._setState("OverlaySettingsScreen");
        }
      }, 300);
    }

    // _onChanged() {
    //   this._setState("IdleState");
    // }

    static _template() {
      return {
        w: 1920,
        h: 1080,
        OverlaySettingsScreen: {
          x: -500,
          //set the x value to -500+ and add animation from left
          y: 0,
          type: TvOverlaySettingsScreen
        },
        OverlayInputScreen: {
          x: 0,
          y: -630,
          type: TvOverlayInputScreen
        }
      };
    }

    //   _getFocused() {
    //     console.log("getFocused Called")
    //     if (this._type === "inputs") {
    //       this._setState("OverlayInputScreen");
    //     } else if (this._type === "settings") {
    //       this._setState("OverlaySettingsScreen");
    //     }
    //   }

    _firstEnable() {
      this.appApi = new AppApi();
      this.overlayTimeout = null;
      this.timeoutDuration = 30000;
      this._sidePanelAnimation = this.tag("OverlaySettingsScreen").animation({
        delay: 0.3,
        duration: 0.3,
        stopMethod: "reverse",
        //so that .stop will play the transition towards left
        actions: [{
          p: "x",
          v: {
            0: -500,
            1: 0
          }
        }]
      });
      this._topPanelAnimation = this.tag("OverlayInputScreen").animation({
        delay: 0.3,
        duration: 0.3,
        stopMethod: "reverse",
        //so that .stop will play the transition towards left
        actions: [{
          p: "y",
          v: {
            0: -630,
            1: 0
          }
        }]
      });
    }
    _focus() {}
    $focusOverlay() {
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
    }
    $unfocusOverlay() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
    }
    $resetTimeout() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
    }
    $closeOverlay() {
      this._handleBack();
    }
    _handleBack() {
      let currentApp = Storage.get("applicationType");
      this._setState("IdleState");
      console.log("currentApp: ", currentApp);
      setTimeout(() => {
        if (currentApp !== "") {
          this.appApi.setVisibility("ResidentApp", false);
          thunder$6.call("org.rdk.RDKShell", "moveToFront", {
            client: currentApp
          }).then(result => {
            console.log(currentApp, " moveToFront Success");
            thunder$6.call("org.rdk.RDKShell", "setFocus", {
              client: currentApp
            }).then(result => {
              console.log(currentApp, " setFocus Success");
            }).catch(err => {
              console.log("Error", err);
            });
          });
        } else {
          if (Router.getActiveHash() === "dtvplayer") {
            //don't navigate to menu if route is dtvplayer
            Router.focusPage();
          } else {
            console.log("else block navigating to menu");
            Router.navigate("menu"); //if user is currently on resident app, might not be needed as user should not be able to get on this screen while on resident app
          }
        }
      }, 500);
    }
    static _states() {
      return [class IdleState extends this {
        $enter() {
          console.log("entering overlay IdleState");
        }
        $exit() {
          console.log("exiting overlay IdleState");
        }
      }, class OverlaySettingsScreen extends this {
        $enter() {
          this._topPanelAnimation.finish();
          this._sidePanelAnimation.start();
          console.log("$enter from OverlaySettingsScreen");
        }
        $exit() {
          this._sidePanelAnimation.stop();
        }
        _getFocused() {
          return this.tag("OverlaySettingsScreen");
        }
      }, class OverlayInputScreen extends this {
        $enter() {
          this._sidePanelAnimation.finish();
          this._topPanelAnimation.start();
          console.log("$enter from OverlayInputScreen");
        }
        $exit() {
          this._topPanelAnimation.stop();
        }
        _getFocused() {
          return this.tag("OverlayInputScreen");
        }
      }];
    }
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  class Volume extends lng$1.Component {
    constructor() {
      super(...arguments);
      _defineProperty(this, "setVolume", async val => {
        const value = await this.appApi.setVolumeLevel('HDMI0', val);
        return value;
      });
      _defineProperty(this, "setMute", async val => {
        const status = await this.appApi.audio_mute('HDMI0', val);
        return status;
      });
    }
    static _template() {
      return {
        rect: true,
        w: 1920,
        h: 320,
        color: 0xFF000000,
        y: -320,
        alpha: 0.9,
        transitions: {
          y: {
            duration: .3,
            timingFunction: 'cubic-bezier(0.17, 0.9, 0.32, 1.3)'
          },
          h: {
            duration: .3,
            timingFunction: 'cubic-bezier(0.17, 0.9, 0.32, 1.3)'
          }
        },
        Overlay: {
          Line: {
            y: 317,
            h: 3,
            w: 1920,
            rect: true,
            color: 0xffffffff
          }
        },
        VolumeInfo: {
          alpha: 1,
          zIndex: 2,
          y: 160,
          x: 960,
          mountX: 0.5,
          mountY: 0.5,
          h: 100,
          w: 100,
          src: Utils.asset('/images/volume/Volume.png'),
          Text: {
            x: 100,
            y: 0,
            text: {
              text: 0,
              fontSize: 80,
              fontFace: CONFIG.language.font
            }
          }
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.volTimeout = null;
      this.volume = 0;
      this.mute = false;
      this.appApi.getConnectedAudioPorts().then(res => {
        this.appApi.getVolumeLevel(res.connectedAudioPorts[0]).then(res1 => {
          this.appApi.muteStatus(res.connectedAudioPorts[0]).then(result => {
            this.mute = result.muted;
          });
          if (res1) {
            this.volume = parseInt(res1.volumeLevel);
            this._updateText(this.volume);
          }
        });
      }).catch(err => {
        this._updateText(this.volume);
      });
    }
    onVolumeKeyDown() {
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, 2000);
      if (this.volume > 0) {
        this.volume -= 5;
        if (this.setVolume(this.volume)) this._updateText(this.volume);
      }
    }
    onVolumeKeyUp() {
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, 2000);
      if (this.volume < 100) {
        this.volume += 5;
        if (this.setVolume(this.volume)) this._updateText(this.volume);
      }
    }
    onVolumeMute() {
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, 2000);
      if (this.setMute(!this.mute)) {
        this.mute = !this.mute;
        this._updateIcon(this.mute);
      }
    }
    _updateText(val) {
      this.tag('Text').text.text = val;
    }
    _updateIcon(check) {
      if (check) {
        this.tag('VolumeInfo').src = Utils.asset('images/volume/Volume_Mute.png');
      } else {
        this.tag('VolumeInfo').src = Utils.asset('/images/volume/Volume.png');
      }
    }
    _focus() {
      this.volTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, 2000);
      this.patch({
        smooth: {
          y: -30
        }
      });
    }
    _unfocus() {
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.patch({
        smooth: {
          y: -320
        }
      });
    }
    _handleBack() {
      console.log(Storage.get('applicationType'));
      if (Storage.get('applicationType')) {
        this.appApi.visibile('ResidentApp', false);
        this.appApi.setVisibility(Storage.get('applicationType'), true);
      } else {
        Router.focusPage();
      }
    }
    static _states() {
      return [];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ChannelItem extends lng$1.Component {
    static _template() {
      return {
        w: 236,
        Title: {
          x: 10,
          y: 45,
          mountY: 0.5,
          zIndex: 2,
          text: {
            text: 'xxxxxx',
            fontFace: CONFIG.language.font,
            fontStyle: 'normal',
            fontSize: 21,
            textColor: 0xffffffff,
            maxLines: 1,
            maxLinexSuffix: '...',
            wordWrapWidth: 232
          }
        },
        Item: {
          w: 236 - 3,
          h: 78,
          color: 0xff272727,
          rect: true
          // texture: Lightning.Tools.getRoundRect(236, 81, 0, 1, 0xff000000, true, 0xff1d1c1c),
        }
      };
    }

    setBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "bold";
    }
    unsetBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "normal";
    }
    set fontStyle(v) {
      this.tag('Title').text.fontStyle = v;
    }
    set title(val) {
      this.tag('Title').text = val;
    }
    get title() {
      return this.tag("Title").text;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Shows extends lng$1.Component {
    static _template() {
      return {
        y: 200
      }; /* this is just an empty component. used like a parent container for Cell containers */
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Cell extends lng$1.Component {
    static _template() {
      return {
        zIndex: 2
      };
    }
    set txt(ins) {
      /* the text on the Cell */
      this.patch({
        AiringOverlay: {
          zIndex: 4,
          Title: {
            x: 10,
            y: 45,
            mountY: 0.5,
            text: {
              text: ins ? ins : "No Shows are being aired at the moment",
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...'
            }
          }
        }
      });
      this.insText = ins ? ins : "No Shows are being aired at the moment";
    }
    get txt() {
      return this.insText;
    }
    set color(val) {
      let title = this.tag("Title");
      if (title) title.text.textColor = val;
    }
    setBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "bold";
    }
    unsetBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "normal";
    }
    set width(w) {
      /* the horizontal width of the Cell */
      this.patch({
        Item: {
          // clipping: true,
          w: w - 3,
          h: 78,
          color: 0xff272727,
          rect: true
          // texture: Lightning.Tools.getRoundRect(w, 81, 0, 1, 0xff000000, true, 0xff272727),
        }
      });

      this.tag('Title').text.wordWrapWidth = w - 20;
    }
    getwidth() {
      return this.width;
    }
    _init() {
      this.tag('AiringOverlay').w = this.tag('Item').w;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class CellCursor extends lng$1.Component {
    static _template() {
      return {
        zIndex: 5,
        UpperLine: {
          x: 0,
          y: 0,
          rect: true,
          w: 236,
          h: 2,
          color: CONFIG.theme.hex
        },
        LowerLine: {
          x: 0,
          y: 79,
          rect: true,
          w: 236,
          h: 2,
          color: CONFIG.theme.hex
        }
        // texture:Lightning.Tools.getRoundRect(236 ,81,0,1,0xffFFFFFF,true,0x0000ffff) // if you change this then you may wanna change the part where it patches itself too.
      };
    }

    patchCursor(x, y, w) {
      this.tag("UpperLine").patch({
        smooth: {
          x: x,
          y: y,
          w: w - 3
        }
      });
      this.tag("LowerLine").patch({
        smooth: {
          x: x,
          y: y + 79,
          w: w - 3
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let k = 5;
  class Epg extends lng$1.Component {
    static _template() {
      return {
        Background: {
          color: 0xff000000,
          w: 1920,
          h: 1080,
          rect: true
        },
        Loader: {
          x: 960,
          y: 540,
          mount: 0.5,
          w: 100,
          h: 100,
          src: Utils.asset("images/settings/Loading.png"),
          visible: true
        },
        Wrapper: {
          x: 200,
          y: 150,
          w: 1920,
          h: 1080,
          visible: false,
          DayLabel: {
            x: 0,
            y: 281,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: 'Today',
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...',
              wordWrapWidth: 236
            }
          },
          ShowName: {
            x: 0,
            y: 195,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: 'SHOW',
              fontFace: CONFIG.language.font,
              fontStyle: 'bold',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...',
              wordWrapWidth: 236
            }
          },
          ShowTimings: {
            x: 236 * 5 + 59,
            y: 195,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: 'SHOW-TIMINGS',
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...',
              wordWrapWidth: 236
            }
          },
          ChannelName: {
            x: 236 * 5 + 59,
            y: 225,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: 'CHANNEL-NAME',
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 2,
              maxLinexSuffix: '...',
              wordWrapWidth: 236 * 5
            }
          },
          ShowDetails: {
            x: 0,
            y: 225,
            w: 236 * 5,
            h: 81,
            mountY: 0.5,
            text: {
              text: 'SHOW-DETAILS',
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 2,
              maxLinexSuffix: '...',
              wordWrapWidth: 236 * 5
            }
          },
          Channels: {
            x: 0,
            y: 81 + 200,
            w: 236
          },
          TopBar: {
            y: 200,
            x: 236,
            TimeNotifiers: {
              x: -4,
              w: 236 * 6 + 2,
              h: 81,
              clipping: true,
              TimeBar: {
                // this is the gray bar
                x: k,
                y: 81 - 12,
                // this should be the ShowLists "y" value - 9, extra -3 to accomodate margin
                rect: true,
                h: 9,
                w: 0,
                color: 0xff404040
              },
              DownTriangle: {
                // this is the little triangle over the white bar.
                x: 4,
                y: 81 - 12,
                // this should be the same as TimeBar's "y" Value, extra -3 to accomodate margin
                mountX: 0.5,
                mountY: 0.5,
                color: 0xffffffff,
                text: {
                  text: "".concat(String.fromCodePoint(9662)),
                  fontSize: 25,
                  textColor: 0xffffffff
                }
              }
            },
            TimeLabels: {
              clipping: true,
              zIndex: 2,
              w: 236 * 6,
              h: 81,
              x: k,
              y: 0
            },
            Wrapper: {
              w: 236 * 6,
              h: 81 * 9,
              clipping: true,
              Shows: {
                y: 81,
                // x: 236,
                type: Shows
              },
              CellCursor: {
                y: 81,
                type: CellCursor
              }
            }
          }
        }
      };
    }
    setChannels(channels) {
      let c = channels.map((c, i) => {
        return {
          y: 81 * i,
          w: 236,
          type: ChannelItem,
          title: c.shortname
        };
      });
      this.tag('Channels').children = c;
      this.channelGridInstance = this.tag('Channels').children;
    }
    _firstEnable() {
      this.appApi = new AppApi();
    }
    launchApp(appName) {
      const apps = {
        //mapping from channel.shortname to application name
        "Youtube": "Cobalt",
        "Netflix": "Netflix",
        "Amazon Prime": "Amazon"
      };
      const app = apps[appName];
      let params = {
        launchLocation: "epgScreen"
      };
      this.appApi.launchApp(app, params);
    }
    _handleBack() {
      Router.navigate("menu");
    }
    _handleEnter() {
      let channel = this.getCurrentChannel();
      if (channel.dvburi === "OTT") {
        this.launchApp(channel.shortname); // check mapping in launchApp method
      } else {
        if (!Router.isNavigating()) {
          this.DTV.launchChannel(channel.dvburi).then(res => {
            console.log("launchChannel method successful: ", JSON.stringify(res));
            this.widgets.channeloverlay.$focusChannel(this.D - 11 + this.currentlyFocusedRow); // -11 = -8 + -3(3 to accomodate apps which won't be shown on the overlay)
            Router.navigate("dtvplayer");
          }).catch(err => {
            console.log("launchChannel method failed: ", JSON.stringify(err));
          });
        } else {
          console.error("Router is still navigating.");
        }
      }
    }
    getCurrentChannel() {
      let currentChannel = this.activeChannels[this.currentlyFocusedRow];
      return currentChannel;
    }
    setShows4Channels(channels) {
      let headStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.strtindexesofrows = [];
      var ltp = this.ltp;
      var rtp = new Date(this.ltp.getTime() + 3 * 60 * 60 * 1000);
      var cells = [];
      var self = this;
      function filterShowsBasedOnTimeWindow(shows, index) {
        let inc = headStart < 0 ? -1 : 1;
        let i = Math.abs(headStart);
        while (i >= 0) {
          // binary search can optimize this loop.

          shows[i].endtime = shows[i].duration + shows[i].starttime;
          if (i >= shows.length) {
            console.warn("Reached the end of data , can't traverse shows any further!");
            break;
          } else if (new Date(shows[i].starttime) <= ltp && new Date(shows[i].endtime) > ltp) {
            break;
          } else if (new Date(shows[i].starttime) > ltp) {
            console.warn("there's chance that an empty space appear in one of the rows");
            break;
          } else if (i === shows.length - 1) {
            console.warn('traversed all of the shows and none of them are airing at this time for this channel');
            return;
          }
          i += inc;
        }
        let x = 0;
        self.strtindexesofrows.push(cells.length);
        for (; i < shows.length; i++) {
          if (new Date(shows[i].starttime) >= rtp) {
            break;
          }
          let width = shows[i].duration / (1000 * 60) / 30 * 236;
          shows[i].endtime = shows[i].duration + shows[i].starttime;
          // the below code trim the left most and right most cells
          if (new Date(shows[i].starttime) < ltp) {
            width -= (ltp - new Date(shows[i].starttime)) / (1000 * 60) / 30 * 236;
          }
          if (new Date(shows[i].endtime) > rtp) {
            width -= (new Date(shows[i].endtime) - rtp) / (1000 * 60) / 30 * 236;
          }
          //------------ Trimming ends here-----------------
          cells.push({
            x: x,
            y: index * 81,
            w: width,
            type: Cell,
            txt: shows[i].name,
            description: shows[i].shortdescription,
            width: width,
            starttime: shows[i].starttime,
            showIndex: i,
            duration: shows[i].duration,
            endtime: shows[i].endtime
          });
          shows[i].duration + shows[i].starttime;
          x += width;
        }
        // the below code actually sets the shows
        if (index === channels.length - 1) {
          let shows = self.tag('Shows');
          shows.children = cells;
          self.strtindexesofrows.push(cells.length); // this is added just for calculation.
          self.gridInstance = shows.children;
          // self.updateCursor()
          self._setState('CellSelector');
        }
      }
      channels.map((channel, i) => {
        filterShowsBasedOnTimeWindow(channel.shows, i);
      });
    }
    setTimeLabelsBetween() {
      let startTime = this.ltp;
      let endTime = new Date(this.ltp.getTime() + 3 * 60 * 60 * 1000);
      let arr = [];
      let p = this.tag('TimeLabels');
      for (let t = startTime, i = 0; t <= endTime; t = new Date(t.getTime() + 30 * 60 * 1000), i++) {
        // the increment can probably be improvised
        let H = t.getHours();
        let M = t.getMinutes();
        M = M.toString().length < 2 ? '0' + M : M;
        arr.push({
          x: i * 236,
          y: 35,
          mountY: 0,
          text: {
            text: H >= 12 ? H === 12 ? "".concat(H, ":").concat(M, "PM") : "".concat(H - 12, ":").concat(M, "PM") : "".concat(H, ":").concat(M, "AM"),
            fontFace: CONFIG.language.font,
            fontStyle: 'normal',
            fontSize: 21,
            textColor: 0xffffffff,
            maxLines: 1,
            maxLinexSuffix: '...'
          }
        });
        p.children = arr;
      }
    }
    initialize() {
      this.ltp = new Date();
      let currentDateTime = this.ltp;
      let temp = currentDateTime.getMinutes();
      let closest30MinRoundOff;
      //the below round off system only works if the duration of the show is a multiple of 30.
      currentDateTime.setMilliseconds(0);
      currentDateTime.setSeconds(0);
      if (temp >= 30) {
        currentDateTime.setMinutes(30);
        closest30MinRoundOff = currentDateTime;
      } else {
        currentDateTime.setMinutes(0);
        closest30MinRoundOff = currentDateTime;
      }
      this.ltp = closest30MinRoundOff;
      this.closest30MinRoundOff = closest30MinRoundOff.getTime();
      this.setTimeLabelsBetween();
      let tBar = this.tag('TimeBar');
      let dTriangle = this.tag('DownTriangle');
      let self = this;
      this.interval = setInterval(() => {
        let now = new Date();
        if (now.getHours() === 0) ;
        let t = (now - self.ltp >= 0 ? now - self.ltp : 0) / (1000 * 60 * 30) * 236;
        tBar.w = t;
        dTriangle.x = t + k;
      }, 2000);
    }
    setBoldText() {
      let l = this.strtindexesofrows[this.currentlyFocusedRow];
      let r = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
      this.channelGridInstance[this.currentlyFocusedRow].setBoldText();
      for (var i = l; i <= r; i++) {
        this.gridInstance[i].setBoldText();
      }
    }
    unsetBoldText() {
      let l = this.strtindexesofrows[this.currentlyFocusedRow];
      let r = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
      this.channelGridInstance[this.currentlyFocusedRow].unsetBoldText();
      for (var i = l; i <= r; i++) {
        this.gridInstance[i].unsetBoldText();
      }
    }
    scrollVertically(n) {
      if (n < 0) {
        this.D--;
      } else {
        this.D++;
      }
      console.log("setting vertical scroll from ".concat(this.D - 8, " to ").concat(this.D, " based the value ").concat(n));
      this.activeChannels = this.channels.slice(this.D - 8, this.D);
      this.setChannels(this.activeChannels);
      this.setShows4Channels(this.activeChannels);
    }
    onDataProvidedX() {
      console.log("on Data Provided");
      this.initialize();
      this.scrollVertically();
      this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
      this.setBoldText();
      this.paintCell();
      this.updateCursor();
      this.verticallyNonScrollableWindow = Math.min(this.channels.length - 1, 7);
    }
    paintCell() {
      this.gridInstance[this.currentCellIndex].color = CONFIG.theme.hex;
    }
    unpaintCell() {
      this.gridInstance[this.currentCellIndex].color = 0xffffffff;
    }
    _focus() {
      this.D = 7;
      this.DTV = this.DTV ? this.DTV : new DTVApi();
      let wrapper = this.tag("Wrapper");
      let loader = this.tag("Loader");
      wrapper.visible = false;
      loader.visible = true;
      this.loadingAnimation.start();
      let self = this;
      function f(page) {
        let d = new Date();
        d.setHours(0);
        d.setMinutes(0);
        d.setSeconds(0);
        d.setMilliseconds(0);
        d = d.getTime();
        let e = d + 7 * 24 * 60 * 60 * 1000;
        function filler(shows) {
          let diff = 0;
          let currentShowETime = d;
          diff = shows[0].starttime - d;
          if (diff > 0) {
            shows.unshift({
              name: '',
              starttime: d,
              duration: diff,
              eventid: 0,
              shortdescription: ''
            });
          }
          let memLeakAlert = shows.length - 1;
          for (let i = 0; i < shows.length - 1; i++) {
            currentShowETime = shows[i].starttime + shows[i].duration;
            diff = shows[i + 1].starttime - currentShowETime;
            if (diff > 0) {
              if (memLeakAlert < 0) {
                console.warn('Memory leak alert; aborting black cell insert');
              }
              shows.splice(i + 1, 0, {
                name: '',
                starttime: currentShowETime,
                duration: diff,
                eventid: 0,
                shortdescription: ''
              });
              memLeakAlert--;
            }
          }
          currentShowETime = shows[shows.length - 1].starttime + shows[shows.length - 1].duration;
          diff = e - currentShowETime;
          if (e > 0) {
            shows.push({
              name: '',
              starttime: currentShowETime,
              duration: diff,
              eventid: 0,
              shortdescription: ''
            });
          }
        }
        return new Promise((resolve, reject) => {
          self.DTV.serviceList().then(channels => {
            let traversedChannels = 0;
            channels.map((channel, i) => {
              if (channel.dvburi === "OTT") {
                traversedChannels++;
                channels[i].shows = [{
                  name: Language.translate("click to launch") + " ".concat(channel.shortname),
                  starttime: 0,
                  duration: e,
                  eventid: 0,
                  shortdescription: ''
                }];
                if (channels.length - 1 === traversedChannels) {
                  console.log("premium apps exclusive resolve");
                  page.channels = channels;
                  resolve(true);
                }
                return 0;
              }
              self.DTV.scheduleEvents(channel.dvburi).then(shows => {
                traversedChannels++;
                // for premium apps and empty cell
                if (!shows || shows.length === 0) {
                  channels[i].shows = [{
                    name: '',
                    starttime: d,
                    duration: e,
                    eventid: 0,
                    shortdescription: ''
                  }];
                } else {
                  channels[i].shows = shows;
                  filler(channels[i].shows);
                }
                if (channels.length === traversedChannels) {
                  page.channels = channels;
                  resolve(true);
                }
              }).catch(err => {
                // console.error(err)
                // return "Home"
                console.error('error', err);
                reject(err);
              });
            });
          }).catch(err => {
            reject(err);
          });
        });
      }
      f(this).then(res => {
        self.loadingAnimation.stop();
        self.onDataProvidedX();
        loader.visible = false;
        wrapper.visible = true;
      }).catch(err => {
        console.log("error while fetching data from dtv", err);
        Router.navigate('menu');
      });
    }
    _init() {
      this.D = 7;
      this.currentCellIndex = 0;
      this.currentlyFocusedRow = 0;
      this.strtindexesofrows = [];
      this.cursorInstance = this.tag('CellCursor');
      this.loadingAnimation = this.tag("Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _unfocus() {
      //resetting all variables
      this.D = 7;
      this.currentCellIndex = 0;
      this.currentlyFocusedRow = 0;
      this.strtindexesofrows = [];
    }
    scrollHorizontally(n) {
      if (n < 0) {
        let prevShow = this.channels[this.D - (8 - this.currentlyFocusedRow)].shows[this.gridInstance[this.currentCellIndex].showIndex - 1];
        // this.ltp = new Date(Math.max(prevShow.starttime, this.closest30MinRoundOff))
        this.ltp = new Date(Math.max(prevShow.starttime));
        this.setShows4Channels(this.activeChannels);
        this.currentCellIndex = this.strtindexesofrows[this.currentlyFocusedRow];
        this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
        this.updateCursor();
      } else {
        let nextShow = this.channels[this.D - (8 - this.currentlyFocusedRow)].shows[this.gridInstance[this.currentCellIndex].showIndex + 1];
        if (nextShow.duration > 3 * 60 * 60 * 1000) {
          this.ltp = new Date(nextShow.starttime);
        } else {
          let l = nextShow.starttime + nextShow.duration - 3 * 60 * 60 * 1000;
          this.ltp = new Date(l);
        }
        this.setShows4Channels(this.activeChannels);
        this.currentCellIndex = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
        this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
        this.updateCursor();
      }
      this.setTimeLabelsBetween();
      this.setBoldText();
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language.translate('Guide'));
    }
    pageTransition() {
      return 'up';
    }
    _handleLeft() {
      Router.focusWidget('Menu');
    }
    _handleUp() {
      this.widgets.menu.notify('TopPanel');
    }
    static _states() {
      return [class CellSelector extends this {
        $enter() {}
        _handleLeft() {
          this.unpaintCell();
          if (this.currentCellIndex > this.strtindexesofrows[this.currentlyFocusedRow]) {
            this.currentCellIndex--;
            this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
            this.updateCursor();
          } else if (this.gridInstance[this.currentCellIndex].showIndex > 0) {
            this.scrollHorizontally(-1);
          } else {
            console.log("can't traverse any left");
            Router.focusWidget('Menu');
          }
          this.paintCell();
        }
        _handleRight() {
          this.unpaintCell();
          this.channels[this.D - (8 - this.currentlyFocusedRow)].shortname;
          if (this.currentCellIndex < this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1) {
            this.currentCellIndex++;
            this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
            this.updateCursor();
          } else if (this.gridInstance[this.currentCellIndex].showIndex < this.channels[this.D - (8 - this.currentlyFocusedRow)].shows.length - 1) {
            //current Cell index has to be updated at last
            this.scrollHorizontally(1);
          } else console.log("can't go further right");
          this.paintCell();
        }
        binarySearch(t, left, right) {
          const lim = left;
          t = new Date(t);
          let mid;
          while (left <= right) {
            mid = left + Math.floor((right - left) / 2);
            const sTime = new Date(this.gridInstance[mid].starttime);
            const eTime = new Date(this.gridInstance[mid].endtime);
            if (t >= sTime && t < eTime) return mid;else if (sTime > t) right = mid - 1;else left = mid + 1;
          }
          mid = Math.max(lim, left - 1);
          return mid;
        }
        _handleDown() {
          this.unpaintCell();
          this.unsetBoldText();
          if (this.currentlyFocusedRow < this.verticallyNonScrollableWindow) {
            let t = this.cellTimeTracker;
            this.currentlyFocusedRow++;
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            this.currentCellIndex = idx;
            this.updateCursor();
          } else if (this.D < this.channels.length) {
            let t = this.cellTimeTracker;
            this.scrollVertically(1);
            //---------------------------------
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            //---------------------------------
            this.currentCellIndex = idx;
            this.updateCursor();
          } else console.log("can't go any further ,it's the last row");
          this.setBoldText();
          this.paintCell();
        }
        _handleUp() {
          this.unpaintCell();
          this.unsetBoldText();
          if (this.currentlyFocusedRow > 0) {
            let t = this.cellTimeTracker;
            this.currentlyFocusedRow--;
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            this.currentCellIndex = idx;
            this.updateCursor();
          } else if (this.D > 8) {
            let t = this.cellTimeTracker;
            this.scrollVertically(-1);
            //---------------------------------
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            //---------------------------------
            this.currentCellIndex = idx;
            this.updateCursor();
          } else console.log("can't go any further , it's the first row");
          this.setBoldText();
          this.paintCell();
        }
        updateDayLabel(starttime) {
          let daylabel = this.tag('DayLabel');
          setTimeout(function () {
            let today = new Date();
            today.setHours(0);
            today.setMinutes(0);
            today.setSeconds(0);
            today.setMilliseconds(0);
            let t = today.getTime();
            t = starttime - t;
            let day = 24 * 60 * 60 * 1000;
            if (t < day) {
              daylabel.text = 'TODAY';
            } else if (t < 2 * day) {
              daylabel.text = 'TOMORROW';
            } else {
              let cellStartTime = new Date(starttime);
              daylabel.text = cellStartTime.getDate() + '-' + (cellStartTime.getMonth() + 1) + '-' + cellStartTime.getFullYear();
            }
          }, 0);
        }
        updateInfoLabels() {
          let currentCell = this.gridInstance[this.currentCellIndex];
          this.tag('ChannelName').text.text = this.channelGridInstance[this.currentlyFocusedRow].title.text;
          this.tag('ShowName').text.text = currentCell.txt;
          this.tag('ShowDetails').text.text = currentCell.description;
          let s = new Date(currentCell.starttime);
          let e = new Date(currentCell.endtime);
          let ehours = e.getHours();
          let eminutes = e.getMinutes();
          if (eminutes.toString().length < 2) eminutes = '0' + eminutes;
          if (ehours >= 12) {
            eminutes = eminutes + 'p';
            if (ehours > 12) {
              ehours -= 12;
            }
          }
          let shours = s.getHours();
          let sminutes = s.getMinutes();
          if (sminutes.toString().length < 2) {
            sminutes = '0' + sminutes;
          }
          if (shours > 12) {
            shours -= 12;
          }
          this.tag('ShowTimings').text.text = "".concat(shours, ":").concat(sminutes, " - ").concat(ehours, ":").concat(eminutes);
          this.updateDayLabel(currentCell.starttime);
        }
        updateCursor() {
          let x = this.gridInstance[this.currentCellIndex].x;
          let y = this.gridInstance[this.currentCellIndex].y;
          let w = this.gridInstance[this.currentCellIndex].w;
          let self = this;
          setTimeout(function () {
            self.updateInfoLabels();
          }, 0);
          this.cursorInstance.patchCursor(x, y, w);
        }
        $exit() {
          console.log('exiting from state - CellSelector');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class DTVPlayer extends lng$1.Component {
    static _template() {
      return {
        Player: {
          w: 1920,
          h: 1080
        }
      };
    }
    _firstEnable() {
      this.dtvApi = new DTVApi();
      this.appApi = new AppApi();
    }
    _handleBack() {
      this.dtvApi.exitChannel().then(res => {
        console.log("exit channel: ", JSON.stringify(res));
      }).catch(err => {
        console.log("failed to exit channel: ", JSON.stringify(err));
      });
      Router.back();
    }
    _handleLeft() {
      Router.focusWidget("ChannelOverlay");
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  //applauncher screen "will" be responsible for handling all overlays as widget and splash screens for apps(if required) | currently only handles settings overlay widget
  class AppLauncherScreen extends lng$1.Component {
    static _template() {
      return {
        Overlay: {
          w: 1920,
          h: 1080
        },
        SplashImage: {
          w: 1920,
          h: 1080,
          x: 960,
          y: 540,
          mount: 0.5,
          src: "",
          //set to a empty string/transparent image
          visible: false
        }
      };
    }
    showSplashImage(callsign) {
      if (this.splashImages[callsign]) {
        //splash image won't be shown if the callsign and image location is mapped in this.splashImages

        //first frame event
        this.firstFrameListener = this._thunder.on("org.rdk.RDKShell", "onApplicationFirstFrame", notification => {
          console.log("onApplicationFirstFrame notification from applauncherscreen: ", notification);
          if (notification.client === callsign.toLowerCase()) {
            console.log("firstframe event triggered hiding splash image");
            this.tag("SplashImage").src = ""; //set to a empty string/transparent image
            this.tag("SplashImage").visible = false;
            this.moveApptoFront(callsign);
            this.firstFrameListener.dispose(); //dispose listener after event is triggered for first time
          }
        });

        //to show the splash image
        this.splashTimeout && Registry.clearTimeout(this.splashTimeout);
        this.tag("SplashImage").src = Utils.asset(this.splashImages[callsign]);
        this.tag("SplashImage").visible = true;

        //to hide the splash image after 30 sec in case firstframe event failed
        this.splashTimeout = Registry.setTimeout(() => {
          console.log("timeout triggered hiding splash image");
          this.tag("SplashImage").src = ""; //set to a empty string/transparent image
          this.tag("SplashImage").visible = false;
          this.moveApptoFront(callsign);
          this.firstFrameListener.dispose(); //dispose the event listener incase event didnot trigger till 30s
        }, 30000);
      }
    }
    moveApptoFront(callsign) {
      //moving the launched app to front.
      console.log("moveToFront: ", callsign, "from applauncher");
      this._thunder.call("org.rdk.RDKShell", "moveToFront", {
        "client": callsign,
        "callsign": callsign
      }).catch(err => {
        console.error("failed to moveToFront : ", callsign, " ERROR: ", JSON.stringify(err), " | fail reason can be since app is already in front");
      });
    }
    _firstEnable() {
      console.log("app-overlay is enabled for firstTime");
      this.splashImages = {
        "Netflix": 'images/apps/App_Netflix_Splash.png'
      }; //mapping between callsigns and splash images
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS(config);
    }
    _focus() {
      console.log("app-overlay is focused");
    }
    _handleBack() {
      Router.navigate("menu");
    }
    _handleLeft() {
      console.log("Router History: ", Router.getHistory());
    }
    _handleRight() {
      console.log("getActiveWidget: ", Router.getActiveWidget());
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let api = null;
  var routes = {
    boot: queryParam => {
      let homeApi = new HomeApi();
      homeApi.setPartnerAppsInfo(queryParam.data);
      homeApi.getAPIKey().then(data => {
        if (data.data.length > 1) {
          api = data;
        }
      });
      return Promise.resolve();
    },
    // root: 'splash',
    routes: [...splashScreenRoutes.splashScreenRoutes, ...route$1.network, ...otherSettingsRoutes.otherSettingsRoutes, ...audioScreenRoutes.audioScreenRoutes, ...detailsScreenRoutes.detailsScreenRoutes, ...liveTvRoutes, {
      path: 'settings',
      component: SettingsScreen,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'failscreen',
      component: Failscreen
    }, {
      path: 'videoplayer',
      component: LightningPlayerControls,
      widgets: ['Volume']
    }, {
      path: 'usb',
      component: UsbAppsScreen,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'epg',
      component: Epg,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'apps',
      component: AppStore,
      widgets: ['Menu', 'Volume']
    }, {
      path: 'usb/player',
      component: AAMPVideoPlayer,
      widgets: ['Volume', "SettingsOverlay"]
    }, {
      path: 'usb/image',
      component: ImageViewer,
      widgets: ['Volume']
    }, {
      path: 'image',
      component: ImageViewer,
      widgets: ['Volume']
    }, {
      path: 'ui',
      component: UIList,
      widgets: ['Volume']
    }, {
      path: 'menu',
      component: MainView,
      before: page => {
        const homeApi = new HomeApi();
        page.tvShowItems = homeApi.getTVShowsInfo();
        // page.usbApps = homeApi.getTVShowsInfo()
        if (api) {
          page.setGracenoteData(api);
        }
        return Promise.resolve();
      },
      widgets: ['Menu', 'Fail', 'Volume']
    }, {
      path: 'tv-overlay/:type',
      component: TvOverlayScreen,
      options: {
        preventStorage: true
      }
    }, {
      path: 'overlay/volume',
      component: Volume
    }, {
      path: 'applauncher',
      component: AppLauncherScreen,
      widgets: ['SettingsOverlay'] //other overlays needs to be added to improve ovelay functionality.
    }, {
      path: 'player',
      component: AAMPVideoPlayer,
      widgets: ['Volume', "SettingsOverlay"]
    }, {
      path: 'dtvplayer',
      component: DTVPlayer,
      widgets: ['Volume', 'TvOverlays', 'ChannelOverlay', "SettingsOverlay"]
    }, {
      path: '!',
      component: Error$1
    }, {
      path: '*',
      component: LogoScreen
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in side panel.
   */
  class SidePanelItem extends lng$1.Component {
    /**
     * Function to render various elements in the side panel item.
     */
    static _template() {
      return {
        Item: {
          rect: true,
          Image: {
            w: 70,
            H: 70
          },
          Title: {
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: 0xffffffff
            }
          }
        }
      };
    }
    _init() {
      this.tag('Image').patch({
        src: Utils.asset(this.data.url),
        w: this.w,
        h: this.h,
        scale: this.unfocus
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.focus,
        color: CONFIG.theme.hex
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus,
        color: 0xffffffff
      });
    }
    setColor() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.focus,
        color: CONFIG.theme.hex
      });
    }
    clearColor() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus,
        color: 0xffffffff
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /** Class for side panel in home UI */
  class SidePanel extends lng$1.Component {
    static _template() {
      return {
        color: 0xff000000,
        rect: true,
        y: 270,
        w: 200,
        h: 810,
        SidePanel: {
          x: 0,
          y: 127,
          w: 240,
          h: 750,
          type: lng$1.components.ListComponent,
          roll: true,
          horizontal: false,
          invertDirection: true
        }
      };
    }
    _init() {
      this.homeApi = new HomeApi();
      this.tag('SidePanel').sidePanelItems = this.homeApi.getSidePanelInfo();
      this.sidePanelData = this.homeApi.getSidePanelInfo();
      this._setState('SidePanel');
      this.indexVal = 0;
      this.prevIndex = 0;
    }

    /**
     * Function to set items in side panel.
     */
    set sidePanelItems(items) {
      this.tag('SidePanel').patch({
        x: 105
      });
      this.tag('SidePanel').items = items.map((info, index) => {
        this.data = info;
        return {
          w: 50,
          h: 50,
          y: index == 0 ? 20 : (index + 1) * 20,
          type: SidePanelItem,
          data: info,
          focus: 1.1,
          unfocus: 1,
          x_text: 100,
          y_text: 160,
          text_focus: 1.1,
          text_unfocus: 0.9
        };
      });
      this.tag('SidePanel').start();
    }

    /**
     * Function to reset items in side panel.
     */
    set resetSidePanelItems(items) {
      this.tag('SidePanel').patch({
        x: 0
      });
      this.tag('SidePanel').items = items.map((info, index) => {
        return {
          w: 204,
          h: 184,
          y: index == 0 ? 25 : index == 1 ? 105 : index == 2 ? 260 : 470,
          type: SidePanelItem,
          data: info,
          focus: 0.7,
          unfocus: 0.4,
          x_text: 100,
          y_text: 160,
          text_focus: 1.1,
          text_unfocus: 0.9
        };
      });
      this.tag('SidePanel').start();
    }
    /**
     * Function to set scaling to side panel.
     */
    set scale(scale) {
      this.tag('SidePanel').patch({
        scale: scale
      });
    }

    /**
     * Function to set x coordinate of side panel.
     */
    set x(x) {
      this.tag('SidePanel').patch({
        x: x
      });
    }

    /**
     * Function to set index value of side panel.
     */
    set index(index) {
      this.tag('SidePanel').items[this.prevIndex].clearColor();
      this.indexVal = index;
    }
    set deFocus(val) {
      if (val) {
        this.tag('SidePanel').items[this.prevIndex].clearColor();
      } else {
        this.tag('SidePanel').items[this.prevIndex].setColor();
      }
    }
    set scrollableLastRow(bool) {
      this.isLastRowScrollable = bool;
    }
    static _states() {
      return [class SidePanel extends this {
        _getFocused() {
          if (this.tag('SidePanel').length) {
            return this.tag('SidePanel').items[this.indexVal];
          }
        }
        _handleKey(key) {
          if (key.keyCode == keyMap.ArrowRight || key.keyCode == keyMap.Enter) {
            if (this.prevIndex != this.indexVal) {
              this.tag('SidePanel').items[this.prevIndex].clearColor();
            }
            this.prevIndex = this.indexVal;
            this.fireAncestors('$goToMainView', this.tag('SidePanel').items[this.indexVal], this.indexVal);
          } else if (key.keyCode == keyMap.ArrowDown) {
            if (this.tag('SidePanel').length - 1 != this.indexVal) {
              this.indexVal = this.indexVal + 1;
            }
            return this.tag('SidePanel').items[this.indexVal];
          } else if (key.keyCode == keyMap.ArrowUp) {
            if (0 === this.indexVal) {
              this.fireAncestors('$goToTopPanel', 0);
            } else {
              this.indexVal = this.indexVal - 1;
              return this.tag('SidePanel').items[this.indexVal];
            }
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /** Class for top panel in home UI */
  class TopPanel extends lng$1.Component {
    static _template() {
      return {
        TopPanel: {
          color: 0xff000000,
          rect: true,
          w: 1920,
          h: 270,
          Mic: {
            x: 105,
            // zIndex: 2,
            y: 87,
            src: Utils.asset('/images/topPanel/microphone.png'),
            w: 50,
            h: 50
          },
          Logo: {
            x: 200,
            y: 90,
            src: Utils.asset('/images/' + CONFIG.theme.logo),
            w: 227,
            h: 43
          },
          Page: {
            x: 200,
            y: 184,
            // mountY: 0.5,
            text: {
              fontSize: 40,
              text: Language.translate('home'),
              textColor: CONFIG.theme.hex,
              fontStyle: 'bolder',
              fontFace: CONFIG.language.font,
              wordWrapWidth: 1720,
              maxLines: 1
            }
          },
          Settings: {
            x: 1825 - 105 - 160 - 37 + 30,
            y: 111,
            mountY: 0.5,
            src: Utils.asset('/images/topPanel/setting.png'),
            w: 37,
            h: 37
          },
          Time: {
            x: 1920 - 105 - 160,
            y: 111,
            mountY: 0.5,
            text: {
              text: '',
              fontSize: 35,
              fontFace: CONFIG.language.font
            },
            w: 160,
            h: 60
          }
        }
      };
    }
    changeTimeZone(time) {
      this.zone = time;
    }
    updateZone(res) {
      this.zone = res;
    }
    _construct() {
      this.indexVal = 1;
      this.audiointerval = null;
      this.zone = null; // declaring this variable to keep track of zone changes
      this.appApi = new AppApi();
      this.appApi.getZone().then(res => {
        this.updateZone(res);
      });
      this.zone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    set index(index) {
      this.indexVal = index;
    }
    _focus() {
      this._setState('Setting');
      this.tag('Settings').color = CONFIG.theme.hex;
    }
    set changeText(text) {
      this.tag('Page').text.text = text;
      if (text === 'Home') {
        this.tag('Settings').color = 0xffffffff;
      }
    }

    /**
    *
    * @param {boolean} toggle
    * Function to change the mic icon.
    */

    set changeMic(toggle) {
      if (toggle) {
        this.tag('Mic').src = Utils.asset('/images/topPanel/microphone_mute.png');
      } else {
        this.tag('Mic').src = Utils.asset('/images/topPanel/microphone.png');
      }
    }
    _build() {
      Registry.setInterval(() => {
        let _date = this._updateTime(this.zone);
        if (this.zone) {
          this.tag('Time').patch({
            text: {
              text: _date.strTime
            }
          });
        }
      }, 1000);
    }
    updateIcon(tagname, url) {
      this.tag(tagname).patch({
        src: Utils.asset(url)
      });
    }

    /**
     * Function to update time in home UI.
     */
    _updateTime(zone) {
      if (zone != null) {
        let date = new Date();
        date = new Date(date.toLocaleString('en-US', {
          timeZone: zone
        }));
        // get day
        let days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        let strDay = days[date.getDay()];

        // get month
        let month = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        let strMonth = month[date.getMonth()];
        let strDate = date.toLocaleDateString('en-US', {
          day: '2-digit'
        }) + ' ' + strMonth + ' ' + date.getFullYear();
        let hours = date.getHours();
        let minutes = date.getMinutes();
        let ampm = hours >= 12 ? 'pm' : 'am';
        hours = hours % 12;
        hours = hours ? hours : 12;
        minutes = minutes < 10 ? '0' + minutes : minutes;
        let strTime = hours + ':' + minutes + ' ' + ampm;
        return {
          strTime,
          strDay,
          strDate
        };
      } else {
        return "";
      }
    }
    static _states() {
      return [class Mic extends this {
        $enter() {
          this.tag('Mic').color = CONFIG.theme.hex;
        }
        _getFocused() {
          this.tag('Mic').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('Mic').color = 0xffffffff;
        }
        _handleKey(key) {
          if (key.keyCode == keyMap.ArrowRight) {
            this._setState('Setting');
          } else if (key.keyCode == keyMap.ArrowDown) {
            this.tag('Mic').color = 0xffffffff;
            this.fireAncestors('$goToSidePanel', 0);
          }
        }
      }, class Setting extends this {
        $enter() {
          this.tag('Settings').color = CONFIG.theme.hex;
        }
        _handleKey(key) {
          if (key.keyCode === keyMap.ArrowDown) {
            Router.focusPage();
            this.tag('Settings').color = 0xffffffff;
          } else if (key.keyCode === keyMap.ArrowLeft) ; else if (key.keyCode === keyMap.Enter) {
            //this.tag('Page').text.text = Language.translate('settings')
            Router.navigate('settings');
            Router.focusPage();
            this.tag('Settings').color = 0xffffffff;
          }
        }
        $exit() {
          this.tag('Settings').color = 0xffffffff;
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var route = {
    1: () => {
      Router.navigate('epg');
      Router.focusPage();
    },
    3: () => {
      Router.navigate('apps');
      Router.focusPage();
    },
    'default': () => {
      Router.navigate('menu');
      Router.focusPage();
    }
  };
  class Menu extends lng$1.Component {
    static _template() {
      return {
        TopPanel: {
          type: TopPanel
        },
        SidePanel: {
          type: SidePanel
        }
      };
    }
    pageTransition() {
      return 'down';
    }
    _init() {
      this.homeApi = new HomeApi();
      this.tag('SidePanel').sidePanelItems = this.homeApi.getSidePanelInfo();
    }
    _focus() {
      if (!this.mainView) {
        this.mainView = Router.activePage();
      }
      this._setState('SidePanel');
    }
    _handleRight() {
      Router.focusPage();
    }
    $goToTopPanel() {
      this._setState('TopPanel');
      Router.focusWidget('Menu');
    }
    $goToSidePanel() {
      this._setState('SidePanel');
    }
    $goToMainView(sidePanelInstance, index) {
      if (route[index]) {
        route[index]();
      } else {
        route['default']();
      }
      sidePanelInstance.setColor();
      return;
    }
    refreshMainView() {
      if (this.mainView) {
        this.mainView.refreshFirstRow();
      }
    }
    setIndex(index) {
      this.tag('SidePanel').index = index;
    }
    notify(val) {
      if (val === 'TopPanel') {
        Router.focusWidget('Menu');
        this._setState('TopPanel');
      }
    }
    $scroll(val) {
      if (this.mainView) {
        this.mainView.scroll(val);
      }
    }
    updateTimeZone(timezone) {
      this.tag('TopPanel').changeTimeZone(timezone);
    }
    updateTopPanelText(text) {
      this.tag('TopPanel').changeText = text;
    }
    static _states() {
      return [class SidePanel extends this {
        _getFocused() {
          return this.tag('SidePanel');
        }
      }, class TopPanel extends this {
        _getFocused() {
          return this.tag('TopPanel');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$4 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  const thunder$5 = thunderJS(config$4);
  new AppApi();
  function keyIntercept() {
    const rdkshellCallsign = 'org.rdk.RDKShell';
    thunder$5.Controller.activate({
      callsign: rdkshellCallsign
    }).then(result => {
      console.log('Successfully activated RDK Shell');
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call('org.rdk.RDKShell', 'setFocus', {
        client: 'ResidentApp'
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.AudioVolumeMute,
        modifiers: []
      }).then(result => {
        console.log('addKeyIntercept success');
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.on(rdkshellCallsign, 'onSuspended', notification => {
        if (notification) {
          console.log('onSuspended notification from KeyIntercept: ' + notification.client);
        }
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Escape,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.F1,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Inputs_Shortcut,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Picture_Setting_Shortcut,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Power,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Settings_Shortcut,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Youtube,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Amazon,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Netflix,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.F7,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.AudioVolumeUp,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.AudioVolumeDown,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'foreground',
        keyCode: keyMap.AudioVolumeDown,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'foreground',
        keyCode: keyMap.AudioVolumeUp,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'foreground',
        keyCode: keyMap.AudioVolumeMute,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.MediaFastForward,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: 142,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Home,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.MediaRewind,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'ResidentApp',
        keyCode: keyMap.Pause,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'Cobalt',
        keyCode: keyMap.Escape,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'Amazon',
        keyCode: keyMap.Escape,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'Cobalt',
        keyCode: keyMap.Home,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'Amazon',
        keyCode: keyMap.Home,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'Cobalt',
        keyCode: keyMap.Backspace,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$5.call(rdkshellCallsign, 'addKeyIntercept', {
        client: 'Amazon',
        keyCode: keyMap.Backspace,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    });
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for HDMI Output Screen.
   */
  var appApi$4 = new AppApi();
  class HdmiOutputScreen extends lng$1.Component {
    static _template() {
      return {
        HdmiOutputScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _init() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this.loadingAnimation.start();
      var options = [];
      appApi$4.getSoundMode().then(result => {
        appApi$4.getSupportedAudioModes().then(res => {
          options = [...res.supportedAudioModes];
          this.tag('HdmiOutputScreenContents').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').items = options.map((item, index) => {
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: result.soundMode === item ? true : false,
              item: item,
              videoElement: false
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this._setState("Options");
        }).catch(err => {
          console.log('error', err);
        });
      }).catch(err => {
        console.log('error', JSON.stringify(err));
      });
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          console.log('focusedHDMI');
          return this.tag('HdmiOutputScreenContents.List').element;
        }
        _handleDown() {
          this.tag('HdmiOutputScreenContents.List').setNext();
        }
        _handleUp() {
          this.tag('HdmiOutputScreenContents.List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**s
   * Class for Audio screen.
   */

  class AudioScreen extends lng$1.Component {
    static _template() {
      return {
        AudioScreenOverlay: {
          x: 200,
          y: 275,
          AudioOutput: {
            alpha: 0.3,
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Audio Output: ') + " HDMI",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputMode: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Output Mode: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          DynamicRange: {
            alpha: 0.3,
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Full Dynamic Range'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AudioLanguage: {
            y: 270,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Audio Language: ') + "Auto",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NavigationFeedback: {
            y: 360,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Navigation Feedback'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 66,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOnWhite.png')
            }
          },
          Bluetooth: {
            alpha: 0.3,
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Bluetooth: ') + "None",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        HdmiOutputScreen: {
          type: HdmiOutputScreen,
          visible: false
        }
      };
    }
    _init() {
      this.appApi = new AppApi();
      this._setState('OutputMode');
    }
    _focus() {
      this._setState('OutputMode');
      this.appApi.getSoundMode().then(result => {
        this.tag('OutputMode.Title').text.text = Language.translate('Output Mode: ') + result.soundMode;
      });
    }
    hide() {
      this.tag('AudioScreenOverlay').visible = false;
    }
    show() {
      this.tag('AudioScreenOverlay').visible = true;
    }
    static _states() {
      return [class AudioOutput extends this {
        $enter() {
          this.tag('AudioOutput')._focus();
        }
        $exit() {
          this.tag('AudioOutput')._unfocus();
        }
        _handleDown() {
          this._setState('OutputMode');
        }
        _handleEnter() {
          this._setState('HdmiOutputScreen');
        }
      }, class OutputMode extends this {
        $enter() {
          this.tag('OutputMode')._focus();
        }
        $exit() {
          this.tag('OutputMode')._unfocus();
        }
        _handleUp() {
          // this._setState('AudioOutput')
        }
        _handleDown() {
          // this._setState('DynamicRange');
        }
        _handleEnter() {
          console.log("hdmioutputscreen");
          this._setState('HdmiOutputScreen');
        }
      }, class DynamicRange extends this {
        $enter() {
          this.tag('DynamicRange')._focus();
        }
        $exit() {
          this.tag('DynamicRange')._unfocus();
        }
        _handleUp() {
          this._setState('OutputMode');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          /**
           * This handle Enter has api calls -
           * 1 - get DRC Mode which doesnot return a drc mode and the success value is mostly false
           * 2- set Volume - able to set the value to 100
           * 3- get Volume - able to get the volume successfully as well
           * 4- 
           * 
           */
          //console.log(`Enter input was given to dynamic range ... `);
          // gets the drc mode
          this.appApi.getDRCMode().then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.setVolumeLevel("HDMI0", 100).then(res => {
            this.appApi.getVolumeLevel().catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
          this.appApi.getConnectedAudioPorts().then(res => {}).catch(err => {
            console.log(err);
          });
          // gets the enabled Audio Port
          this.appApi.getEnableAudioPort("HDMI0").then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.getSupportedAudioPorts().catch(err => {
            console.log("Error while getting the supported Audio ports ie. ".concat(err));
          });

          // set enable Audio POrt
          this.appApi.setEnableAudioPort("HDMI0").then(res => {
            this.appApi.getEnableAudioPort("HDMI0").then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });

          // set zoom setting ,possible values : FULL, NONE, Letterbox 16x9, Letterbox 14x9, CCO, PanScan, Letterbox 2.21 on 4x3, Letterbox 2.21 on 16x9, Platform, Zoom 16x9, Pillarbox 4x3, Widescreen 4x3
          this.appApi.setZoomSetting("FULL").then(res => {
            this.appApi.getZoomSetting().then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
        }
      }, class NavigationFeedback extends this {
        $enter() {
          this.tag('NavigationFeedback')._focus();
        }
        $exit() {
          this.tag('NavigationFeedback')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          //
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag('Bluetooth')._focus();
        }
        $exit() {
          this.tag('Bluetooth')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
      }, class HdmiOutputScreen extends this {
        $enter() {
          this.hide();
          console.log("hdmioutputscreenEnter");
          this.tag('HdmiOutputScreen').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Audio  Output Mode');
        }
        $exit() {
          this.tag("HdmiOutputScreen").visible = false;
          this.show();
          this.fireAncestors('$updatePageTitle', 'Settings  Audio');
        }
        _getFocused() {
          console.log("hdmioutputscreenfocused");
          return this.tag('HdmiOutputScreen');
        }
        _handleBack() {
          console.log("hdmioutputscreenbackHDMI");
          this._setState("OutputMode");
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$4 = thunderJS({
    host: '127.0.0.1',
    port: 9998,
    default: 1
  });

  /**
   * Class for Resolution Screen.
   */

  class ResolutionScreen extends lng$1.Component {
    static _template() {
      return {
        ResolutionScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.appApi.activateDisplaySettings();
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      thunder$4.on('org.rdk.DisplaySettings', 'resolutionChanged', notification => {
        const items = this.tag('List').items;
        items.forEach(element => {
          element.tag('Item.Tick').visible = false;
          if (element._item === notification.resolution) {
            element.tag('Item.Tick').visible = true;
          }
        });
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _focus() {
      this.loadingAnimation.start();
      var options = [];
      var sIndex = 0;
      this.appApi.getResolution().then(resolution => {
        this.appApi.getSupportedResolutions().then(res => {
          options = [...res];
          this.tag('ResolutionScreenContents').h = options.length * 90;
          this.tag('ResolutionScreenContents.List').h = options.length * 90;
          this.tag('List').items = options.map((item, index) => {
            var bool = false;
            if (resolution === item) {
              bool = true;
              sIndex = index;
            }
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: bool,
              item: item,
              videoElement: true
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this.tag('List').setIndex(sIndex);
          this._setState("Options");
        }).catch(err => {
          console.log("error while fetching the supported resolution ".concat(err));
        });
      });
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video screen.
   */

  class VideoScreen extends lng$1.Component {
    static _template() {
      return {
        VideoScreenContents: {
          x: 200,
          y: 275,
          Resolution: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Resolution: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDR: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('High Dynamic Range: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MatchContent: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Match Content: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputFormat: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Output Format:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Chroma: {
            alpha: 0.3,
            // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Chroma:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDCP: {
            y: 450,
            h: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('HDCP Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        },
        ResolutionOverlay: {
          type: ResolutionScreen,
          visible: false
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('Resolution');
    }
    _focus() {
      this._appApi.getResolution().then(resolution => {
        this.tag("Resolution.Title").text.text = Language.translate('Resolution: ') + resolution;
      }).catch(err => {
        console.log("Error fetching the Resolution");
      });
      this._appApi.getHDCPStatus().then(result => {
        if (result.isHDCPCompliant && result.isHDCPEnabled) {
          this.tag("HDCP.Title").text.text = "".concat(Language.translate('HDCP Status: '), "Enabled, Version: ").concat(result.currentHDCPVersion);
        } else {
          this.tag("HDCP.Title").text.text = "".concat(Language.translate('HDCP Status: '), "Not Supported ");
        }
      });
      this._appApi.getHDRSetting().then(result => {
        const availableHDROptions = {
          "HdrOff": "Off",
          "Hdr10": "HDR 10",
          "Hdr10Plus": "HDR 10+",
          "HdrHlg": "HLG",
          "HdrDolbyvision": "Dolby Vision",
          "HdrTechnicolor": "Technicolor HDR"
        };
        this.tag("HDR.Title").text.text = Language.translate('High Dynamic Range: ') + availableHDROptions[result];
      });
      this._setState('Resolution');
    }
    hide() {
      this.tag('VideoScreenContents').visible = false;
    }
    show() {
      this.tag('VideoScreenContents').visible = true;
    }
    static _states() {
      return [class Resolution extends this {
        $enter() {
          this.tag('Resolution')._focus();
        }
        $exit() {
          this.tag('Resolution')._unfocus();
        }
        _handleDown() {
          this._setState('HDR');
        }
        _handleEnter() {
          this._setState("ResolutionOverlay");
        }
      }, class HDR extends this {
        $enter() {
          this.tag('HDR')._focus();
        }
        $exit() {
          this.tag('HDR')._unfocus();
        }
        _handleUp() {
          this._setState('Resolution');
        }
        _handleDown() {
          this._setState('HDCP');
        }
        _handleEnter() {
          //
        }
      }, class MatchContent extends this {
        $enter() {
          this.tag('MatchContent')._focus();
        }
        $exit() {
          this.tag('MatchContent')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleDown() {
          this._setState('OutputFormat');
        }
        _handleEnter() {
          //
        }
      }, class OutputFormat extends this {
        $enter() {
          this.tag('OutputFormat')._focus();
        }
        $exit() {
          this.tag('OutputFormat')._unfocus();
        }
        _handleUp() {
          this._setState('MatchContent');
        }
        _handleDown() {
          this._setState('Chroma');
        }
        _handleEnter() {
          //
        }
      }, class Chroma extends this {
        $enter() {
          this.tag('Chroma')._focus();
        }
        $exit() {
          this.tag('Chroma')._unfocus();
        }
        _handleUp() {
          this._setState('OutputFormat');
        }
        _handleDown() {
          // this._setState('HDCP') 
        }
        _handleEnter() {
          //
        }
      }, class HDCP extends this {
        // class not required
        $enter() {
          this.tag('HDCP')._focus();
        }
        $exit() {
          this.tag('HDCP')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleEnter() {
          //
        }
      }, class ResolutionOverlay extends this {
        $enter() {
          this.hide();
          this.tag('ResolutionOverlay').visible = true;
          this.fireAncestors('$updatePageTitle', "Settings  Video  Resolution");
        }
        $exit() {
          this.tag('ResolutionOverlay').visible = false;
          this.show();
          this.fireAncestors('$updatePageTitle', "Settings  Video");
        }
        _getFocused() {
          return this.tag('ResolutionOverlay');
        }
        _handleBack() {
          this._setState('Resolution');
        }
        // $updateResolution(value) {
        //   this.tag('Resolution.Title').text.text = 'Resolution: ' + value;
        // }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
    * Class for Other Settings Screen.
    */

  var appApi$3 = new AppApi();
  var defaultInterface = "";
  var currentInterface = [];
  class NetworkInfo extends lng$1.Component {
    static _template() {
      return {
        NetworkInfoScreenContents: {
          x: 200,
          y: 275,
          Status: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          ConnectionType: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Connection Type: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          IPAddress: {
            //alpha: 0.3, // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('IP Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Gateway: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Gateway: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MACAddress: {
            //alpha: 0.3, // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('MAC Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          InternetProtocol: {
            //alpha: 0.3, // disabled
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Internet Protocol: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SSID: {
            //alpha: 0.3, // disabled
            y: 540,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('SSID: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SignalStrength: {
            //alpha: 0.3, // disabled
            y: 630,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Signal Strength: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        }
      };
    }
    getIPSetting(interfaceName) {
      appApi$3.getIPSetting(interfaceName).then(result => {
        this.tag('InternetProtocol.Value').text.text = result.ipversion;
      }).catch(err => console.log(err));
    }
    _focus() {
      //Getting the default interface
      appApi$3.getDefaultInterface().then(result => {
        defaultInterface = result.interface;
        this.getIPSetting(defaultInterface);
        if (defaultInterface === "WIFI") {
          this.tag("ConnectionType.Value").text.text = "Wireless";
          this.tag("SSID").alpha = 1;
          this.tag("SignalStrength").alpha = 1;
        } else if (defaultInterface === "ETHERNET") {
          this.tag("ConnectionType.Value").text.text = "Ethernet";
          this.tag("SSID").alpha = 0;
          this.tag("SignalStrength").alpha = 0;
        } else {
          this.tag("ConnectionType.Value").text.text = "NA";
          this.tag("Status.Value").text.text = "Disconnected";
          this.tag("IPAddress.Value").text.text = "NA";
          this.tag("Gateway.Value").text.text = "NA";
          this.tag("MACAddress.Value").text.text = "NA";
        }

        //Filtering the current interface
        appApi$3.getInterfaces().then(result => {
          currentInterface = result.interfaces.filter(data => data.interface === defaultInterface);
          //console.log(currentInterface);
          if (currentInterface[0].connected) {
            this.tag("Status.Value").text.text = "Connected";
            appApi$3.getConnectedSSID().then(result => {
              if (parseInt(result.signalStrength) >= -50) {
                this.tag("SignalStrength.Value").text.text = "Excellent";
              } else if (parseInt(result.signalStrength) >= -60) {
                this.tag("SignalStrength.Value").text.text = "Good";
              } else if (parseInt(result.signalStrength) >= -67) {
                this.tag("SignalStrength.Value").text.text = "Fair";
              } else {
                this.tag("SignalStrength.Value").text.text = "Poor";
              }
              this.tag("SSID.Value").text.text = "".concat(result.ssid);
            }).catch(error => console.log(error));
            appApi$3.getIPSetting(defaultInterface).then(result => {
              this.tag('IPAddress.Value').text.text = "".concat(result.ipaddr);
              this.tag("Gateway.Value").text.text = "".concat(result.gateway);
            }).catch(error => console.log(error));
          } else {
            this.tag('Status.Value').text.text = "Disconnected";
          }
          this.tag('MACAddress.Value').text.text = "".concat(currentInterface[0].macAddress);
        }).catch(error => console.log(error));
      }).catch(error => console.log(error));
    }
    _unfocus() {
      this.tag('SSID.Value').text.text = 'NA';
      this.tag('SignalStrength.Value').text.text = 'NA';
      this.tag('MACAddress.Value').text.text = 'NA';
      this.tag('Gateway.Value').text.text = 'NA';
      this.tag('IPAddress.Value').text.text = 'NA';
      this.tag('ConnectionType.Value').text.text = 'NA';
      this.tag('InternetProtocol.Value').text.text = 'NA';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$1 = new Wifi();
  class JoinAnotherNetworkComponent extends lng$1.Component {
    handleDone() {
      var securityCode = this.securityCodes[this.securityCodeIndex].value;
      if (!this.textCollection['EnterSSID']) {
        this._setState("EnterSSID");
      } else if (securityCode < 0 || securityCode > 14) {
        this._setState("EnterSecurity");
      } else if (securityCode !== 0 && !this.textCollection['EnterPassword']) {
        this._setState("EnterPassword");
      } else {
        if (this.textCollection['EnterSecurity'] === "0") {
          this.textCollection['EnterPassword'] = "";
          this.tag("Pwd").text.text = "";
        }
        var self = this;
        this.startConnectForAnotherNetwork({
          ssid: self.textCollection['EnterSSID'],
          security: securityCode
        }, self.textCollection['EnterPassword']);
      }
    }

    // startConnectForAnotherNetwork(device, passphrase) {
    //   wifi.connect({ ssid: device.ssid, security: device.security }, passphrase)
    //   Router.back()
    // }
    startConnectForAnotherNetwork(device, passphrase) {
      wifi$1.connect({
        ssid: device.ssid,
        security: device.security
      }, passphrase).then(() => {
        wifi$1.saveSSID(device.ssid, passphrase, device.security).then(response => {
          if (response.result === 0 && response.success === true) {
            wifi$1.SaveSSIDKey(this._item.ssid).then(persistenceResponse => {
              console.log(persistenceResponse);
            });
            // Router.back()
          } else if (response.result !== 0) {
            wifi$1.clearSSID().then(response => {
              // console.log(response)
              // Router.back()
            });
          }
        });
      });
      this.fireAncestors("$navigateBack");
    }
    static _template() {
      return {
        Text: {
          x: 758,
          y: 70,
          text: {
            text: "Find and join a WiFi network",
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: CONFIG.theme.hex
          }
        },
        BorderTop: {
          x: 190,
          y: 130,
          w: 1488,
          h: 2,
          rect: true
        },
        Network: {
          x: 190,
          y: 176,
          text: {
            text: "Network Name: ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        NetworkBox: {
          x: 400,
          y: 160,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        NetworkText: {
          x: 420,
          y: 170,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        NetworkType: {
          x: 190,
          y: 246,
          text: {
            text: "Security: ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        TypeBox: {
          x: 400,
          y: 230,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false),
          ArrowForward: {
            h: 30,
            w: 45,
            y: 15,
            x: 1220,
            src: Utils.asset('images/settings/Arrow.png')
          },
          ArrowBackward: {
            h: 30,
            w: 45,
            x: 10,
            scaleX: -1,
            y: 15,
            src: Utils.asset('images/settings/Arrow.png')
          }
        },
        TypeText: {
          x: 470,
          y: 263,
          mountY: 0.5,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        Password: {
          x: 190,
          y: 316,
          text: {
            text: "Password:",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        PasswordBox: {
          x: 400,
          y: 300,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        Pwd: {
          x: 420,
          y: 310,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        BorderBottom: {
          x: 190,
          y: 396,
          w: 1488,
          h: 2,
          rect: true
        },
        Keyboard: {
          y: 437,
          x: 400,
          type: Keyboard,
          visible: true,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.qwerty
        }
      };
    }
    _focus() {
      this._setState('EnterSSID');
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': ''
      };
      this.tag('Pwd').text.text = "";
      this.tag("NetworkText").text.text = "";
      this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
      if (this.securityCodes[this.securityCodeIndex].value === 0) {
        this.pwdUnReachable = true;
        this.tag("PasswordBox").alpha = 0.5;
        this.tag("Password").alpha = 0.5;
      } else {
        this.pwdUnReachable = false;
        this.tag("PasswordBox").alpha = 1;
        this.tag("Password").alpha = 1;
      }
    }
    static _states() {
      return [class EnterSSID extends this {
        $enter() {
          this.tag('NetworkBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("EnterSecurity");
        }
        _handleEnter() {
          this._setState('Keyboard');
        }
        $exit() {
          this.tag('NetworkBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterSecurity extends this {
        $enter() {
          this.tag("TypeBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSSID");
        }
        isPasswordUnReachable(secCode) {
          if (secCode === 0) {
            this.tag("PasswordBox").alpha = 0.5;
            this.tag("Password").alpha = 0.5;
            return true;
          } else {
            this.tag("PasswordBox").alpha = 1;
            this.tag("Password").alpha = 1;
            return false;
          }
        }
        _handleLeft() {
          this.securityCodeIndex = (15 + --this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleEnter() {
          this.handleDone();
        }
        _handleRight() {
          this.securityCodeIndex = (15 + ++this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleDown() {
          if (!this.pwdUnReachable) {
            this._setState("EnterPassword");
          }
        }
        $exit() {
          this.tag("TypeBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterPassword extends this {
        $enter() {
          if (this.pwdUnReachable) {
            this._setState("EnterSecurity");
          }
          this.tag('PasswordBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleDown() {
          this._setState("EnterSSID");
        }
        _handleEnter() {
          this._setState('Keyboard');
        }
        $exit() {
          this.tag('PasswordBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'EnterSSID') {
            this.element = 'NetworkText';
          }
          if (this.prevState === 'EnterPassword') {
            this.element = 'Pwd';
          }
          if (this.prevState === 'EnterSecurity') {
            this.element = 'TypeText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Clear') {
            this.textCollection[this.prevState] = this.textCollection[this.prevState].substring(0, this.textCollection[this.prevState].length - 1);
            this.tag(this.element).text.text = this.textCollection[this.prevState];
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.textCollection[this.prevState] += ' ';
            this.tag(this.element).text.text = this.textCollection[this.prevState];
          } else if (key === 'Delete') {
            this.textCollection[this.prevState] = '';
            this.tag(this.element).text.text = this.textCollection[this.prevState];
          } else {
            this.textCollection[this.prevState] += key;
            this.tag(this.element).text.text = this.textCollection[this.prevState];
          }
        }
        _handleBack() {
          this._setState(this.prevState);
        }
      }];
    }
    _init() {
      this.securityCodeIndex = 0;
      this.pwdUnReachable = true;
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': '0'
      };
      this.securityCodes = [{
        name: "Open/None (Unsecure)",
        value: 0
      }, {
        name: "WEP - Deprecated, not needed",
        value: 1
      }, {
        name: "WEP",
        value: 2
      }, {
        name: "WPA Personal TKIP",
        value: 3
      }, {
        name: "WPA Personal AES",
        value: 4
      }, {
        name: "WPA2 Personal TKIP",
        value: 5
      }, {
        name: "WPA2 Personal AES",
        value: 6
      }, {
        name: "WPA Enterprise TKIP",
        value: 7
      }, {
        name: "WPA Enterprise AES",
        value: 8
      }, {
        name: "WPA2 Enterprise TKIP",
        value: 9
      }, {
        name: "WPA2 Enterprise AES",
        value: 10
      }, {
        name: "Mixed Personal",
        value: 11
      }, {
        name: "Mixed Enterprise",
        value: 12
      }, {
        name: "WPA3 Personal AES",
        value: 13
      }, {
        name: "WPA3 Personal SAE",
        value: 14
      }];
      this.tag("Pwd").text.text = this.textCollection['EnterPassword'];
      this.tag("NetworkText").text.text = this.textCollection['EnterSSID'];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class WifiPairingScreen extends lng$1.Component {
    static _template() {
      return {
        PairingScreen: {
          Title: {
            x: 960,
            y: 95,
            mountX: 0.5,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          RectangleWithColor: {
            x: 180,
            y: 164,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          PasswordLabel: {
            x: 180,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: 'Password: ',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          Pwd: {
            x: 437,
            y: 240,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              wordWrapWidth: 1000,
              wordWrap: false,
              textOverflow: 'ellipsis'
            }
          },
          PasswordBox: {
            x: 417,
            y: 208,
            zIndex: 2,
            texture: lng$1.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false)
          },
          PasswrdSwitch: {
            h: 45,
            w: 66.9,
            x: 1656,
            y: 255,
            zIndex: 2,
            type: PasswordSwitch,
            mount: 0.5
          },
          ShowPassword: {
            x: 1398,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: 'Show Password',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          List: {
            x: 417,
            y: 331,
            type: lng$1.components.ListComponent,
            w: 1080,
            h: 400,
            itemSize: 28,
            horizontal: true,
            invertDirection: false,
            roll: true,
            zIndex: 2
          },
          RectangleWithColor2: {
            x: 180,
            y: 451,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          KeyBoard: {
            y: 501,
            x: 420,
            type: Keyboard,
            visible: true,
            zIndex: 2,
            formats: KEYBOARD_FORMATS.qwerty
          }
        }
      };
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    item(item) {
      this.star = "";
      this.passwd = "";
      this.tag("Pwd").text.text = "";
      this.tag('Title').text = item.ssid;
      var options = [];
      this._item = item;
      if (item.connected) {
        options = ['Disconnect', 'Cancel'];
      } else {
        options = ['Connect', 'Cancel'];
      }
      this.tag('List').items = options.map((item, index) => {
        return {
          ref: item,
          x: index === 0 ? 0 : 325 * index,
          w: 325,
          h: 85,
          type: ConfirmAndCancel,
          item: item
        };
      });
      this._setState('Pair');
    }
    _focus() {
      this.hidePasswd = true;
      this._setState('Pair');
      this.item(this.fireAncestors("$PairingnetworkParams"));
    }
    _unfocus() {}
    _init() {
      this.star = "";
      this.passwd = "";
      this.isOn = false;
      this._wifi = new Wifi();
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        this.fireAncestors("$navigateBack");
      } else if (option === 'Connect') {
        if (this._item) {
          console.log('trying to connect wifi');
          this._wifi.connect(this._item, '').then(() => {}).catch(err => {
            console.log('Not able to connect to wifi', JSON.stringify(err));
          });
        }
        this.fireAncestors("$navigateBack");
      } else if (option === 'Disconnect') {
        this._wifi.disconnect().then(() => {
          this.fireAncestors("$navigateBack");
        });
      }
    }
    startConnect(password) {
      this._wifi.connect(this._item, password).then(() => {
        this._wifi.saveSSID(this._item.ssid, password, this._item.security).then(response => {
          if (response.result === 0 && response.success === true) {
            this._wifi.SaveSSIDKey(this._item.ssid).then(persistenceResponse => {
              console.log(persistenceResponse);
            });
            // Router.back()
          } else if (response.result !== 0) {
            this._wifi.clearSSID().then(response => {
              // console.log(response)
              // Router.back()
            });
          }
        });
        this.fireAncestors("$navigateBack");
      });
    }
    static _states() {
      return [class Password extends this {
        $enter() {
          this.shifter = false;
          this.capsLock = false;
        }
        _getFocused() {
          return this.tag("KeyBoard");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.startConnect(this.passwd);
          } else if (key === 'Clear') {
            this.passwd = this.passwd.substring(0, this.passwd.length - 1);
            this.star = this.star.substring(0, this.star.length - 1);
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.star += '\u25CF';
            this.passwd += ' ';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === 'Delete') {
            this.star = '';
            this.passwd = '';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else {
            this.star += '\u25CF';
            this.passwd += key;
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          }
        }
        _handleUp() {
          this._setState("Pair");
        }
      }, class Pair extends this {
        $enter() {}
        _getFocused() {
          return this.tag('List').element;
        }
        _handleRight() {
          this.tag('List').setNext();
        }
        _handleLeft() {
          this.tag('List').setPrevious();
        }
        _handleUp() {
          this._setState("PasswordSwitchState");
        }
        _handleDown() {
          this._setState("Password");
        }
        _handleEnter() {
          if (this.tag('List').element.ref == 'Connect' && this._item.security != 0) {
            if (this.star === '') {
              this._setState('Password');
            } else {
              this.startConnect(this.passwd);
            }
          } else {
            this.pressEnter(this.tag('List').element.ref);
          }
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1279, 88, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Pair");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.passwd);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const errorTitle = 'Error Title';
  const errorMsg = 'Error Message';
  class FailComponent extends lng$1.Component {
    notify(args) {
      console.log(args);
      if (args.title && args.msg) {
        this.tag('FailComponent.Title').text.text = args.title;
        this.tag('FailComponent.Message').text.text = Language.translate(args.msg);
      }
    }
    _unfocus() {
      this.tag('FailComponent.Title').text.text = errorTitle;
      this.tag('FailComponent.Message').text.text = errorMsg;
    }
    static _template() {
      return {
        FailComponent: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: errorTitle,
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Message: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: errorMsg,
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          RectangleDefault: {
            x: 0,
            y: 200,
            w: 200,
            mountX: 0.5,
            h: 50,
            rect: true,
            color: CONFIG.theme.hex,
            Ok: {
              x: 100,
              y: 25,
              mount: 0.5,
              text: {
                text: Language.translate("OK"),
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
  * Class for WiFi screen.
  */
  class WiFiScreen extends lng$1.Component {
    static _template() {
      return {
        WifiContents: {
          x: 200,
          y: 275,
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('WiFi On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              visible: false,
              h: 45,
              w: 45,
              x: 1500,
              // x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Networks: {
            y: 180,
            flex: {
              direction: 'column'
            },
            PairedNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            AvailableNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            visible: false
          },
          JoinAnotherNetwork: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Join Another Network'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        },
        JoinAnotherNetworkOverlay: {
          type: JoinAnotherNetworkComponent,
          visible: false
        },
        WifiPairingScreen: {
          type: WifiPairingScreen,
          visible: false
        },
        FailScreen: {
          type: FailComponent,
          visible: false
        }
      };
    }
    _active() {
      this._setState('Switch');
    }
    _focus() {
      this._setState('Switch');
      this._enable();
    }
    changeStateBack(state) {
      this._setState(state);
    }
    _firstEnable() {
      this.wifiLoading = this.tag('Switch.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: Math.PI * 2
          }
        }]
      });
      this.onError = {
        0: 'SSID_CHANGED - The SSID of the network changed',
        1: 'CONNECTION_LOST - The connection to the network was lost',
        2: 'CONNECTION_FAILED - The connection failed for an unknown reason',
        3: 'CONNECTION_INTERRUPTED - The connection was interrupted',
        4: 'INVALID_CREDENTIALS - The connection failed due to invalid credentials',
        5: 'NO_SSID - The SSID does not exist',
        6: 'UNKNOWN - Any other error.'
      };
      this._wifi = new Wifi();
      this._network = new Network();
      this.wifiStatus = false;
      this._wifiIcon = true;
      this._activateWiFi();
      this._setState('Switch');
      if (this.wiFiStatus) {
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
      }
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this._network.activate().then(result => {
        if (result) {
          this.wifiStatus = true;
          this._network.registerEvent('onIPAddressStatusChanged', notification => {
            console.log(JSON.stringify(notification));
            if (notification.status == 'LOST') {
              if (notification.interface === 'WIFI') {
                this._wifi.setInterface('ETHERNET', true).then(res => {
                  if (res.success) {
                    this._wifi.setDefaultInterface('ETHERNET', true);
                  }
                });
              }
            }
          });
          this._network.registerEvent('onDefaultInterfaceChanged', notification => {
            if (notification.newInterfaceName === 'ETHERNET') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
            if (notification.newInterfaceName == 'ETHERNET' || notification.oldInterfaceName == 'WIFI') {
              this._wifi.disconnect();
              this.wifiStatus = false;
              this.tag('Networks').visible = false;
              this.tag('JoinAnotherNetwork').visible = false;
              this.tag('Switch.Loader').visible = false;
              this.wifiLoading.stop();
              this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this._setState('Switch');
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            }
            if (notification.newInterfaceName == '' && notification.oldInterfaceName == 'WIFI') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            }
          });
          this._network.registerEvent('onConnectionStatusChanged', notification => {
            if (notification.interface === 'ETHERNET' && notification.status === 'CONNECTED') {
              this._wifi.setInterface('ETHERNET', true).then(res => {
                if (res.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
          });
        }
      });
    }

    /**
     * Function to be executed when the Wi-Fi screen is enabled.
     */
    _enable() {
      if (this.wifiStatus) {
        this._wifi.discoverSSIDs();
      }
    }

    /**
     * Function to be executed when the Wi-Fi screen is disabled.
     */
    _disable() {
      this._wifi.stopScan();
    }
    pairedDevices() {
      this._pairedNetworks.tag('List').items = [];
      this._availableNetworks.tag('List').items = [];
    }

    /**
     * Function to render list of Wi-Fi networks.
     */
    renderDeviceList(ssids) {
      this._pairedList = [];
      this._pairedNetworks.h = 0;
      this._pairedNetworks.tag('List').items = [];
      this._pairedNetworks.tag('List').h = 0;
      this._wifi.getConnectedSSID().then(result => {
        if (result.ssid != '') {
          this._pairedList = [result];
          this._pairedNetworks.h = this._pairedList.length * 90;
          this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
          this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
            item.connected = true;
            return {
              ref: 'Paired' + index,
              w: 1920 - 300,
              h: 90,
              type: WiFiItem,
              item: item
            };
          });
        }
        this._otherList = ssids.filter(device => {
          console.log("SSID filter", device);
          result = this._pairedList.map(a => a.ssid);
          if (result.includes(device.ssid)) {
            return false;
          } else return device;
        });
        console.log("otherlist", this._otherList);
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        this._availableNetworks.tag('List').y = this._pairedNetworks.tag('List').h;
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          item.connected = false;
          return {
            ref: 'Other' + index,
            w: 1620,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
      });
    }
    hide() {
      this.tag('WifiContents').visible = false;
    }
    show() {
      this.tag('WifiContents').visible = true;
    }
    $PairingnetworkParams() {
      return this.ListItem;
    }
    $navigateBack() {
      this._setState('Switch');
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.tag('Switch.Button').scaleX = 1;
          }
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          if (this.wifiStatus === true) {
            this._setState('JoinAnotherNetwork');
          }
        }
        _handleEnter() {
          this.switch();
        }
      }, class PairedDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('Switch.Button').scaleX = -1;
          }
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          this.ListItem = this._pairedNetworks.tag('List').element._item;
          this._setState("WifiPairingScreen");
        }
      }, class AvailableDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('Switch.Button').scaleX = -1;
          }
        }
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          console.log("SSID check", this._availableNetworks.tag('List').element._item);
          this.ListItem = this._pairedNetworks.tag('List').element._item;
          console.log("enter connect method");
          this._wifi.getSSIDKey().then(response => {
            console.log("ssid check");
            if (response === ListItem.ssid) {
              this._wifi.connect().then(response => {
                console.log(response);
              }).catch(err => {
                this._setState("WifiPairingScreen");
                this._wifi.SaveSSIDKey("").then(() => {});
              });
            } else {
              this._setState("WifiPairingScreen");
            }
          });
        }
      }, class JoinAnotherNetwork extends this {
        $enter() {
          this.tag('JoinAnotherNetwork')._focus();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleEnter() {
          this._setState("JoinAnotherNetworkOverlay");
        }
        _handleDown() {
          if (this.wifiStatus) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('JoinAnotherNetwork')._unfocus();
        }
      }, class JoinAnotherNetworkOverlay extends this {
        $enter() {
          console.log("wifiscreen");
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('JoinAnotherNetworkOverlay').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('JoinAnotherNetworkOverlay').visible = false;
        }
        _getFocused() {
          return this.tag('JoinAnotherNetworkOverlay');
        }
        _handleBack() {
          this._setState('Switch');
        }
      },
      //WifiPairingScreen
      class WifiPairingScreen extends this {
        $enter() {
          console.log("wifiscreen");
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('WifiPairingScreen').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('WifiPairingScreen').visible = false;
        }
        _getFocused() {
          return this.tag('WifiPairingScreen');
        }
        _handleBack() {
          this._setState('Switch');
        }
      }, class FailScreen extends this {
        $enter() {
          console.log("wifiscreen");
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('FailScreen').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('FailScreen').visible = false;
        }
        _getFocused() {
          return this.tag('FailScreen');
        }
        _handleBack() {
          this._setState('Switch');
        }
        _handleEnter() {
          this._setState('Switch');
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */

    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          this._wifi.discoverSSIDs();
          this._setState('JoinAnotherNetwork');
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) {
            this._setState('AvailableDevices');
          }
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) {
            this._setState('PairedDevices');
          } else {
            this._setState('JoinAnotherNetwork');
          }
        }
      }
    }
    /**
     * Function to turn on and off Wi-Fi.
     */
    switch() {
      if (this.wifiStatus) {
        this._wifi.disconnect();
        console.log('turning off wifi');
        this._wifi.setInterface('ETHERNET', true).then(result => {
          if (result.success) {
            this._wifi.setDefaultInterface('ETHERNET', true).then(result => {
              if (result.success) {
                this._wifi.disconnect();
                this.wifiStatus = false;
                this.tag('Networks').visible = false;
                this.tag('JoinAnotherNetwork').visible = false;
                this.tag('Switch.Loader').visible = false;
                this.wifiLoading.stop();
                this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              }
            });
          }
        });
      } else {
        console.log('turning on wifi');
        this.wifiStatus = true;
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
        this.wifiLoading.play();
        this.tag('Switch.Loader').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this._wifi.discoverSSIDs();
        this.pairedDevices();
      }
    }

    /**
     * Function to activate Wi-Fi plugin.
     */
    _activateWiFi() {
      this._wifi.activate().then(() => {
        this.switch();
      });
      this._wifi.registerEvent('onWIFIStateChanged', notification => {
        console.log(JSON.stringify(notification));
        if (notification.state === 2 || notification.state === 5) {
          this._wifi.discoverSSIDs();
        }
        if (notification.state === 5) {
          this._wifi.getConnectedSSID().then(result => {
            this._wifi.SaveSSIDKey(result.ssid).then(response => {
              console.log(response);
            });
          });
        }
      });
      this._wifi.registerEvent('onError', notification => {
        if (notification.code === 4) {
          this._wifi.clearSSID();
        }
        console.log('on errro');
        this._wifi.discoverSSIDs();
        this._wifi.setInterface('ETHERNET', true).then(res => {
          if (res.success) {
            this._wifi.setDefaultInterface('ETHERNET', true);
          }
        });
        this.tag("FailScreen").notify({
          title: 'WiFi Error',
          msg: this.onError[notification.code]
        });
        this._setState('FailScreen');
      });
      this._wifi.registerEvent('onAvailableSSIDs', notification => {
        console.log("notification", notification);
        this.renderDeviceList(notification.ssids);
        if (!notification.moreData) {
          setTimeout(() => {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
          }, 1000);
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi = new Wifi();
  class NetworkInterfaceScreen extends lng$1.Component {
    _construct() {
      this.LoadingIcon = Utils.asset('images/settings/Loading.png');
    }
    static _template() {
      return {
        NetworkInterfaceScreenContents: {
          x: 200,
          y: 275,
          WiFi: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('WiFi'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Ethernet: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Ethernet'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 175,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          }
        },
        WifiScreen: {
          type: WiFiScreen,
          visible: false
        }
      };
    }
    _focus() {
      this._setState('WiFi');
    }
    _init() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS(config);
      const systemcCallsign = 'org.rdk.Network';
      const eventName = 'onDefaultInterfaceChanged';
      this._thunder.on(systemcCallsign, eventName, notification => {
        console.log('onDefaultInterfaceChanged notification from networkInterfaceScreen: ', notification);
        if (notification.newInterfaceName === "ETHERNET") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: Connected';
        } else if (notification.newInterfaceName === "" && notification.oldInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: Error, Retry!';
        } else if (notification.newInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet';
        }
      });
      this.loadingAnimation = this.tag('Ethernet.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.tag('Ethernet.Loader').src = this.LoadingIcon;
    }
    _firstActive() {
      this.tag('Ethernet.Loader').on('txError', () => {
        const url = 'http://127.0.0.1:50050/lxresui/static/images/settings/Loading.png';
        this.tag('Ethernet.Loader').src = url;
      });
    }
    hide() {
      this.tag('NetworkInterfaceScreenContents').visible = false;
    }
    show() {
      this.tag('NetworkInterfaceScreenContents').visible = true;
    }
    setEthernetInterface() {
      wifi.getInterfaces().then(res => {
        res.interfaces.forEach(element => {
          if (element.interface === "ETHERNET" && element.connected) {
            wifi.setInterface('ETHERNET', true).then(result => {
              if (result.success) {
                wifi.setDefaultInterface('ETHERNET', true);
                this.tag('Ethernet.Title').text.text = 'Ethernet';
                this.tag('Ethernet.Loader').visible = true;
                this.loadingAnimation.start();
              }
            });
          }
        });
      });
    }
    static _states() {
      return [class WiFi extends this {
        $enter() {
          this.tag('WiFi')._focus();
        }
        $exit() {
          this.tag('WiFi')._unfocus();
        }
        _handleDown() {
          this._setState('Ethernet');
        }
        _getFocused() {
          return this.tag('WiFi');
        }
        _handleEnter() {
          this._setState("WifiScreen");
        }
      }, class Ethernet extends this {
        $enter() {
          this.tag('Ethernet')._focus();
        }
        $exit() {
          this.tag('Ethernet')._unfocus();
        }
        _handleEnter() {
          wifi.getDefaultInterface().then(res => {
            if (res.success) {
              if (res.interface !== "ETHERNET") {
                this.setEthernetInterface();
              }
            }
          });
        }
        _handleDown() {
          //  this._setState('WiFi')
        }
        _handleUp() {
          this._setState('WiFi');
        }
      }, class WifiScreen extends this {
        $enter() {
          console.log("wifiscreen");
          this.hide();
          this.tag('WifiScreen').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Interface  WiFi');
        }
        $exit() {
          this.show();
          this.tag('WifiScreen').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Interface');
        }
        _getFocused() {
          return this.tag('WifiScreen');
        }
        _handleBack() {
          this._setState('WiFi');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
    * Class for Other Network Config Screen.
    */

  class NetworkConfigurationScreen extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        color: 0x00000000,
        w: 1920,
        h: 1080,
        NetworkConfigurationScreenContents: {
          x: 200,
          y: 275,
          NetworkInfo: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Network Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NetworkInterface: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Network Interface: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TestInternetAccess: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Test Internet Access: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 420,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          },
          StaticMode: {
            alpha: 0,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Static Mode'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        NetworkInfoScreen: {
          type: NetworkInfo,
          visible: false
        },
        NetworkInterfaceOverlay: {
          type: NetworkInterfaceScreen,
          visible: false
        }
      };
    }
    _firstEnable() {
      console.log("first trigger");
      this._setState('NetworkInfo');
      let _currentIPSettings = {};
      let _newIPSettings = {};
      this._network = new Network();
      this._network.getDefaultInterface().then(interfaceName => {
      });
      _newIPSettings = _currentIPSettings;
      _newIPSettings.ipversion = "IPV6"; // this fails, need to verify how to set proper ip settings

      // loader animation for testing internet
      this.loadingAnimation = this.tag('TestInternetAccess.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState('NetworkInfo');
      new Network().getDefaultInterface().then(interfaceName => {
        this.$NetworkInterfaceText(interfaceName);
      });
    }
    _unfocus() {
      this.tag('TestInternetAccess.Title').text.text = Language.translate('Test Internet Access: ');
    }
    $NetworkInterfaceText(text) {
      this.tag('NetworkInterface.Title').text.text = Language.translate('Network Interface: ') + text;
    }
    hide() {
      this.tag('NetworkConfigurationScreenContents').visible = false;
    }
    show() {
      this.tag('NetworkConfigurationScreenContents').visible = true;
    }
    static _states() {
      return [class NetworkInfo extends this {
        $enter() {
          this.tag('NetworkInfo')._focus();
        }
        $exit() {
          this.tag('NetworkInfo')._unfocus();
        }
        _handleDown() {
          this._setState('NetworkInterface');
        }
        _handleEnter() {
          this._setState("NetworkInfoScreen");
        }
      }, class NetworkInterface extends this {
        $enter() {
          this.tag('NetworkInterface')._focus();
        }
        $exit() {
          this.tag('NetworkInterface')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInfo');
        }
        _handleDown() {
          this._setState('TestInternetAccess');
        }
        _handleEnter() {
          this._setState("NetworkInterfaceOverlay");
          //  if (!Router.isNavigating()) {

          //  }
        }
      }, class TestInternetAccess extends this {
        $enter() {
          this.tag('TestInternetAccess')._focus();
        }
        $exit() {
          this.tag('TestInternetAccess')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInterface');
        }
        _handleDown() {
          //  this._setState('NetworkInfo')
        }
        _handleEnter() {
          this.loadingAnimation.start();
          this.tag('TestInternetAccess.Loader').visible = true;
          this._network.isConnectedToInternet().then(result => {
            var connectionStatus = Language.translate("Internet Access: ");
            if (result) {
              connectionStatus += Language.translate("Connected");
            } else {
              connectionStatus += Language.translate("Not Connected");
            }
            setTimeout(() => {
              this.tag('TestInternetAccess.Loader').visible = false;
              this.tag('TestInternetAccess.Title').text.text = connectionStatus;
              this.loadingAnimation.stop();
            }, 2000);
          });
        }
      }, class StaticMode extends this {
        $enter() {
          this.tag('StaticMode')._focus();
        }
        $exit() {
          this.tag('StaticMode')._unfocus();
        }
        _handleUp() {
          this._setState('TestInternetAccess');
        }
        _handleDown() {
          this._setState('NetworkInfo');
        }
        _handleEnter() {}
      }, class NetworkInfoScreen extends this {
        $enter() {
          this.hide();
          this.tag('NetworkInfoScreen').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Info');
        }
        $exit() {
          this.show();
          this.tag('NetworkInfoScreen').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings / Network Configuration');
        }
        _getFocused() {
          return this.tag('NetworkInfoScreen');
        }
        _handleBack() {
          this._setState('NetworkInfo');
        }
      }, class NetworkInterfaceOverlay extends this {
        $enter() {
          this.hide();
          this.tag('NetworkInterfaceOverlay').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Interface');
        }
        $exit() {
          this.show();
          this.tag('NetworkInterfaceOverlay').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration');
        }
        _getFocused() {
          return this.tag('NetworkInterfaceOverlay');
        }
        _handleBack() {
          this._setState('NetworkInterface');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let _item;
  /**
   * Class for pairing screen for the Bluetooth.
   */
  class BluetoothPairingScreen extends lng$1.Component {
    static _template() {
      return {
        BluetoothPair: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Pairing: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 0,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            ConnectDisconnect: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Unpair: {
              x: 0 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Unpair"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 0 + 220 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    getData(item) {
      console.log("setting pairing screen item: ", item);
      _item = item;
      this._setState('ConnectDisconnect');
      this.tag('Title').text = item.name;
      if (item.connected) {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = 'Disconnect';
      } else {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = 'Connect';
      }
    }
    _init() {
      this._setState('ConnectDisconnect');
    }
    _focus() {
      this._setState('ConnectDisconnect');
      this.item(this.fireAncestors("$BluetoothParams"));
    }
    static _states() {
      return [class ConnectDisconnect extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          // this.tag('Pairing').text = "Someting is wrong " + _item.name
          if (_item.connected) {
            this.fireAncestors('$triggerBluetoothAction', 'Disconnect');
          } else {
            this.fireAncestors('$triggerBluetoothAction', 'Connect');
          }
        }
        _handleRight() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Unpair extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.fireAncestors('$triggerBluetoothAction', 'Unpair');
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _handleLeft() {
          this._setState('ConnectDisconnect');
        }
        _focus() {
          this.tag('Unpair').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Unpair').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.fireAncestors('$triggerBluetoothAction', 'Cancel');
        }
        _handleLeft() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Bluetooth screen.
   */
  class BluetoothScreen extends lng$1.Component {
    static _template() {
      return {
        Bluetooth: {
          y: 275,
          x: 200,
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Bluetooth On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Searching: {
            visible: false,
            h: 90,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Searching for Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              // x: 1600,
              x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            }
          },
          Networks: {
            PairedNetworks: {
              y: 180,
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            AvailableNetworks: {
              y: 90,
              visible: false,
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            visible: false
          },
          AddADevice: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Add A Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        },
        BluetoothPairingScreen: {
          type: BluetoothPairingScreen,
          visible: false
        },
        FailScreen: {
          type: FailComponent,
          visible: false
        }
      };
    }

    //  $navigateBack() {
    //   this._setState('AddADevice')
    // }

    $triggerBluetoothAction(option) {
      this.pressEnter(option);
      this._setState('AddADevice');
    }
    hide() {
      this.tag('Bluetooth').visible = false;
    }
    show() {
      this.tag('Bluetooth').visible = true;
    }
    _unfocus() {
      this._disable();
    }
    _firstEnable() {
      this._bt = new BluetoothApi();
      this._bluetooth = false;
      this._activateBluetooth();
      this._setState('Switch');
      this.switch(); //so that switch will be enabled by default
      //this._bluetooth = false
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this.renderDeviceList();
      this.loadingAnimation = this.tag('Searching.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState('AddADevice');
      this._enable();
      if (this._bluetooth) {
        this.tag('Networks').visible = true;
        this.tag('AddADevice').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.renderDeviceList();
        //this._bt.startScan()
      }
    }

    /**
     * Function to be excuted when the Bluetooth screen is enabled.
     */
    _enable() {
      if (this._bluetooth) {
        this._bt.startScan();
      }
      this.scanTimer = Registry.setInterval(() => {
        if (this._bluetooth) {
          this._bt.startScan();
        }
      }, 5000);
    }

    /**
     * Function to be executed when the Bluetooth screen is disabled from the screen.
     */
    _disable() {
      Registry.clearInterval(this.scanTimer);
      this._bt.stopScan();
    }

    /**
     * Function to be executed when add a device is pressed
     */

    showAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: true
      });
      this.tag('AvailableNetworks').patch({
        visible: true
      });
      //  this.loadingAnimation.stop()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    hideAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      //  this.loadingAnimation.start()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    /**
     * Function to render list of Bluetooth devices
     */
    renderDeviceList() {
      this._bt.getPairedDevices().then(result => {
        this._pairedList = result;
        this._pairedNetworks.h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
          item.paired = true;
          return {
            ref: 'Paired' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
      this._bt.getDiscoveredDevices().then(result => {
        this._discoveredList = result;
        this._otherList = this._discoveredList.filter(device => {
          if (!device.paired) {
            result = this._pairedList.map(a => a.deviceID);
            if (result.includes(device.deviceID)) {
              return false;
            } else return device;
          }
        });
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          return {
            ref: 'Other' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        this._setState('AddADevice');
      } else if (option === 'Pair') {
        this._bt.pair(this._availableNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._availableNetworks.tag('List').element._item.name;
          if (result.success) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'Pairing Succesful'
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'Pairing Failed'
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      } else if (option === 'Connect') {
        this._bt.connect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'Connection Failed'
            });
            this._setState('FailScreen');
          } else {
            this._bt.setAudioStream(this._pairedNetworks.tag('List').element._item.deviceID);
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'Connection Successful'
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      } else if (option === 'Disconnect') {
        this._bt.disconnect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'Failed to Disconnect'
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'Disconnected'
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      } else if (option === 'Unpair') {
        this._bt.unpair(this._pairedNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (result) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'Unpaired'
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'Unpairing Failed'
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      }
    }
    $BluetoothParams() {
      return this._pairedNetworks.tag('List').element._item;
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          this.hideAvailableDevices();
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          this._setState('AddADevice');
        }
        _handleEnter() {
          this.switch();
        }
      }, class PairedDevices extends this {
        $enter() {
          this.hideAvailableDevices();
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          this.tag('BluetoothPairingScreen').getData(this._pairedNetworks.tag('List').element._item);
          this._setState('BluetoothPairingScreen');
        }
      }, class AvailableDevices extends this {
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          this.pressEnter('Pair');
        }
        _handleBack() {
          this.hideAvailableDevices();
          this._setState('AddADevice');
        }
      }, class AddADevice extends this {
        $enter() {
          this.tag('AddADevice')._focus();
          this.hideAvailableDevices();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleDown() {
          if (this._bluetooth) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('AddADevice')._unfocus();
        }
        _handleEnter() {
          if (this._bluetooth) {
            this.showAvailableDevices();
            this._setState('AvailableDevices');
          }
        }
      }, class BluetoothPairingScreen extends this {
        $enter() {
          this._disable();
          this._bt.stopScan();
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('BluetoothPairingScreen').visible = true;
        }
        _getFocused() {
          return this.tag('BluetoothPairingScreen');
        }
        $exit() {
          this._enable();
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('BluetoothPairingScreen').visible = false;
        }
        _handleBack() {
          this._setState('AddADevice');
        }
      }, class FailScreen extends this {
        $enter() {
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('FailScreen').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('FailScreen').visible = false;
        }
        _getFocused() {
          return this.tag('FailScreen');
        }
        _handleBack() {
          this._setState('AddADevice');
        }
        _handleEnter() {
          this._setState('AddADevice');
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */
    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) ;
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) ; else if (listname === 'MyDevices') {
            this._setState('AddADevice');
          }
        }
      }
    }

    /**
     * Function to turn on and off Bluetooth.
     */
    switch() {
      if (this._bluetooth) {
        this._bt.disable().then(result => {
          if (result.success) {
            this._bluetooth = false;
            this.tag('Networks').visible = false;
            this.tag('AddADevice').visible = false;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          }
        }).catch(() => {
          console.log('Cannot turn off Bluetooth');
        });
      } else {
        this._bt.enable().then(result => {
          if (result.success) {
            this._bluetooth = true;
            this.tag('Networks').visible = true;
            this.tag('AddADevice').visible = true;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.renderDeviceList();
            this._bt.startScan();
          }
        }).catch(() => {
          console.log('Cannot turn on Bluetooth');
        });
      }
    }

    /**
     * Function to activate Bluetooth plugin.
     */
    _activateBluetooth() {
      this._bt.activate().then(res => {
        console.log(res);
        this._bluetooth = true;
        this._bt.registerEvent('onDiscoveredDevice', () => {
          this.renderDeviceList();
        });
        this._bt.registerEvent('onPairingRequest', notification => {
          this.respondToPairingRequest(notification.deviceID, 'ACCEPTED');
        });
        this._bt.registerEvent('onConnectionChange', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          let btName = notification.name;
          if (notification.connected) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'CONNECTION SUCCESS'
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: 'CONNECTION FAILED'
            });
            this._setState('FailScreen');
          }
        });
        this._bt.registerEvent('onDiscoveryCompleted', () => {
          this.tag('Searching.Loader').visible = false;
          this.loadingAnimation.stop();
          this.renderDeviceList();
        });
        this._bt.registerEvent('onDiscoveryStarted', () => {
          this.loadingAnimation.start();
          this.tag('Searching.Loader').visible = true;
        });
        this._bt.registerEvent('onRequestFailed', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          this.tag("FailScreen").notify({
            title: notification.name,
            msg: notification.newStatus
          });
          this._setState('FailScreen');
        });
      }).catch(err => {
        console.log(err);
      });
    }

    /**
     * Function to respond to Bluetooth client.
     * @param {number} deviceID
     * @param {string} responseValue
     */
    respondToPairingRequest(deviceID, responseValue) {
      this._bt.respondToEvent(deviceID, 'onPairingRequest', responseValue);
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const dtvApi$2 = new DTVApi();
  const config$3 = {
    host: "127.0.0.1",
    port: 9998,
    default: 1
  };
  const thunder$3 = thunderJS(config$3);
  const systemcCallsign = "DTV";

  /**
   * Class for DVB Scan screen.
   */
  class DvbSScan extends lng$1.Component {
    static _template() {
      return {
        DvbSScanScreenContents: {
          x: 200,
          y: 275,
          Wrapper: {
            y: -3,
            h: 635,
            w: 1700,
            clipping: true,
            Scroller: {
              y: 2,
              Satellite: {
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Satellite"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Frequency: {
                y: 90,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Frequency"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Polarity: {
                y: 180,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Polarity"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SymbolRate: {
                y: 270,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Symbol Rate"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              FEC: {
                y: 360,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("FEC"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              DVBS2: {
                y: 450,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("DVB-S2"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              },
              Modulation: {
                y: 540,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Modulation"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SearchType: {
                y: 630,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Search Mode"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Retune: {
                y: 720,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language.translate("Clear existing service list"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              }
            }
          },
          StartScan: {
            zIndex: 3,
            x: 10,
            y: 670,
            h: 50,
            w: 200,
            rect: true,
            color: 0xffffffff,
            Title: {
              x: 100,
              y: 27,
              mount: 0.5,
              text: {
                text: Language.translate("Start Scan"),
                textColor: 0xff000000,
                fontFace: CONFIG.language.font,
                fontSize: 24
              }
            }
          },
          ErrorNotification: {
            x: 250,
            y: 670,
            h: 50,
            visible: false,
            Content: {
              x: 10,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language.translate("Error!"),
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            }
          },
          ScanProgress: {
            x: 270,
            y: 670,
            h: 50,
            visible: false,
            Title: {
              visible: false,
              x: 40,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language.translate("Please wait scan in progress") + "...",
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 10,
              mountX: 1,
              y: 25,
              mountY: 0.5,
              src: Utils.asset("images/settings/Loading.png")
            }
          }
        },
        SelectSatellite: {
          type: Satellite,
          visible: false
        },
        SelectFrequency: {
          type: IntegerInput,
          visible: false
        },
        SelectPolarity: {
          type: Polarity,
          visible: false
        },
        SelectSymbolRate: {
          type: IntegerInput,
          visible: false
        },
        SelectFEC: {
          type: FEC,
          visible: false
        },
        SelectModulation: {
          type: Modulation,
          visible: false
        },
        SelectSearchType: {
          type: SearchType,
          visible: false
        }
      };
    }
    _init() {
      this._setState("Satellite");
      this.preventExit = false;
      this.selectedSatellite = {};
      this.selectedFrequency = "";
      this.selectedPolarity = "";
      this.selectedSymbolRate = "";
      this.selectedFEC = "";
      this.selectedDVBS2 = false; //default value is false
      this.selectedModulation = "";
      this.selectedSearchType = "";
      this.selectedRetune = false; //default value is set to false

      this.loadingAnimation = this.tag("ScanProgress.Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.inProgressAnimation = this.tag("ScanProgress.Title").animation({
        duration: 0.6,
        repeat: 0,
        stopMethod: "immediate",
        actions: [{
          p: "text.text",
          v: {
            0: Language.translate("Please wait scan in progress"),
            0.3: Language.translate("Please wait scan in progress") + ".",
            0.6: Language.translate("Please wait scan in progress") + "..",
            0.9: Language.translate("Please wait scan in progress") + "..."
          }
        }]
      });
    }
    setScanInProgress() {
      this.preventExit = true;
      this.loadingAnimation.start();
      this.inProgressAnimation.start();
      this.tag("ScanProgress").visible = true;
    }
    setScanFinished() {
      this.preventExit = false;
      this.loadingAnimation.stop();
      this.inProgressAnimation.stop();
      this.tag("ScanProgress").visible = false;
      this.tag("ScanProgress.Title").visible = false;
    }
    _captureKey() {
      if (this.preventExit) {
        this.tag("ScanProgress.Title").visible = true;
        this.inProgressAnimation.start();
      } else {
        return false;
      }
    }
    consoleLog() {
      //log it everywhere
      console.log("selectedSatellite: ", JSON.stringify(this.selectedSatellite), " selectedFrequency: ", this.selectedFrequency, " selectedPolarity: ", this.selectedPolarity, " selectedSymbolRate: ", this.selectedSymbolRate, " selectedFEC: ", this.selectedFEC, " selectedDVBS2: ", this.selectedDVBS2, " selectedModulation: ", this.selectedModulation, " selectedSearchType: ", this.selectedSearchType, " selectedRetune: ", this.selectedRetune);
    }
    _focus() {
      // console.log("dvbscan screen in focus");
      this.resetForm();
      this._setState("Satellite");
      this.consoleLog();
      // console.log(this.satelliteList);
      // console.log(this.polarityList);
      // console.log(this.fecList);
      // console.log(this.modulationList);
      // console.log(this.searchtypeList);
    }

    _firstActive() {
      thunder$3.on(systemcCallsign, "searchstatus", notification => {
        console.log("SearchStatus Notification: ", JSON.stringify(notification));
        if (notification.finished) {
          console.log("notification.finished: ", notification.finished);
          this.setScanFinished();
        }
      });

      ///////////////satellite

      this.satelliteList = [];
      dtvApi$2.satelliteList().then(res => {
        this.satelliteList = res;
      });

      ///////////////////polarity

      this.polarityList = [];
      dtvApi$2.polarityList().then(res => {
        this.polarityList = res;
      });

      ///////////////////symbolRate
      //symbol rate has some predefined values additional to custom imput
      this.symbolRateList = [];
      dtvApi$2.symbolRateList().then(res => {
        this.symbolRateList = res;
      });

      ////////////////////FEC

      this.fecList = [];
      dtvApi$2.fecList().then(res => {
        this.fecList = res;
      });

      ///////////////////modulation

      this.modulationList = [];
      dtvApi$2.modulationList().then(res => {
        this.modulationList = res;
      });

      ///////////////////searchtype

      this.searchtypeList = [];
      dtvApi$2.searchtypeList().then(res => {
        this.searchtypeList = res;
      });
    }
    _handleBack() {
      this.resetForm();
      return false; //so that handleBack of parent is also executed.
    }

    $getSatelliteList() {
      return this.satelliteList;
    }
    $setSatellite(satellite) {
      this.selectedSatellite = satellite;
      //this.consoleLog();
    }

    $getSelectedSatellite() {
      return this.selectedSatellite;
    }
    $getPolarityList() {
      return this.polarityList;
    }
    $setPolarity(polarity) {
      this.selectedPolarity = polarity;
      //this.consoleLog();
    }

    $getSelectedPolarity() {
      return this.selectedPolarity;
    }
    $getFECList() {
      return this.fecList;
    }
    $setFEC(fec) {
      this.selectedFEC = fec;
      //this.consoleLog();
    }

    $getSelectedFEC() {
      return this.selectedFEC;
    }
    $getModulationList() {
      return this.modulationList;
    }
    $setModulation(modulation) {
      this.selectedModulation = modulation;
      //this.consoleLog();
    }

    $getSelectedModulation() {
      return this.selectedModulation;
    }
    $getSearchTypeList() {
      return this.searchtypeList;
    }
    $setSearchType(searchtype) {
      this.selectedSearchType = searchtype;
      //this.consoleLog();
    }

    $getSelectedSearchType() {
      return this.selectedSearchType;
    }
    setFrequency(frequency) {
      this._setState("Frequency");
      this.selectedFrequency = frequency;
      this.tag("Frequency.Title").text.text = Language.translate("Frequency") + ": " + (this.selectedFrequency !== "" ? this.selectedFrequency : Language.translate("Select a") + " " + Language.translate("Frequency"));
    }
    setSymbolRate(symbolrate) {
      this._setState("SymbolRate");
      this.selectedSymbolRate = symbolrate;
      this.tag("SymbolRate.Title").text.text = Language.translate("Symbol Rate") + ": " + (this.selectedSymbolRate !== "" ? this.selectedSymbolRate : Language.translate("Select a") + " " + Language.translate("Symbol Rate"));
    }
    resetForm() {
      this.setScanFinished();
      //reset the form variables to initial state on exit from this form
      this.selectedSatellite = {};
      this.tag("Satellite.Title").text.text = Language.translate("Satellite");
      this.selectedFrequency = "";
      this.tag("Frequency.Title").text.text = Language.translate("Frequency");
      this.selectedPolarity = "";
      this.tag("Polarity.Title").text.text = Language.translate("Polarity");
      this.selectedSymbolRate = "";
      this.tag("SymbolRate.Title").text.text = Language.translate("Symbol Rate");
      this.selectedFEC = "";
      this.tag("FEC.Title").text.text = Language.translate("FEC");
      this.selectedDVBS2 = false;
      this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.selectedModulation = "";
      this.tag("Modulation.Title").text.text = Language.translate("Modulation");
      this.selectedSearchType = "";
      this.tag("SearchType.Title").text.text = Language.translate("Search Mode");
      this.selectedRetune = false;
      this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.tag("ErrorNotification").visible = false;
    }
    verifyInputs() {
      let errorString = "";
      if (Object.keys(this.selectedSatellite).length === 0) {
        errorString += "| " + Language.translate("Satellite") + " ";
      }
      if (this.selectedFrequency === "") {
        errorString += "| " + Language.translate("Frequency") + " ";
      }
      if (this.selectedPolarity === "") {
        errorString += "| " + Language.translate("Polarity") + " ";
      }
      if (this.selectedSymbolRate === "") {
        errorString += "| " + Language.translate("Symbol Rate") + " ";
      }
      if (this.selectedFEC === "") {
        errorString += "| " + Language.translate("FEC") + " ";
      }
      if (this.selectedModulation === "") {
        errorString += "| " + Language.translate("Modulation") + " ";
      }
      if (this.selectedSearchType === "") {
        errorString += "| " + Language.translate("Search Mode") + " ";
      }
      return errorString;
    }
    static _states() {
      return [class Satellite extends this {
        $enter() {
          this.tag("Satellite")._focus();
          this.tag("Scroller").y = 2; //to reset the scroll to show the first item.
        }

        $exit() {
          this.tag("Satellite")._unfocus();
        }
        _handleDown() {
          this._setState("Frequency");
        }
        _handleEnter() {
          if (this.satelliteList.length > 0) {
            this._setState("Satellite.SelectSatellite");
          } else {
            dtvApi$2.satelliteList().then(res => {
              this.satelliteList = res;
            });
          }
        }
        static _states() {
          return [class SelectSatellite extends Satellite {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSatellite").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Satellite"), true);
            }
            $exit() {
              this.tag("SelectSatellite").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("Satellite.Title").text.text = Language.translate("Satellite") + ": " + (Object.keys(this.selectedSatellite).length !== 0 ? this.selectedSatellite.name : Language.translate("Select a") + " " + Language.translate("Satellite"));
            }
            _getFocused() {
              return this.tag("SelectSatellite");
            }
            _handleBack() {
              this._setState("Satellite");
            }
          }];
        }
      }, class Frequency extends this {
        $enter() {
          this.tag("Frequency")._focus();
        }
        $exit() {
          this.tag("Frequency")._unfocus();
        }
        _handleUp() {
          this._setState("Satellite");
        }
        _handleDown() {
          this._setState("Polarity");
        }
        _handleEnter() {
          this.tag("SelectFrequency").patch({
            prevVal: this.selectedFrequency,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setFrequency.bind(this) //pass a function that will be executed when done is clicked on the keyboard
          });

          this._setState("Frequency.SelectFrequency");
        }
        static _states() {
          return [class SelectFrequency extends Frequency {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFrequency").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Frequency"), true);
            }
            $exit() {
              this.tag("SelectFrequency").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
            }
            _getFocused() {
              return this.tag("SelectFrequency");
            }
            _handleBack() {
              this.setFrequency(this.selectedFrequency);
            }
          }];
        }
      }, class Polarity extends this {
        $enter() {
          this.tag("Polarity")._focus();
        }
        $exit() {
          this.tag("Polarity")._unfocus();
        }
        _handleUp() {
          this._setState("Frequency");
        }
        _handleDown() {
          this._setState("SymbolRate");
        }
        _handleEnter() {
          this._setState("Polarity.SelectPolarity");
        }
        static _states() {
          return [class SelectPolarity extends Polarity {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectPolarity").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Polarity"), true);
            }
            $exit() {
              this.tag("SelectPolarity").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("Polarity.Title").text.text = Language.translate("Polarity") + ": " + (this.selectedPolarity !== "" ? this.selectedPolarity.charAt(0).toUpperCase() + this.selectedPolarity.slice(1) : Language.translate("Select a") + " " + Language.translate("Polarity"));
            }
            _getFocused() {
              return this.tag("SelectPolarity");
            }
            _handleBack() {
              this._setState("Polarity");
            }
          }];
        }
      }, class SymbolRate extends this {
        $enter() {
          this.tag("SymbolRate")._focus();
        }
        $exit() {
          this.tag("SymbolRate")._unfocus();
        }
        _handleUp() {
          this._setState("Polarity");
        }
        _handleDown() {
          this._setState("FEC");
        }
        _handleEnter() {
          this.tag("SelectSymbolRate").patch({
            prevVal: this.selectedSymbolRate,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setSymbolRate.bind(this),
            //pass a function that will be executed when done is clicked on the keyboard
            presetValues: this.symbolRateList //can handle a list of predefined values that can be selected using arrow keys
          });

          this._setState("SymbolRate.SelectSymbolRate");
        }
        static _states() {
          return [class SelectSymbolRate extends SymbolRate {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSymbolRate").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Symbol Rate"), true);
            }
            $exit() {
              this.tag("SelectSymbolRate").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
            }
            _getFocused() {
              return this.tag("SelectSymbolRate");
            }
            _handleBack() {
              this.setSymbolRate(this.selectedSymbolRate);
            }
          }];
        }
      }, class FEC extends this {
        $enter() {
          this.tag("FEC")._focus();
        }
        $exit() {
          this.tag("FEC")._unfocus();
        }
        _handleUp() {
          this._setState("SymbolRate");
        }
        _handleDown() {
          this._setState("DVBS2");
        }
        _handleEnter() {
          this._setState("FEC.SelectFEC");
        }
        static _states() {
          return [class SelectFEC extends FEC {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFEC").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("FEC"), true);
            }
            $exit() {
              this.tag("SelectFEC").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("FEC.Title").text.text = Language.translate("FEC") + ": " + (this.selectedFEC !== "" ? this.selectedFEC.replace("fec", "").replace("_", "/").toUpperCase() : Language.translate("Select a") + " " + Language.translate("FEC"));
            }
            _getFocused() {
              return this.tag("SelectFEC");
            }
            _handleBack() {
              this._setState("FEC");
            }
          }];
        }
      }, class DVBS2 extends this {
        $enter() {
          this.tag("DVBS2")._focus();
        }
        $exit() {
          this.tag("DVBS2")._unfocus();
        }
        _handleUp() {
          this._setState("FEC");
        }
        _handleDown() {
          this._setState("Modulation");
        }
        _handleEnter() {
          if (!this.selectedDVBS2) {
            this.selectedDVBS2 = true;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedDVBS2 = false;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class Modulation extends this {
        $enter() {
          this.tag("Modulation")._focus();
        }
        $exit() {
          this.tag("Modulation")._unfocus();
        }
        _handleUp() {
          this._setState("DVBS2");
        }
        _handleDown() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleEnter() {
          this._setState("Modulation.SelectModulation");
        }
        static _states() {
          return [class SelectModulation extends Modulation {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectModulation").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Modulation"), true);
            }
            $exit() {
              this.tag("SelectModulation").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("Modulation.Title").text.text = Language.translate("Modulation") + ": " + (this.selectedModulation !== "" ? this.selectedModulation.toUpperCase() : Language.translate("Select a") + " " + Language.translate("Modulation"));
            }
            _getFocused() {
              return this.tag("SelectModulation");
            }
            _handleBack() {
              this._setState("Modulation");
            }
          }];
        }
      }, class SearchType extends this {
        $enter() {
          this.tag("SearchType")._focus();
        }
        $exit() {
          this.tag("SearchType")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = 2;
          this._setState("Modulation");
        }
        _handleDown() {
          this.tag("Scroller").y = -178;
          this._setState("Retune");
        }
        _handleEnter() {
          this._setState("SearchType.SelectSearchType");
        }
        static _states() {
          return [class SelectSearchType extends SearchType {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSearchType").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language.translate("Search Mode"), true);
            }
            $exit() {
              this.tag("SelectSearchType").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("SearchType.Title").text.text = Language.translate("Search Mode") + ": " + (this.selectedSearchType !== "" ? this.selectedSearchType.charAt(0).toUpperCase() + this.selectedSearchType.slice(1) : Language.translate("Select a") + " " + Language.translate("Search Mode"));
            }
            _getFocused() {
              return this.tag("SelectSearchType");
            }
            _handleBack() {
              this._setState("SearchType");
            }
          }];
        }
      }, class Retune extends this {
        $enter() {
          this.tag("Retune")._focus();
        }
        $exit() {
          this.tag("Retune")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleDown() {
          this._setState("StartScan");
        }
        _handleEnter() {
          if (!this.selectedRetune) {
            this.selectedRetune = true;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedRetune = false;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class StartScan extends this {
        $enter() {
          this.tag("StartScan").color = CONFIG.theme.hex;
          this.tag("StartScan.Title").text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag("StartScan").color = 0xffffffff;
          this.tag("StartScan.Title").text.textColor = 0xff000000;
        }
        _handleUp() {
          this._setState("Retune");
        }
        _handleEnter() {
          let errorString = this.verifyInputs();
          if (errorString === "") {
            this.tag("ErrorNotification").visible = false;
            let serviceSearchParams = {
              tunertype: "dvbs",
              searchtype: this.selectedSearchType,
              retune: this.selectedRetune,
              usetuningparams: true,
              dvbstuningparams: {
                satellite: this.selectedSatellite.name,
                frequency: parseInt(this.selectedFrequency),
                polarity: this.selectedPolarity,
                symbolrate: parseInt(this.selectedSymbolRate),
                fec: this.selectedFEC,
                modulation: this.selectedModulation,
                dvbs2: this.selectedDVBS2
              }
            };
            console.log(JSON.stringify(serviceSearchParams));
            dtvApi$2.startServiceSearch(serviceSearchParams).then(res => {
              this.setScanInProgress();
              console.log(res);
              setTimeout(() => {
                this.setScanFinished(); //to give back controls after 30 sec in case searchstatus event fails
              }, 30000);
            });
          } else {
            this.tag("ErrorNotification.Content").text.text = Language.translate("Please enter the values for the following ") + errorString;
            this.tag("ErrorNotification").visible = true;
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Live TV Scan screen.
   */
  class LiveTVScan extends lng$1.Component {
    static _template() {
      return {
        LiveTVScanScreenContents: {
          x: 200,
          y: 275,
          TScan: {
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('DVB-T Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CScan: {
            alpha: 0.3,
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('DVB-C Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          SScan: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('DVB-S Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        DvbSScan: {
          type: DvbSScan,
          visible: false
        }
      };
    }
    _init() {
      this._setState('SScan');
    }
    _focus() {
      this._setState('SScan');
    }
    hide() {
      this.tag("LiveTVScanScreenContents").visible = false;
    }
    show() {
      this.tag("LiveTVScanScreenContents").visible = true;
    }
    static _states() {
      return [class TScan extends this {
        $enter() {
          this.tag('TScan')._focus();
        }
        $exit() {
          this.tag('TScan')._unfocus();
        }
        _handleDown() {
          this._setState('CScan');
        }
      }, class CScan extends this {
        $enter() {
          this.tag('CScan')._focus();
        }
        $exit() {
          this.tag('CScan')._unfocus();
        }
        _handleUp() {
          this._setState('TScan');
        }
        _handleDown() {
          this._setState('SScan');
        }
      }, class SScan extends this {
        $enter() {
          this.tag('SScan')._focus();
        }
        $exit() {
          this.tag('SScan')._unfocus();
        }
        _handleUp() {
          // this._setState('CScan')
        }
        _handleEnter() {
          this._setState("DvbSScan");
        }
      }, class DvbSScan extends this {
        $enter() {
          this.hide();
          this.tag('DvbSScan').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings / Live TV / Scan / DVB-S Scan');
        }
        $exit() {
          this.show();
          this.tag('DvbSScan').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings / Live TV / Scan');
        }
        _getFocused() {
          return this.tag('DvbSScan');
        }
        _handleBack() {
          this._setState('SScan');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let active = true; //expecting dtv plugin is active by default

  /**
   * Class for Live TV settings screen.
   */
  class LiveTVSettings extends lng$1.Component {
    static _template() {
      return {
        LiveTVSettingsScreenContents: {
          x: 200,
          y: 275,
          Activate: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate("Activate / Deactivate"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/ToggleOnOrange.png")
            }
          },
          Scan: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate("Scan"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/Arrow.png")
            }
          }
        },
        LiveTvScanOverlay: {
          type: LiveTVScan,
          visible: false
        }
      };
    }
    _init() {
      this._setState("Activate");
    }
    _firstActive() {
      this.dtvApi = new DTVApi();
    }
    _focus() {
      this._setState("Activate");
      if (active) {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
      } else {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      }
    }
    hide() {
      this.tag("LiveTVSettingsScreenContents").visible = false;
    }
    show() {
      this.tag("LiveTVSettingsScreenContents").visible = true;
    }
    static _states() {
      return [class Activate extends this {
        $enter() {
          this.tag("Activate")._focus();
        }
        $exit() {
          this.tag("Activate")._unfocus();
        }
        _handleDown() {
          this._setState("Scan");
        }
        _handleEnter() {
          if (active) {
            this.dtvApi.deactivate().then(res => {
              console.log(res);
              active = false;
              this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
            });
          } else {
            this.dtvApi.activate().then(res => {
              console.log(res);
              active = true;
              this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
            });
          }
        }
      }, class Scan extends this {
        $enter() {
          this.tag("Scan")._focus();
        }
        $exit() {
          this.tag("Scan")._unfocus();
        }
        _handleUp() {
          this._setState("Activate");
        }
        _handleEnter() {
          this._setState("LiveTvScanOverlay");
        }
      }, class LiveTvScanOverlay extends this {
        $enter() {
          this.hide();
          this.tag('LiveTvScanOverlay').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings / Live TV / Scan');
        }
        $exit() {
          this.show();
          this.tag('LiveTvScanOverlay').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings / Live TV ');
        }
        _getFocused() {
          return this.tag('LiveTvScanOverlay');
        }
        _handleBack() {
          this._setState('Scan');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SleepTimerScreen extends lng$1.Component {
    static _template() {
      return {
        SleepTimer: {
          y: 275,
          x: 200,
          List: {
            w: 1920 - 300,
            type: lng$1.components.ListComponent,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -5
          }
        }
      };
    }
    _firstEnable() {
      this.lastElement = false;
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '1 Hour',
        tick: false
      }, {
        value: '1.5 Hours',
        tick: false
      }, {
        value: '2 Hours',
        tick: false
      }, {
        value: '3 Hours',
        tick: false
      }];
      this.tag('List').h = this.options.length * 90;
      let timeoutInterval = Storage.get('TimeoutInterval');
      if (!timeoutInterval) {
        timeoutInterval = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (timeoutInterval === item.value) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this.fireAncestors('$registerInactivityMonitoringEvents').then(res => {
        this.fireAncestors('$resetSleepTimer', timeoutInterval);
      }).catch(err => {
        console.error("error while registering the inactivity monitoring event");
      });
      this._setState('Options');
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          this.options.forEach((element, idx) => {
            //if (element.tick) {
            this.tag('List').getElement(idx).tag('Tick').visible = false;
            //this.options[idx].tick = false
            //}
          });

          this.tag('List').element.tag('Tick').visible = true;
          //this.options[this.tag('List').index].tick = true
          this.fireAncestors('$sleepTimerText', this.options[this.tag('List').index].value);
          this.fireAncestors('$resetSleepTimer', this.options[this.tag('List').index].value);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class EnergySavingsScreen extends lng$1.Component {
    static _template() {
      return {
        EnerygySavingContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          // this.tag("List").element.patch({ "Item.Tick.visible": true });
          this.tag("List").element.tag("Tick").visible = true;
          // enable the tick mark in VideoAudioItem.js
          //to update the resolution value on Video Screen
        }
      }];
    }

    _firstEnable() {
      this._appApi = new AppApi();
      this.options = [Language.translate("Deep Sleep"), Language.translate("Light Sleep")];
      this.tag('EnerygySavingContents').h = this.options.length * 90;
      this.tag('EnerygySavingContents.List').h = this.options.length * 90;
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _focus() {
      this.loadingAnimation.start();
      var standbyMode = "";
      this._appApi.getPreferredStandbyMode().then(result => {
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          standbyMode = Language.translate("Light Sleep");
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          standbyMode = Language.translate("Deep Sleep");
        }
        this.tag('List').items = this.options.map((item, index) => {
          return {
            ref: 'Option' + index,
            w: 1920 - 300,
            h: 90,
            type: EnergySavingsItem,
            isTicked: standbyMode === item ? true : false,
            item: item,
            energyItem: true
          };
        });
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
        this._setState("Options");
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$2 = new AppApi();
  const thunder$2 = thunderJS({
    host: '127.0.0.1',
    port: 9998,
    default: 1
  });
  const loader = 'Loader';
  class LanguageScreen extends lng$1.Component {
    static _template() {
      return {
        LanguageScreenContents: {
          x: 200,
          y: 275,
          Languages: {
            flexItem: {
              margin: 0
            },
            List: {
              type: lng$1.components.ListComponent,
              w: 1920 - 300,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -4
            }
          }
        }
      };
    }
    _init() {
      this._Languages = this.tag('LanguageScreenContents.Languages');
      this._Languages.h = availableLanguages.length * 90;
      this._Languages.tag('List').h = availableLanguages.length * 90;
      this._Languages.tag('List').items = availableLanguages.map((item, index) => {
        return {
          ref: 'Lng' + index,
          w: 1620,
          h: 90,
          type: LanguageItem,
          item: item
        };
      });
      appApi$2.deactivateResidentApp(loader);
      appApi$2.setVisibility('ResidentApp', true);
      thunder$2.call('org.rdk.RDKShell', 'moveToFront', {
        client: 'ResidentApp'
      }).then(result => {
        console.log('ResidentApp moveToFront Success');
      });
      thunder$2.call('org.rdk.RDKShell', 'setFocus', {
        client: 'ResidentApp'
      }).then(result => {
        console.log('ResidentApp moveToFront Success');
      }).catch(err => {
        console.log('Error', err);
      });
    }
    _focus() {
      this._setState('Languages');
    }
    static _states() {
      return [class Languages extends this {
        $enter() {}
        _getFocused() {
          return this._Languages.tag('List').element;
        }
        _handleDown() {
          this._navigate('down');
        }
        _handleUp() {
          this._navigate('up');
        }
        _handleEnter() {
          if (localStorage.getItem('Language') !== availableLanguages[this._Languages.tag('List').index]) {
            localStorage.setItem('Language', availableLanguages[this._Languages.tag('List').index]);
            let path = location.pathname.split('index.html')[0];
            let url = path.slice(-1) === '/' ? "static/loaderApp/index.html" : "/static/loaderApp/index.html";
            let notification_url = location.origin + path + url;
            console.log(notification_url);
            appApi$2.launchResident(notification_url, loader).catch(err => {});
            appApi$2.setVisibility('ResidentApp', false);
            location.reload();
          }
        }
      }];
    }
    _navigate(dir) {
      let list = this._Languages.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const _privacyPolicy = "Privacy\n  Welcome to RDKCentral.com, a website owned and operated by RDK Management, LLC (\u201CRDK Management,\u201D \u201Cwe,\u201D or \u201Cus\u201D). This privacy policy discloses the privacy practices for this website only, including an explanation of:\n  \n  the categories of personally identifiable information about you that may be collected and how that information is used;\n  how we collect and use non-personally identifiable information about your use of the website;\n  the categories of persons or entities with whom the information may be shared;\n  the choices that are available to you regarding collection, use, and distribution of the information;\n  how you can opt out of RDK-related promotional e-mail;\n  the kind of security procedures that are in place to protect the loss, misuse or alteration of information;\n  how you can review and request changes to the information; and\n  how we notify users of this website of changes to this privacy policy.\n  Questions regarding this policy should be directed to \u201CRDK Management \u2013 Privacy Feedback\u201D and can be submitted via e-mail to info@rdkcentral.com.\n  \n  \n  What categories of information do we collect?\n  The information collected by RDK Management falls into two categories: (1) information voluntarily supplied by users of the website and (2) tracking information recorded as users navigate through the website. Some of this information is personally identifiable information (i.e., information that identifies a particular person, such as e-mail address), but much of it is not.\n  \n  To make use of some features on our website, like the RDK Wiki, users need to register and provide certain information as part of the registration process. We may ask, for example, for your name, e-mail address, street address, and zip code. We might also request information about your employer and the type of work that you do, in order to determine whether your employer is a member of the RDK program, to help us ensure that you are given access to the correct portions of the website, and to tailor our website content and e-mail (if you\u2019ve registered to receive e-mail) to your interests to make it more useful to you. If you are a registered user, our systems will remember some of this information the next time you log in and use our website, but you can always review and change your information by logging in and editing your profile here.\n  \n  The more you tell us about yourself, the more value we can offer you. Supplying this information is entirely voluntary. But if you choose not to supply the information, we may be unable to provide you with access to all of the features of this website. There are certain features of this website, including the Wiki and requesting to receive RDK-related promotional e-mail, that you will not be able to use unless you provide certain personally identifiable information about yourself. When you submit any personally identifiable information over this website, RDK Management (i) will use the information for the purposes described at the time you submit it and (ii) may use the information to contact you, subject to the contact preferences in your profile. If you want to remain completely anonymous, you\u2019re still free to take advantage of the publicly available content on our website without registration.\n  \n  Does RDK Management analyze my interaction with this website?\n  Some of the third-party service providers that RDK Management uses to deliver services, like analytics providers, may collect information on this website as disclosed in this privacy policy. This information may include personally identifiable information or may be used to contact you online.\n  \n  We and our service providers may use cookies to provide these services. The World Wide Web Consortium (W3C) has started a process to develop a \u201CDo Not Track\u201D Standard. Since the definitions and rules for such a standard have not yet been defined, RDK Management does not yet respond to \u201CDo Not Track\u201D signals sent from browsers.\n  \n  You may opt out of receiving cookies from the companies that provide services on this website by going to www.networkadvertising.org/consumer/opt_out.asp or http://www.aboutads.info/choices.\n  \n  What categories of persons or entities do we share personally identifiable information with?\n  We consider the personally identifiable information contained in our business records to be confidential. We may sometimes disclose personally identifiable information about you to our affiliates or to others who work for us. We may also disclose personally identifiable information about you to service providers and vendors, and to others who provide products and services to us. For example, when you use certain functions on this website you may notice that the website actually collecting or processing the information may be other than an RDK Management website. We may be required by law or legal process to disclose certain personally identifiable information about you to lawyers and parties in connection with litigation and to law enforcement personnel. For example, we may be required by law to disclose personally identifiable information about you without your consent and without notice in order to comply with a valid legal process such as a subpoena, court order, or search warrant.\n  \n  What do we do to personalize your use of this website?\n  We, or our service providers, may customize this website based on non-personal information including: (i) the IP address associated with your computer for purposes of determining your approximate geographic location; (ii) the type of web page that is being displayed; or (iii) the content on the page that is shown. Because this activity automatically applies to all users and it is purely contextual, this type of content delivery cannot be customized or controlled by individual users. We may also personalize this website based on the information that you provided us during registration. You may modify this information as further described in this Privacy Policy.\n  \n  To help make our website more responsive to the needs of our users, we use a standard feature of browser software called a \u201Ccookie.\u201D We use cookies to help us tailor our website to your needs, to deliver a better, more personalized service, and to remember certain choices you\u2019ve made so you don\u2019t have to re-enter them.\n  \n  RDK Management uses cookies, among other things, to remember your username and password, if you choose to store them, as well as to remember some of your personalization preferences and website features. RDK Management does not store your name or other personal information in cookies. You may read about enabling, disabling, and deleting cookies here. Of course, if you set your browser not to accept cookies or you delete them, you may not be able to take advantage of the personalized features enjoyed by other users of our website.\n  \n  The cookies we use don\u2019t directly identify users of our website as particular persons. Rather, they contain information sufficient to simplify and improve a user\u2019s experience on our website. For example, we may use session-based cookies to track the pages on our website visited by our users. We can build a better website if we know which pages our users are visiting and how often. Or, we may use persistent cookies to simplify access to a user\u2019s account information over our website, for example.\n  \n  In connection with the standard operation of RDK Management\u2019s systems, certain non-personally identifiable information about users of this website is recorded. This information is used primarily to tailor and enhance users\u2019 experience using the website. We may use this information in an aggregate, non-personally identifiable form to, among other things, measure the use of our website and determine which pages are the most popular with website users.\n  \n  We may also use one or more audience segmenting technology providers to help present content on this website. These providers uses cookies, web beacons, or similar technologies on your computer or mobile or other device to serve you advertisements or content tailored to interests you have shown by browsing on this and other websites you have visited. It also helps determine whether you have seen a particular piece of content before and in order to avoid sending you duplicates. In doing so, these providers collect non-personally identifiable information such as your browser type, your operating system, web pages visited, time of visits, content viewed, ads viewed, and other click stream data. When you visit this website, these providers may use cookies or web beacons to note which product and service descriptions your browser visited. The use of cookies, web beacons, or similar technologies by these providers is subject to their own privacy policies, not RDK Management\u2019s privacy policy for this website. If you do not want the benefits of the cookies used by these providers, you may opt-out of them by visiting http://www.networkadvertising.org/consumer/opt_out.asp or by visiting their opt-out pages.\n  \n  Your Access to and Control over your information?\n  You may opt out of any future contacts from us at any time. You can do the following at any time via email to support@rdkcentral.com or info@rdkcentral.com or unsubscribe to emails.\n  \n  Request to see all the information stored in the system\n  Accuracy of your data can be checked or corrected.\n  Personal data will be archived, in case user does not access our system for 90 days. However, user can request for deletion by writing to us at support@rdkcentral.com\n  Express any concern you have about our use of your data\n  Opt out from receiving emails by clicking unsubscribe.\n  How do users opt out of RDK-related promotional e-mail?\n  You can opt out of receiving RDK-related promotional e-mail from RDK Management using the opt-out link found in the footer of any of these e-mails. You can also e-mail the request to the attention of \u201CRDK Management \u2013 E-mail Opt Out\u201D via e-mail to info@rdkcentral.com.\n  \n  Other Websites\n  \n  To make our website more valuable to our users, we may offer some features in conjunction with other providers. Our website may also include links to other websites whose privacy policies and practices we don\u2019t control. Once you leave our website by linking to another one (you can tell where you are by checking the address \u2013 known as a URL \u2013 in the location bar on your browser), use of any information you provide is governed by the privacy policy of the operator of the website you\u2019re visiting. That policy may differ from ours. If you can\u2019t find the privacy policy of any of these websites via a link from the site\u2019s homepage, you should contact the website directly for more information.\n  \n  Security\n  \n  All information gathered on our website is stored within a database accessible only to RDK Management, its affiliates, and their specifically-authorized contractors and vendors. However, as effective as any security measure implemented by RDK Management may be, no security system is impenetrable. We cannot guarantee the complete security of our database, nor can we guarantee that information you supply won\u2019t be intercepted while being transmitted to us over the Internet. If you don\u2019t want us to know any particular information about you, don\u2019t include it in anything that you submit or post to this website or send to us in e-mail. We will retain and use your information to the extent necessary to comply with our legal obligations, resolve disputes, and enforce our policies.\n  \n  Changes to this Privacy Policy\n  \n  We may change this privacy policy from time to time. If we change this privacy policy at some point in the future, we\u2019ll post the changes on our website and by continuing to use the website after we post any changes, you accept and agree to this privacy statement, as modified.\n  \n  A Special Note About Children\n  \n  This website is not directed to children under the age of 13, and RDK Management does not knowingly collect personally identifiable information from anyone under the age of 18 on this website.\n  \n  Contacting us:\n  \n  If you have any questions about RDK Management, LLC privacy policy, the data we hold on you, or you would like to exercise one of your data protection rights, please do not hesitate to contact us.\n  \n  Data Protection Officer:  Herman-Jan Smith\n  \n  Email us at: hj.smith@rdkcentral.com\n  \n  Contacting the appropriate authority:\n  \n  Should you wish to report a complaint or if you feel that Our Company has not addressed your concern in a satisfactory manner, you may contact the Information Commissioner\u2019s Office.\n  \n  Email: compliance_team@rdkcentral.com\n  \n  Address:  1701 JFK Boulevard, Philadelphia, PA 19103 U.S.A";
  class PrivacyPolicyScreen extends lng$1.Component {
    static _template() {
      return {
        PrivacyPolicyScreenContents: {
          h: 810,
          w: 1720,
          x: 200,
          y: 270,
          clipping: true,
          PrivacyPolicy: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: "Privacy Policy",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontStyle: "bold",
                fontSize: 40
              }
            },
            Content: {
              x: 10,
              y: 100,
              text: {
                text: _privacyPolicy,
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 20,
                wordWrapWidth: 1500,
                wordWrap: true
              }
            }
          }
        }
      };
    }
    _handleDown() {
      if (this.tag("PrivacyPolicy").y > -2400) {
        this.tag("PrivacyPolicy").y -= 35;
      }
    }
    _handleUp() {
      if (this.tag("PrivacyPolicy").y <= 3) {
        this.tag("PrivacyPolicy").y += 35;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Privacy Screen.
   */

  const xcastApi = new XcastApi();
  class PrivacyScreen extends lng$1.Component {
    static _template() {
      return {
        PrivacyScreenContents: {
          x: 200,
          y: 275,
          LocalDeviceDiscovery: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Local Device Discovery'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          UsbMediaDevices: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('USB Media Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          AudioInput: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Audio Input'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          ClearCookies: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Clear Cookies and App Data'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          PrivacyPolicy: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Privacy Policy and License'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        PrivacyPolicyScreen: {
          type: PrivacyPolicyScreen,
          visible: false
        }
      };
    }
    _firstEnable() {
      this._setState('LocalDeviceDiscovery');
      this.checkLocalDeviceStatus();
      this.USBApi = new UsbApi();
      this.AppApi = new AppApi();
    }
    _focus() {
      this._setState(this.state);
      this.checkLocalDeviceStatus();
      this.checkUSBDeviceStatus();
    }
    checkUSBDeviceStatus() {
      if (!Storage.get('UsbMedia')) {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        Storage.set('UsbMedia', 'ON');
      } else if (Storage.get('UsbMedia') === 'ON') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
      } else if (Storage.get('UsbMedia') === 'OFF') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      }
    }
    checkLocalDeviceStatus() {
      xcastApi.getEnabled().then(res => {
        if (res.enabled) {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        } else {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
        }
      }).catch(err => {
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    toggleLocalDeviceDiscovery() {
      xcastApi.getEnabled().then(res => {
        if (!res.enabled) {
          xcastApi.activate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            }
          });
        } else {
          xcastApi.deactivate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            }
          });
        }
      }).catch(err => {
        console.log('Service not active');
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    hide() {
      this.tag('PrivacyScreenContents').visible = false;
    }
    show() {
      this.tag('PrivacyScreenContents').visible = true;
    }
    static _states() {
      return [class LocalDeviceDiscovery extends this {
        $enter() {
          this.tag('LocalDeviceDiscovery')._focus();
        }
        $exit() {
          this.tag('LocalDeviceDiscovery')._unfocus();
        }
        _handleUp() {
          //  this._setState('PrivacyPolicy')
        }
        _handleDown() {
          this._setState('UsbMediaDevices');
        }
        _handleEnter() {
          this.toggleLocalDeviceDiscovery();
        }
      }, class UsbMediaDevices extends this {
        $enter() {
          this.tag('UsbMediaDevices')._focus();
        }
        $exit() {
          this.tag('UsbMediaDevices')._unfocus();
        }
        _handleUp() {
          this._setState('LocalDeviceDiscovery');
        }
        _handleDown() {
          this._setState('AudioInput');
        }
        _handleEnter() {
          let _UsbMedia = Storage.get('UsbMedia');
          if (_UsbMedia === 'ON') {
            this.fireAncestors('$deRegisterUsbMount');
            this.USBApi.deactivate().then(res => {
              Storage.set('UsbMedia', 'OFF');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this.widgets.menu.refreshMainView();
            }).catch(err => {
              console.error("error while disabling the usb plugin = ".concat(err));
              this.fireAncestors('$registerUsbMount');
            });
          } else if (_UsbMedia === 'OFF') {
            this.USBApi.activate().then(res => {
              Storage.set('UsbMedia', 'ON');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
              this.fireAncestors('$registerUsbMount');
              this.widgets.menu.refreshMainView();
            });
          }
        }
      }, class AudioInput extends this {
        $enter() {
          this.tag('AudioInput')._focus();
        }
        $exit() {
          this.tag('AudioInput')._unfocus();
        }
        _handleUp() {
          this._setState('UsbMediaDevices');
        }
        _handleDown() {
          this._setState('ClearCookies');
        }
        _handleEnter() {
          // 
        }
      }, class ClearCookies extends this {
        $enter() {
          this.tag('ClearCookies')._focus();
        }
        $exit() {
          this.tag('ClearCookies')._unfocus();
        }
        _handleUp() {
          this._setState('AudioInput');
        }
        _handleDown() {
          this._setState('PrivacyPolicy');
        }
        _handleEnter() {
          this.AppApi.clearCache().then(() => {
            //location.reload(true)
          });
        }
      }, class PrivacyPolicy extends this {
        $enter() {
          this.tag('PrivacyPolicy')._focus();
        }
        $exit() {
          this.tag('PrivacyPolicy')._unfocus();
        }
        _handleUp() {
          this._setState('ClearCookies');
        }
        _handleDown() {
          //  this._setState('LocalDeviceDiscovery')
        }
        _handleEnter() {
          this._setState("PrivacyPolicyScreen");
        }
      }, class PrivacyPolicyScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('PrivacyPolicyScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Privacy  Policy');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('PrivacyPolicyScreen');
        }
        $exit() {
          this.show();
          this.tag('PrivacyPolicyScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings ');
        }
        _handleBack() {
          this._setState('PrivacyPolicy');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video and Audio screen.
   */

  class DeviceInformationScreen extends lng$1.Component {
    static _template() {
      return {
        DeviceInfoWrapper: {
          w: 1720,
          h: 810,
          x: 200,
          y: 275,
          clipping: true,
          DeviceInfoContents: {
            y: 3,
            Line1: {
              y: 0,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            ChipSet: {
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate("Chipset"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 45,
                mountY: 0.5,
                text: {
                  text: "N/A",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line2: {
              y: 90,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            SerialNumber: {
              Title: {
                x: 10,
                y: 135,
                mountY: 0.5,
                text: {
                  text: Language.translate("Serial Number"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 135,
                mountY: 0.5,
                text: {
                  text: "N/A",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line3: {
              y: 180,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            Location: {
              Title: {
                x: 10,
                y: 225,
                mountY: 0.5,
                text: {
                  text: Language.translate("Location"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 225,
                mountY: 0.5,
                text: {
                  text: "City: N/A , Country: N/A ",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line4: {
              y: 270,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            SupportedDRM: {
              Title: {
                x: 10,
                y: 360,
                mountY: 0.5,
                text: {
                  text: Language.translate("Supported DRM & Key-System"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  wordWrapWidth: 1600,
                  wordWrap: true,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 360,
                mountY: 0.5,
                text: {
                  text: "N/A",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  wordWrapWidth: 1200,
                  wordWrap: true,
                  fontSize: 25
                }
              }
            },
            Line5: {
              y: 450,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            FirmwareVersions: {
              Title: {
                x: 10,
                y: 540,
                mountY: 0.5,
                text: {
                  text: Language.translate("Firmware version"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 540,
                mountY: 0.5,
                text: {
                  text: "UI Version: ".concat(Settings.get('platform', 'version'), ", Build Version: , Timestamp: "),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line6: {
              y: 630,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            AppVersions: {
              Title: {
                x: 10,
                y: 720,
                mountY: 0.5,
                text: {
                  text: Language.translate("App Info"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 720,
                mountY: 0.5,
                text: {
                  text: "Youtube:\nAmazon Prime:\nNetflix ESN:",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line7: {
              y: 810,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            }
          }
        }
      };
    }
    _init() {
      this._network = new Network();
      this.appApi = new AppApi();
    }
    _focus() {
      this._setState('DeviceInformationScreen');
      this.appApi.getSerialNumber().then(result => {
        this.tag("SerialNumber.Value").text.text = "".concat(result.serialNumber);
      });
      this.appApi.getSystemVersions().then(res => {
        this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings.get('platform', 'version'), " \nBuild Version - ").concat(res.stbVersion, " \nTime Stamp - ").concat(res.stbTimestamp, " ");
      }).catch(err => {
        console.error("error while getting the system versions");
      });
      this.appApi.getDRMS().then(result => {
        console.log('from device info supported drms ' + JSON.stringify(result));
        var drms = "";
        result.forEach(element => {
          drms += "".concat(element.name, " :");
          if (element.keysystems) {
            drms += "\t";
            element.keysystems.forEach(keySystem => {
              drms += "".concat(keySystem, ", ");
            });
            drms += "\n";
          } else {
            drms += "\n";
          }
        });
        this.tag('SupportedDRM.Value').text.text = "".concat(drms.substring(0, drms.length - 1));
      });
      this._network.isConnectedToInternet().then(result => {
        if (result.connectedToInternet === true) {
          this.appApi.getLocation().then(result => {
            console.log("getLocation from device info " + JSON.stringify(result));
            var locationInfo = "";
            if (result.city.length !== 0) {
              locationInfo = "City: " + result.city;
            } else {
              locationInfo = "City: N/A ";
            }
            if (result.country.length !== 0) {
              locationInfo += ", Country: " + result.country;
            } else {
              locationInfo += ", Country: N/A ";
            }
            this.tag('Location.Value').text.text = "".concat(locationInfo);
          });
        } else {
          this.tag('Location.Value').text.text = "City: N/A, Country: N/A";
        }
      });
      this.appApi.getDeviceIdentification().then(result => {
        console.log('from device Information screen getDeviceIdentification: ' + JSON.stringify(result));
        this.tag('ChipSet.Value').text.text = "".concat(result.chipset);
        // this.tag('FirmwareVersions.Value').text.text = `${result.firmwareversion}`
      });

      let self = this;
      if (Storage.get('Netflix_ESN')) {
        self.tag('AppVersions.Value').text.text = "Youtube: NA\nAmazon Prime: NA\nNetflix ESN: ".concat(Storage.get('Netflix_ESN'));
      } else {
        self.appApi.getPluginStatus('Netflix').then(result => {
          let sel = self;
          console.log("Netflix : plugin status : ", JSON.stringify(result));
          if (result[0].state === 'deactivated' || result[0].state === 'deactivation') {
            sel.appApi.launchPremiumAppInSuspendMode("Netflix").then(res => {
              console.log("Netflix : netflix launch for esn value in suspend mode returns : ", JSON.stringify(res));
              let se = sel;
              se.appApi.getNetflixESN().then(res => {
                Storage.set('Netflix_ESN', res);
                console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
                se.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
              }).catch(err => {
                console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
              });
            }).catch(err => {
              console.error("Netflix : error while launching netflix in suspendMode : ", JSON.stringify(err));
            });
          } else {
            self.appApi.getNetflixESN().then(res => {
              Storage.set('Netflix_ESN', res);
              console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
              self.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
            }).catch(err => {
              console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
            });
          }
        }).catch(err => {
          console.error("Netflix : error while getting netflix plugin status ie. ", JSON.stringify(err));
        });
      }
      this.appApi.registerChangeLocation();
    }
    set netflixESN(v) {
      console.log("setting netflix ESN value to ".concat(v));
      this.tag('AppVersions.Value').text.text = v;
    }
    _handleDown() {
      if (this.tag("DeviceInfoContents").y > -200) {
        this.tag("DeviceInfoContents").y -= 20;
      }
    }
    _handleUp() {
      if (this.tag("DeviceInfoContents").y < 3) {
        this.tag("DeviceInfoContents").y += 20;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeOverlayItems extends lng$1.Component {
    static _template() {
      return {
        TimeItemsContents: {
          y: 3,
          List: {
            type: lng$1.components.ListComponent,
            h: 810,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          }
        }
      };
    }

    /**
     * Function refresh the list.
     */
    refreshList(item) {
      console.log("item from refreshList", item);
      this._item = item;
      this.tag('List').items = Object.keys(item.time_region).map((ele, idx) => {
        return {
          ref: 'Time' + idx,
          w: 1620,
          h: 90,
          type: TimeItem,
          item: [ele, ele === item.isActive]
        };
      });
    }
    _firstEnable() {
      this.appApi = new AppApi();
    }
    _handleDown() {
      this.tag('List').setNext();
    }
    _handleUp() {
      this.tag('List').setPrevious();
    }
    _handleEnter() {
      console.log("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      this.fireAncestors("$updateTimeZone", "".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      //  this.widgets.menu.updateTimeZone(`${this._item.zone}/${this.tag('List').element._item[0]}`)
      this.appApi.setZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      //  Router.navigate('settings/advanced/device/timezone', { refresh: true })
      return false; //to execute handle enter in parent component
    }

    _getFocused() {
      return this.tag('List').element;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeZoneOverlayItem extends lng$1.Component {
    _construct() {
      this.Arrow = Utils.asset('/images/settings/Arrow.png');
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Right: {
          y: 45,
          x: 1600,
          mountX: 1,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Arrow, 45, 45),
          color: 0xffffffff
        },
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item[2]
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item[0],
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _handleEnter() {
      console.log('enter', this._item[1]);
      this.fireAncestors("$navigateAndRefreshItems", {
        time_region: this._item[1],
        zone: this._item[0],
        isActive: this.zone
      });
      // Router.navigate('settings/advanced/device/timezone/item', { time_region: this._item[1], zone: this._item[0], isActive: this.zone })
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  class TimeZone extends lng$1.Component {
    /**
     * @param {object} args
     */
    set params(args) {
      if (args.refresh) {
        this._firstEnable();
      }
    }
    static _template() {
      return {
        TimeZoneOverlayScreenContents: {
          x: 200,
          y: 275,
          w: 1720,
          h: 810,
          clipping: true,
          List: {
            y: 3,
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Error: {
            alpha: 0,
            x: 560,
            y: 340,
            mountX: 0.5,
            MSG: {
              text: {
                text: 'TimeZone API not present',
                fontFace: CONFIG.language.font,
                fontSize: 40,
                textColor: 0xffffffff
              }
            }
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        },
        TimeOverlayItems: {
          x: 200,
          y: 275,
          w: 1720,
          h: 810,
          clipping: true,
          type: TimeOverlayItems,
          visible: false
        }
      };
    }
    async _firstEnable() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.loadingAnimation.start();
      this.tag('Loader').visible = true;
      this.appApi = new AppApi();
      this.resp = await this.appApi.fetchTimeZone();
      let data = [];
      this.zone = await this.appApi.getZone();
      try {
        console.log(this.resp, this.zone);
        delete this.resp.Etc;
        for (const i in this.resp) {
          if (typeof this.resp[i] === 'object') {
            data.push([i, this.resp[i], this.zone !== undefined ? this.zone.split('/')[0] === i : false]);
          }
        }
      } catch (error) {
        console.log('no api present', error);
      }
      console.log(data);
      if (data.length > 1) {
        this.tag('List').h = data.length * 90;
        this.tag('List').items = data.map((item, idx) => {
          return {
            ref: 'Time' + idx,
            w: 1620,
            h: 90,
            type: TimeZoneOverlayItem,
            item: item,
            zone: this.zone !== undefined ? this.zone.split('/')[1] : ''
          };
        });
      } else {
        this.tag('Error').alpha = 1;
      }
      this.loadingAnimation.stop();
      this.tag('Loader').visible = false;
      this._setState('List');
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
      }
    }
    hide() {
      this.tag('TimeZoneOverlayScreenContents').visible = false;
    }
    show() {
      this.tag('TimeZoneOverlayScreenContents').visible = true;
    }
    $navigateAndRefreshItems(params) {
      this.tag("TimeOverlayItems").refreshList(params);
      this._setState('TimeOverlayItems');
    }
    static _states() {
      return [class TimeOverlayItems extends this {
        $enter() {
          this.hide();
          this.tag('TimeOverlayItems').visible = true;
        }
        $exit() {
          this.show();
          this.tag('TimeOverlayItems').visible = false;
          this._firstEnable(); // so that the list will be refreshed when exiting from child screen.
        }

        _getFocused() {
          return this.tag('TimeOverlayItems');
        }
        _handleEnter() {
          this._setState('List');
        }
        _handleBack() {
          this._setState('List');
        }
      }, class List extends this {
        $enter() {
          this.show();
        }
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Firmware screen.
   */

  class FirmwareScreen extends lng$1.Component {
    static _template() {
      return {
        FirmwareContents: {
          x: 200,
          y: 270,
          State: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Firmware State: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          Version: {
            Title: {
              x: 10,
              y: 90,
              mountY: 0.5,
              text: {
                text: Language.translate('Firmware Versions: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedVersion: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language.translate("Downloaded Firmware Version: "),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedPercent: {
            Title: {
              x: 10,
              y: 180,
              mountY: 0.5,
              text: {
                text: "",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          FirmwareUpdate: {
            RectangleDefault: {
              x: 110,
              y: 200,
              w: 300,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: CONFIG.theme.hex,
              Update: {
                x: 170,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Check for Update"),
                  fontFace: CONFIG.language.font,
                  fontSize: 24
                }
              }
            }
          }
        }
      };
    }
    _firstEnable() {
      let state = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      const thunder = thunderJS(config);
      const systemcCallsign = "org.rdk.System.1";
      thunder.Controller.activate({
        callsign: systemcCallsign
      }).then(res => {
        thunder.on(callsign, "onFirmwareUpdateStateChange", notification => {
          console.log("Tanjirou's notification : on Firmware update state changed notifcation = ".concat(JSON.stringify(notification)));
          if (state[notification.firmwareUpdateStateChange] == "Downloading") {
            this.downloadInterval = setInterval(() => {
              console.log("Downloading...");
              this.getDownloadPercent();
            }, 1000);
          } else if (state[notification.firmwareUpdateStateChange] != "Downloading" && this.downloadInterval) {
            clearInterval(this.downloadInterval);
            this.downloadInterval = null;
          }
        }, err => {
          console.error("error while fetching notification ie. ".concat(err));
        });
      }).catch(err => {
        console.error("error while activating the system plugin");
      });
    }
    _unfocus() {
      if (this.downloadInterval) {
        clearInterval(this.downloadInterval);
        this.downloadInterval = null;
      }
    }
    _focus() {
      this.downloadInterval = null;
      this._appApi = new AppApi();
      const downloadState = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      this._appApi.getFirmwareUpdateState().then(res => {
        console.log("getFirmwareUpdateState from firmware screen " + JSON.stringify(res));
        this.tag('State.Title').text.text = Language.translate("Firmware State: ") + downloadState[res.firmwareUpdateState];
      });
      this._appApi.getDownloadFirmwareInfo().then(res => {
        console.log("getDownloadFirmwareInfo from firmware screen " + JSON.stringify(res));
        this.tag('Version.Title').text.text = Language.translate("Firmware Versions: ") + res.currentFWVersion;
      });
      this._setState('FirmwareUpdate');
    }
    getDownloadPercent() {
      this._appApi.getFirmwareDownloadPercent().then(res => {
        console.log("getFirmwareDownloadPercent : ".concat(JSON.stringify(res)));
        if (res.downloadPercent < 0) {
          this.tag('DownloadedPercent.Title').text.text = "";
        } else {
          this.tag('DownloadedPercent.Title').text.text = Language.translate("Download Progress: ") + res.downloadPercent + "%";
        }
      }).catch(err => {
        console.error(err);
      });
    }
    getDownloadFirmwareInfo() {
      this._appApi.updateFirmware().then(res => {
        this._appApi.getDownloadFirmwareInfo().then(result => {
          console.log("getDownloadFirmwareInfo : ".concat(JSON.stringify(result.downloadFWVersion)));
          this.tag('DownloadedVersion.Title').text.text = Language.translate('Downloaded Firmware Version: ') + "".concat(result.downloadFWVersion ? result.downloadFWVersion : 'NA');
        }).catch(err => {
          console.error(err);
        });
      }).catch(err => {
        console.error(err);
      });
    }
    static _states() {
      return [class FirmwareUpdate extends this {
        _handleEnter() {
          this.getDownloadFirmwareInfo();
          this.getDownloadPercent();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$1 = new AppApi();
  /**
   * Class for Reboot Confirmation Component.
   */
  class RebootConfirmation extends lng$1.Component {
    static _template() {
      return {
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language.translate("Reboot"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language.translate("Click Confirm to reboot!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xffffffff,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xff000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xff7d7d7d,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xff000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _focus() {
      this._setState("Confirm");
      this.loadingAnimation = this.tag("Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        stopDelay: 0.2,
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          appApi$1.reboot().then(result => {
            console.log("device rebooting" + JSON.stringify(result));
            this._setState("Rebooting");
          });
        }
        _handleRight() {
          this._setState("Cancel");
        }
        _focus() {
          this.tag("Confirm").patch({
            color: CONFIG.theme.hex
          });
          this.tag("Confirm.Title").patch({
            text: {
              textColor: 0xffffffff
            }
          });
        }
        _unfocus() {
          this.tag("Confirm").patch({
            color: 0xffffffff
          });
          this.tag("Confirm.Title").patch({
            text: {
              textColor: 0xff000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        //handleEnter is not required, default behaviour from parent is to exit this screen
        $enter() {
          this._focus();
        }
        _handleLeft() {
          this._setState("Confirm");
        }
        _focus() {
          this.tag("Cancel").patch({
            color: CONFIG.theme.hex
          });
          this.tag("Cancel.Title").patch({
            text: {
              textColor: 0xffffffff
            }
          });
        }
        _unfocus() {
          this.tag("Cancel").patch({
            color: 0xff7d7d7d
          });
          this.tag("Cancel.Title").patch({
            text: {
              textColor: 0xff000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Rebooting extends this {
        $enter() {
          this.loadingAnimation.start();
          this.tag("Loader").visible = true;
          this.tag("Title").text.text = "Rebooting...";
          this.tag("Buttons").visible = false;
          this.tag("Info").visible = false;
        }
        _handleEnter() {
          // do nothing
        }
        _handleLeft() {
          // do nothing
        }
        _handleRight() {
          // do nothing
        }
        _handleBack() {
          // do nothing
        }
        _handleUp() {
          // do nothing
        }
        _handleDown() {
          // do nothing
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Video and Audio screen.
   */

  class DeviceScreen extends lng$1.Component {
    static _template() {
      return {
        DeviceScreenContents: {
          x: 200,
          y: 275,
          Info: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TimeZone: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Time Zone'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Firmware: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Check for Firmware Update'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Reboot: {
            y: 270,
            //  alpha: 0.3, // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Reboot'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Reset: {
            y: 360,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Factory Reset'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        DeviceInformationScreen: {
          type: DeviceInformationScreen,
          visible: false
        },
        TimeZoneOverlay: {
          type: TimeZone,
          visible: false
        },
        FirmwareScreen: {
          type: FirmwareScreen,
          visible: false
        },
        RebootConfirmationScreen: {
          type: RebootConfirmation,
          visible: false
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._network = new Network();
      this._setState('Info');
    }
    _focus() {
      this._setState('Info');
    }
    hide() {
      this.tag('DeviceScreenContents').visible = false;
    }
    show() {
      this.tag('DeviceScreenContents').visible = true;
    }
    static _states() {
      return [class Info extends this {
        $enter() {
          this.tag('Info')._focus();
        }
        $exit() {
          this.tag('Info')._unfocus();
        }
        _handleUp() {
          //  this._setState('Reboot');
        }
        _handleDown() {
          this._setState('TimeZone');
        }
        _handleEnter() {
          this._setState("DeviceInformationScreen");
        }
      }, class TimeZone extends this {
        $enter() {
          this.tag('TimeZone')._focus();
        }
        $exit() {
          this.tag('TimeZone')._unfocus();
        }
        _handleUp() {
          this._setState('Info');
        }
        _handleDown() {
          this._setState('Firmware');
        }
        _handleEnter() {
          this._setState("TimeZoneOverlay");
        }
      }, class Firmware extends this {
        $enter() {
          this.tag('Firmware')._focus();
        }
        $exit() {
          this.tag('Firmware')._unfocus();
        }
        _handleUp() {
          this._setState('TimeZone');
        }
        _handleDown() {
          this._setState('Reboot');
        }
        _handleEnter() {
          this._setState("FirmwareScreen");
        }
      }, class Reboot extends this {
        $enter() {
          this.tag('Reboot')._focus();
        }
        $exit() {
          this.tag('Reboot')._unfocus();
        }
        _handleUp() {
          this._setState('Firmware');
        }
        _handleDown() {
          //  this._setState('Reset')
        }
        _handleEnter() {
          this._setState("RebootConfirmation");
        }
      }, class Reset extends this {
        $enter() {
          this.tag('Reset')._focus();
        }
        $exit() {
          this.tag('Reset')._unfocus();
        }
        _handleUp() {
          //this._setState('Reboot');
        }
        _handleDown() {
          //this._setState('Info')
        }
        _handleEnter() {}
      }, class DeviceInformationScreen extends this {
        $enter() {
          this.hide();
          this.tag('DeviceInformationScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device  Info');
        }
        _getFocused() {
          return this.tag('DeviceInformationScreen');
        }
        $exit() {
          this.show();
          this.tag('DeviceInformationScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Device ');
        }
        _handleBack() {
          this._setState('Info');
        }
      },
      //TimeZoneOverlay
      class TimeZoneOverlay extends this {
        $enter() {
          this.hide();
          this.tag('TimeZoneOverlay').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device  Time');
        }
        _getFocused() {
          return this.tag('TimeZoneOverlay');
        }
        $exit() {
          this.show();
          this.tag('TimeZoneOverlay').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device ');
        }
        _handleBack() {
          this._setState('TimeZone');
        }
      }, class FirmwareScreen extends this {
        $enter() {
          this.hide();
          this.tag('FirmwareScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device  Firmware Update');
        }
        _getFocused() {
          return this.tag('FirmwareScreen');
        }
        $exit() {
          this.show();
          this.tag('FirmwareScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device ');
        }
        _handleBack() {
          this._setState('Firmware');
        }
      }, class RebootConfirmation extends this {
        $enter() {
          this.hide();
          this.tag("RebootConfirmationScreen").visible = true;
          this.fireAncestors('$hideBreadCrum');
        }
        _getFocused() {
          return this.tag("RebootConfirmationScreen");
        }
        $exit() {
          this.show();
          this.tag("RebootConfirmationScreen").visible = false;
          this.fireAncestors('$showBreadCrum');
        }
        _handleBack() {
          this._setState('Reboot');
        }
        _handleEnter() {
          //default behaviour, confirm will override this
          this._setState('Reboot');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$2 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  thunderJS(config$2);
  /**
   * Class for AdvancedSettings screen.
   */

  class AdvanceSettingsScreen extends lng$1.Component {
    static _template() {
      return {
        AdvanceScreenContents: {
          x: 200,
          y: 275,
          TTSOptions: {
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('TTS Options'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CECControl: {
            y: 90,
            // alpha: 0.3, // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('CEC Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Bug: {
            y: 180,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Bug Report'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Contact: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Contact Support'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Device: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        DeviceScreen: {
          type: DeviceScreen,
          visible: false
        }
      };
    }
    _init() {
      this.cecApi = new CECApi();
      this.cecApi.activate().then(() => {
        this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.performOTPAction();
      });
      this._setState('CECControl');
    }
    _focus() {
      this._setState('CECControl');
    }
    performOTPAction() {
      this.cecApi.setEnabled().then(res => {
        if (res.success) {
          this.cecApi.performOTP().then(otpRes => {
            if (otpRes.success) {
              console.log('Otp Action success full');
            }
          });
        }
      });
    }
    toggleCEC() {
      this.cecApi.getEnabled().then(res => {
        console.log(res);
        if (res.enabled) {
          this.cecApi.deactivate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          });
        } else {
          this.cecApi.activate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
          });
        }
      });
    }
    hide() {
      this.tag('AdvanceScreenContents').visible = false;
    }
    show() {
      this.tag('AdvanceScreenContents').visible = true;
    }
    static _states() {
      return [class UIVoice extends this {
        $enter() {
          this.tag('UIVoice')._focus();
        }
        $exit() {
          this.tag('UIVoice')._unfocus();
        }
        _handleUp() {
          //this._setState('Reset');
        }
        _handleDown() {
          //this._setState('TTSOptions')
        }
        _handleEnter() {}
      }, class TTSOptions extends this {
        $enter() {
          this.tag('TTSOptions')._focus();
        }
        $exit() {
          this.tag('TTSOptions')._unfocus();
        }
        _handleUp() {
          //this._setState('UIVoice');
        }
        _handleDown() {
          //this._setState('CECControl')
        }
        _handleEnter() {}
      }, class CECControl extends this {
        $enter() {
          this.tag('CECControl')._focus();
        }
        $exit() {
          this.tag('CECControl')._unfocus();
        }
        _handleUp() {
          //this._setState('TTSOptions');
        }
        _handleDown() {
          this._setState('Device');
        }
        _handleEnter() {
          this.toggleCEC();
        }
      }, class Bug extends this {
        $enter() {
          this.tag('Bug')._focus();
        }
        $exit() {
          this.tag('Bug')._unfocus();
        }
        _handleUp() {
          //this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('Contact')
        }
        _handleEnter() {}
      }, class Contact extends this {
        $enter() {
          this.tag('Contact')._focus();
        }
        $exit() {
          this.tag('Contact')._unfocus();
        }
        _handleUp() {
          //this._setState('Bug');
        }
        _handleDown() {
          //this._setState('Device')
        }
        _handleEnter() {}
      }, class Device extends this {
        $enter() {
          this.tag('Device')._focus();
        }
        $exit() {
          this.tag('Device')._unfocus();
        }
        _handleUp() {
          this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('UI Voice')
        }
        _handleEnter() {
          this._setState("DeviceScreen");
        }
      }, class DeviceScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('DeviceScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('DeviceScreen');
        }
        $exit() {
          this.show();
          this.tag('DeviceScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings ');
        }
        _handleBack() {
          this._setState('Device');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Other Settings Screen.
   */

  class OtherSettingsScreen extends lng$1.Component {
    static _template() {
      return {
        OtherSettingsScreenContents: {
          x: 200,
          y: 275,
          SleepTimer: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Sleep Timer: Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          RemoteControl: {
            alpha: 0.3,
            // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          ScreenSaver: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Screen-Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          EnergySaver: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Energy Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Language: {
            alpha: 0.3,
            // disabled
            y: 450 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Language'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Privacy: {
            //alpha: 0.3, // disabled
            y: 540 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Privacy'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AdvancedSettings: {
            y: 630 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language.translate('Advanced Settings'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        SleepTimerScreen: {
          type: SleepTimerScreen,
          visible: false
        },
        EnergySavingsScreen: {
          type: EnergySavingsScreen,
          visible: false
        },
        LanguageScreen: {
          type: LanguageScreen,
          visible: false
        },
        PrivacyScreen: {
          type: PrivacyScreen,
          visible: false
        },
        AdvanceSettingsScreen: {
          type: AdvanceSettingsScreen,
          visible: false
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('SleepTimer');
    }
    $updateStandbyMode(standbyMode) {
      this.tag("EnergySaver.Title").text.text = Language.translate("Energy Saver: ") + standbyMode;
    }
    $sleepTimerText(text) {
      this.tag('SleepTimer.Title').text.text = Language.translate('Sleep Timer: ') + text;
    }
    _focus() {
      this._setState('SleepTimer');
      if (Storage.get('TimeoutInterval')) {
        this.tag('SleepTimer.Title').text.text = Language.translate('Sleep Timer: ') + Storage.get('TimeoutInterval');
      } else {
        this.tag('SleepTimer.Title').text.text = Language.translate('Sleep Timer: ') + 'Off';
      }
      this._appApi.getPreferredStandbyMode().then(result => {
        var currentStandbyMode = "";
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          currentStandbyMode = "Light Sleep";
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          currentStandbyMode = "Deep Sleep";
        }
        this.tag("EnergySaver.Title").text.text = Language.translate("Energy Saver: ") + currentStandbyMode;
      });
    }
    hide() {
      this.tag('OtherSettingsScreenContents').visible = false;
    }
    show() {
      this.tag('OtherSettingsScreenContents').visible = true;
    }
    static _states() {
      return [class SleepTimer extends this {
        $enter() {
          this.tag('SleepTimer')._focus();
        }
        $exit() {
          this.tag('SleepTimer')._unfocus();
        }
        _handleUp() {
          //  this._setState('AdvancedSettings')
        }
        _handleDown() {
          // this._setState('RemoteControl')
          this._setState('EnergySaver');
        }
        _handleEnter() {
          this._setState("SleepTimerScreen");
        }
      }, class RemoteControl extends this {
        $enter() {
          this.tag('RemoteControl')._focus();
        }
        $exit() {
          this.tag('RemoteControl')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('ScreenSaver');
        }
        _handleEnter() {}
      }, class ScreenSaver extends this {
        $enter() {
          this.tag('ScreenSaver')._focus();
        }
        $exit() {
          this.tag('ScreenSaver')._unfocus();
        }
        _handleUp() {
          this._setState('RemoteControl');
        }
        _handleDown() {
          this._setState('EnergySaver');
        }
        _handleEnter() {
          // 
        }
      }, class EnergySaver extends this {
        $enter() {
          this.tag('EnergySaver')._focus();
        }
        $exit() {
          this.tag('EnergySaver')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('Privacy');
        }
        _handleEnter() {
          this._setState("EnergySavingsScreen");
        }
      }, class Language extends this {
        $enter() {
          this.tag('Language')._focus();
        }
        $exit() {
          this.tag('Language')._unfocus();
        }
        _handleUp() {
          this._setState('EnergySaver');
        }
        _handleDown() {
          this._setState('Privacy');
        }
        _handleEnter() {
          // this._setState("LanguageScreen")
        }
      }, class Privacy extends this {
        $enter() {
          this.tag('Privacy')._focus();
        }
        $exit() {
          this.tag('Privacy')._unfocus();
        }
        _handleUp() {
          this._setState('EnergySaver');
        }
        _handleDown() {
          this._setState('AdvancedSettings');
        }
        _handleEnter() {
          this._setState("PrivacyScreen");
        }
      }, class AdvancedSettings extends this {
        $enter() {
          this.tag('AdvancedSettings')._focus();
        }
        $exit() {
          this.tag('AdvancedSettings')._unfocus();
        }
        _handleUp() {
          this._setState('Privacy');
        }
        _handleDown() {
          //  this._setState('SleepTimer')
        }
        _handleEnter() {
          this._setState("AdvanceSettingsScreen");
        }
      }, class SleepTimerScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('SleepTimerScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Sleep Timer');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('SleepTimerScreen');
        }
        $exit() {
          this.show();
          this.tag('SleepTimerScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('SleepTimer');
        }
      }, class EnergySavingsScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('EnergySavingsScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Energy Saver');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('EnergySavingsScreen');
        }
        $exit() {
          this.show();
          this.tag('EnergySavingsScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('EnergySaver');
        }
      },
      //LanguageScreen
      class LanguageScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('LanguageScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Language');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('LanguageScreen');
        }
        $exit() {
          this.show();
          this.tag('LanguageScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('Language');
        }
      },
      //PrivacyScreen
      class PrivacyScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('PrivacyScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Privacy');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('PrivacyScreen');
        }
        $exit() {
          this.show();
          this.tag('PrivacyScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('Privacy');
        }
      }, class AdvanceSettingsScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('AdvanceSettingsScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('AdvanceSettingsScreen');
        }
        $exit() {
          this.show();
          this.tag('AdvanceSettingsScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('AdvancedSettings');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$1 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  var thunder$1 = thunderJS(config$1);
  /**
   * Class for settings screen.
   */
  class SettingsOverlay extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {
          rect: true,
          color: 0xcc000000,
          w: 1920,
          h: 1080,
          visible: false,
          BreadCrumbs: {
            x: 200,
            y: 184,
            text: {
              fontSize: 40,
              text: Language.translate("settings"),
              textColor: CONFIG.theme.hex,
              fontStyle: "bolder",
              fontFace: CONFIG.language.font,
              wordWrapWidth: 1720,
              maxLines: 1
            }
          },
          SettingsScreenContents: {
            x: 200,
            y: 275,
            NetworkConfiguration: {
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate("Network Configuration"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            Bluetooth: {
              y: 90,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate("Pair Remote Control"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            Video: {
              y: 180,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate("Video"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            Audio: {
              y: 270,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate("Audio"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            OtherSettings: {
              y: 360,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate("Other Settings"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            NFRStatus: {
              y: 450,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate('Native Frame Rate'),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 67,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset('images/settings/ToggleOffWhite.png')
              }
            },
            DTVSettings: {
              alpha: 0.3,
              y: 540,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language.translate("Live TV"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            }
          },
          AudioScreenOverlay: {
            type: AudioScreen,
            visible: false
          },
          NetworkConfigurationOverlay: {
            type: NetworkConfigurationScreen,
            visible: false
          },
          BluetoothScreenOverlay: {
            type: BluetoothScreen,
            visible: false
          },
          LiveTvSettings: {
            type: LiveTVSettings,
            visible: false
          },
          VideoScreenOverlay: {
            type: VideoScreen,
            visible: false
          },
          OtherSettingsScreen: {
            type: OtherSettingsScreen,
            visible: false
          }
        }
      };
    }
    _focus() {
      this.tag("Wrapper").visible = true;
      this._setState("NetworkConfiguration");
      this.$updatePageTitle("settings"); //use this method as fireancestor from child components to change the page title
    }

    _unfocus() {
      this.tag("Wrapper").visible = false;
    }
    _firstActive() {
      if (Storage.get("NFRStatus")) {
        console.log("Netflix : NFRStatus is found to be enabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
      } else {
        console.log("Netflix : NFRStatus is found to be disabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
      }
      this.appApi = new AppApi();
      this.dtvApi = new DTVApi();
      this.dtvPlugin = false; //plugin availability
      this.dtvApi.activate().then(res => {
        // if (res){
        this.dtvPlugin = true;
        this.tag("DTVSettings").alpha = 1;
        // }
      });
    }

    _handleBack() {
      console.log("application Type = ", Storage.get("applicationType"));
      if (Storage.get("applicationType") === "") {
        if (Router.getActiveHash() === "player" || Router.getActiveHash() === "dtvplayer" || Router.getActiveHash() === "usb/player") {
          Router.focusPage();
        } else {
          Router.focusPage();
          Router.navigate("menu");
        }
      } else {
        Router.focusPage();
        this.appApi.visibile("ResidentApp", false);
        this.appApi.setFocus(Storage.get("applicationType"));
      }
    }
    _handleLeft() {
      //do nothing
    }
    _handleRight() {
      //do nothing
    }
    _handleUp() {
      //do nothing
    }
    _handleDown() {
      //do nothing
    }
    $updatePageTitle(title, alreadyTranslated) {
      console.log("title", title);
      if (alreadyTranslated) {
        this.tag("BreadCrumbs").text.text = title;
      } else {
        this.tag("BreadCrumbs").text.text = Language.translate(title);
      }
    }
    hide() {
      this.tag('SettingsScreenContents').visible = false;
    }
    show() {
      this.tag('SettingsScreenContents').visible = true;
    }
    $hideBreadCrum() {
      this.tag("BreadCrumbs").visible = false;
    }
    $showBreadCrum() {
      this.tag("BreadCrumbs").visible = true;
    }
    static _states() {
      return [class NetworkConfiguration extends this {
        $enter() {
          this.tag("NetworkConfiguration")._focus();
        }
        $exit() {
          this.tag("NetworkConfiguration")._unfocus();
        }
        _handleDown() {
          this._setState("Bluetooth");
        }
        _handleEnter() {
          this._setState('NetworkConfigurationOverlay');
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag("Bluetooth")._focus();
        }
        $exit() {
          this.tag("Bluetooth")._unfocus();
        }
        _handleUp() {
          this._setState("NetworkConfiguration");
        }
        _handleDown() {
          this._setState("Video");
        }
        _handleLeft() {}
        _handleEnter() {
          this._setState("BluetoothScreenOverlay");
        }
      }, class Video extends this {
        $enter() {
          this.tag("Video")._focus();
        }
        $exit() {
          this.tag("Video")._unfocus();
        }
        _handleUp() {
          this._setState("Bluetooth");
        }
        _handleDown() {
          this._setState("Audio");
        }
        _handleEnter() {
          this._setState('VideoScreenOverlay');
        }
      }, class Audio extends this {
        $enter() {
          this.tag("Audio")._focus();
        }
        $exit() {
          this.tag("Audio")._unfocus();
        }
        _handleUp() {
          this._setState("Video");
        }
        _handleEnter() {
          this._setState('AudioScreenOverlay');
        }
        _handleDown() {
          this._setState("OtherSettings");
        }
      }, class OtherSettings extends this {
        $enter() {
          this.tag("OtherSettings")._focus();
        }
        $exit() {
          this.tag("OtherSettings")._unfocus();
        }
        _handleUp() {
          this._setState("Audio");
        }
        _handleEnter() {
          this._setState("OtherSettingsScreen");
        }
        _handleDown() {
          this._setState("NFRStatus");
        }
      }, class NFRStatus extends this {
        $enter() {
          this.tag('NFRStatus')._focus();
        }
        $exit() {
          this.tag('NFRStatus')._unfocus();
        }
        _handleUp() {
          this._setState('OtherSettings');
        }
        _handleDown() {
          if (this.dtvPlugin) {
            this._setState('DTVSettings');
          }
        }
        _handleEnter() {
          //handle Switch
          let self = this;
          if (Storage.get("NFRStatus")) {
            thunder$1.call("Netflix.1", "nfrstatus", {
              "params": "disable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
              Storage.set("NFRStatus", false);
              console.log("Netflix : nfr disable updation results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus");
              console.error(nerr);
            });
          } else {
            thunder$1.call("Netflix.1", "nfrstatus", {
              "params": "enable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
              Storage.set("NFRStatus", true);
              console.log("Netflix : nfr enable results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus ");
              console.error(nerr);
            });
          }
        }
      }, class DTVSettings extends this {
        $enter() {
          this.tag("DTVSettings")._focus();
        }
        $exit() {
          this.tag("DTVSettings")._unfocus();
        }
        _handleUp() {
          this._setState('NFRStatus');
        }
        _handleEnter() {
          if (this.dtvPlugin) {
            this._setState("LiveTvSettings");
          }
          dtvApi.activate().then(res => {
            this.tag('DTVSettings.Title').text.text = 'DTV Settings: Activtion' + res;
          });
        }
      }, class AudioScreenOverlay extends this {
        $enter() {
          this.hide();
          this.tag('AudioScreenOverlay').visible = true;
          this.$updatePageTitle('Settings  Audio');
        }
        _getFocused() {
          return this.tag('AudioScreenOverlay');
        }
        $exit() {
          this.show();
          this.tag('AudioScreenOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState("Audio");
        }
      }, class VideoScreenOverlay extends this {
        $enter() {
          this.hide();
          this.tag('VideoScreenOverlay').visible = true;
          this.$updatePageTitle('Settings  Video');
        }
        _getFocused() {
          return this.tag('VideoScreenOverlay');
        }
        $exit() {
          this.show();
          this.tag('VideoScreenOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('Video');
        }
      }, class NetworkConfigurationOverlay extends this {
        $enter() {
          this.hide();
          this.tag('NetworkConfigurationOverlay').visible = true;
          this.$updatePageTitle("Settings  Network Configuration");
        }
        _getFocused() {
          return this.tag('NetworkConfigurationOverlay');
        }
        $exit() {
          this.show();
          this.tag('NetworkConfigurationOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState("NetworkConfiguration");
        }
      }, class BluetoothScreenOverlay extends this {
        $enter() {
          this.hide();
          this.tag('BluetoothScreenOverlay').visible = true;
          this.$updatePageTitle('Settings  Bluetooth On/Off');
        }
        _getFocused() {
          return this.tag('BluetoothScreenOverlay');
        }
        $exit() {
          this.show();
          this.tag('BluetoothScreenOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('Bluetooth');
        }
      }, class OtherSettingsScreen extends this {
        $enter() {
          this.hide();
          this.tag('OtherSettingsScreen').visible = true;
          this.$updatePageTitle('Settings  Other Settings');
        }
        _getFocused() {
          return this.tag('OtherSettingsScreen');
        }
        $exit() {
          this.show();
          this.tag('OtherSettingsScreen').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('OtherSettings');
        }
      }, class LiveTvSettings extends this {
        $enter() {
          this.hide();
          this.tag('LiveTvSettings').visible = true;
          this.$updatePageTitle("Settings / Live TV");
        }
        _getFocused() {
          return this.tag('LiveTvSettings');
        }
        $exit() {
          this.show();
          this.tag('LiveTvSettings').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('DTVSettings');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  var powerState = 'ON';
  var thunder = thunderJS(config);
  var appApi = new AppApi();
  var dtvApi$1 = new DTVApi();
  class App extends Router.App {
    static getFonts() {
      return [{
        family: CONFIG.language.font,
        url: Utils.asset('fonts/' + CONFIG.language.fontSrc)
      }];
    }
    _setup() {
      console.log("accelerator-home-ui version: " + Settings.get("platform", "version"));
      Router.startRouter(routes, this);
      document.onkeydown = e => {
        if (e.keyCode == keyMap.Backspace) {
          e.preventDefault();
        }
      };
      function updateAddress() {
        if (window.navigator.onLine) {
          console.log("is online");
        } else {
          Storage.set("ipAddress", null);
          console.log("is offline");
        }
      }
      window.addEventListener("offline", updateAddress);
    }
    static _template() {
      return {
        Pages: {
          // this hosts all the pages
          forceZIndexContext: true
        },
        Widgets: {
          Menu: {
            type: Menu
          },
          Fail: {
            type: Failscreen
          },
          Volume: {
            type: Volume
          },
          TvOverlays: {
            type: TvOverlayScreen
          },
          ChannelOverlay: {
            type: ChannelOverlay
          },
          SettingsOverlay: {
            type: SettingsOverlay
          }
        }
      };
    }
    static language() {
      return {
        file: Utils.asset('language/language-file.json'),
        language: CONFIG.language.id
      };
    }
    $updateTimeZone(timezone) {
      this.tag('Menu').updateTimeZone(timezone);
    }
    _captureKey(key) {
      console.log(key, key.keyCode);
      if (key.keyCode == keyMap.Escape || key.keyCode == keyMap.Home || key.keyCode === keyMap.m) {
        if (Storage.get('applicationType') != '') {
          appApi.exitApp(Storage.get('applicationType')).catch(err => {
            console.log(err);
          });
          if (Router.getActiveHash().startsWith("tv-overlay") || Router.getActiveHash().startsWith("overlay") || Router.getActiveHash().startsWith("applauncher")) {
            Router.navigate('menu');
          }
        } else {
          if (!Router.isNavigating()) {
            if (Router.getActiveHash() === "dtvplayer") {
              //exit scenario for dtv player
              dtvApi$1.exitChannel().then(res => {
                console.log("exit channel: ", JSON.stringify(res));
              }).catch(err => {
                console.log("failed to exit channel: ", JSON.stringify(err));
              });
              if (Router.getActiveWidget()) {
                Router.getActiveWidget()._setState("IdleState");
              }
            }
            Router.navigate('menu');
          }
        }
        return true;
      }
      if (key.keyCode == keyMap.Inputs_Shortcut) {
        //for inputs overlay
        if (Storage.get("applicationType") !== "") {
          if (Router.getActiveHash() === "tv-overlay/inputs") {
            Router.reload();
          } else {
            Router.navigate("tv-overlay/inputs", false);
          }
          // appApi.setVisibility('ResidentApp', true);
          thunder.call('org.rdk.RDKShell', 'moveToFront', {
            client: 'ResidentApp'
          }).then(result => {
            appApi.setVisibility('ResidentApp', true); //#requiredChange
            console.log('ResidentApp moveToFront Success');
            thunder.call("org.rdk.RDKShell", "setFocus", {
              client: 'ResidentApp'
            }).then(result => {
              console.log("residentApp setFocus Success");
            }).catch(err => {
              console.log("Error", err);
            });
          });
        } else {
          if (Router.getActiveHash() === "dtvplayer") {
            Router.focusWidget('TvOverlays');
            Router.getActiveWidget()._setState("OverlayInputScreen");
          }
        }
        return true;
      }
      if (key.keyCode == keyMap.Picture_Setting_Shortcut) {
        //for video settings overlay
        if (Storage.get("applicationType") !== "") {
          if (Router.getActiveHash() === "tv-overlay/settings") {
            Router.reload();
          } else {
            Router.navigate("tv-overlay/settings", false);
          }
          // appApi.setVisibility('ResidentApp', true);
          thunder.call('org.rdk.RDKShell', 'moveToFront', {
            client: 'ResidentApp'
          }).then(result => {
            appApi.setVisibility('ResidentApp', true); //#requiredChange
            console.log('ResidentApp moveToFront Success');
            thunder.call("org.rdk.RDKShell", "setFocus", {
              client: 'ResidentApp'
            }).then(result => {
              console.log("Resident App setFocus Success");
            }).catch(err => {
              console.log("Error", err);
            });
          });
        } else {
          if (Router.getActiveHash() === "dtvplayer") {
            Router.focusWidget('TvOverlays');
            Router.getActiveWidget()._setState("OverlaySettingsScreen");
          }
        }
        return true;
      }
      if (key.keyCode == keyMap.Settings_Shortcut) {
        console.log("settings shortcut");
        if (Storage.get("applicationType") === "") {
          //launch settings overlay/page depending on the current route.
          if (Router.getActiveHash() === "player" || Router.getActiveHash() === "dtvplayer" || Router.getActiveHash() === "usb/player") {
            //player supports settings overlay, so launch it as overlay
            if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "SettingsOverlay") {
              //currently focused on settings overlay, so hide it
              Router.focusPage();
            } else {
              //launch the settings overlay
              Router.focusWidget('SettingsOverlay');
            }
          } else {
            //navigate to settings page for all other routes
            Router.navigate("settings");
          }
        } else {
          //currently on some application
          if (Router.getActiveHash() === "applauncher") {
            //if route is applauncher just focus the overlay widget
            if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "SettingsOverlay") {
              //currently focused on settings overlay, so hide it
              Router.focusPage();
              let currentApp = Storage.get("applicationType");
              appApi.zorder(currentApp);
              appApi.setFocus(currentApp);
              appApi.setVisibility(currentApp, true);
            } else {
              //launch the settings overlay
              appApi.zorder("ResidentApp");
              appApi.setFocus("ResidentApp");
              appApi.setVisibility("ResidentApp", true);
              Router.focusWidget('SettingsOverlay');
            }
          } else {
            //if on some other route while on an application, route to applauncher before launching the settings overlay
            appApi.zorder("ResidentApp");
            appApi.setFocus("ResidentApp");
            appApi.setVisibility("ResidentApp", true);
            Router.navigate("applauncher");
            Router.focusWidget('SettingsOverlay');
          }
        }
        return true;
      }
      if (key.keyCode == keyMap.Guide_Shortcut) {
        Router.navigate('epg');
        return true;
      }
      if (key.keyCode == keyMap.Amazon) {
        appApi.launchApp("Amazon").catch(err => {
          console.error("Error in launching Amazon via dedicated key: " + JSON.stringify(err));
        });
        return true;
      }
      if (key.keyCode == keyMap.Youtube) {
        let params = {
          launchLocation: "dedicatedButton"
        };
        appApi.launchApp("Cobalt", params).catch(err => {
          console.error("Error in launching Youtube via dedicated key: " + JSON.stringify(err));
        });
        return true;
      }
      if (key.keyCode == keyMap.Netflix) {
        //launchLocation mapping is in launchApp method in AppApi.js
        let params = {
          launchLocation: "dedicatedButton"
        };
        appApi.launchApp("Netflix", params).catch(err => {
          console.error("Error in launching Netflix via dedicated key: " + JSON.stringify(err));
        });
        return true;
      }
      if (key.keyCode == keyMap.Power) {
        // Remote power key and keyboard F1 key used for STANDBY and POWER_ON
        if (powerState == 'ON') {
          this.standby('STANDBY');
          return true;
        } else if (powerState == 'STANDBY') {
          appApi.standby("ON").then(res => {
            powerState = 'ON';
          });
          return true;
        }
      } else if (key.keyCode == 228) {
        console.log("___________DEEP_SLEEP_______________________F12");
        appApi.standby("DEEP_SLEEP").then(res => {
          powerState = 'DEEP_SLEEP';
        });
        return true;
      } else if (key.keyCode == keyMap.AudioVolumeMute) {
        if (Storage.get('applicationType') !== '') {
          let activePage = Router.getActiveRoute();
          if (activePage !== 'overlay/volume') {
            Router.navigate('overlay/volume', {
              flag: true,
              route: activePage
            });
            this._moveToFront();
          } else {
            this._moveToFront();
            let page = Router.getActivePage();
            page.onVolumeMute();
          }
        } else {
          if (Router.getActiveWidget()) {
            let page = Router.getActiveWidget();
            page.onVolumeMute();
          }
          Router.focusWidget('Volume');
        }
        return true;
      } else if (key.keyCode == keyMap.AudioVolumeUp) {
        if (Storage.get('applicationType') !== '') {
          let activePage = Router.getActiveRoute();
          if (activePage !== 'overlay/volume') {
            Router.navigate('overlay/volume', {
              flag: true,
              route: activePage
            });
            this._moveToFront();
          } else {
            this._moveToFront();
            let page = Router.getActivePage();
            page.onVolumeKeyUp();
          }
        } else {
          if (Router.getActiveWidget()) {
            let page = Router.getActiveWidget();
            page.onVolumeKeyUp();
          }
          Router.focusWidget('Volume');
        }
        return true;
      } else if (key.keyCode == keyMap.AudioVolumeDown) {
        if (Storage.get('applicationType') !== '') {
          let activePage = Router.getActiveRoute();
          if (activePage !== 'overlay/volume') {
            Router.navigate('overlay/volume', {
              flag: true,
              route: activePage
            });
            this._moveToFront();
          } else {
            this._moveToFront();
            let page = Router.getActivePage();
            page.onVolumeKeyDown();
          }
        } else {
          if (Router.getActiveWidget()) {
            let page = Router.getActiveWidget();
            page.onVolumeKeyDown();
          }
          Router.focusWidget('Volume');
        }
        return true;
      }
      return false;
    }
    _moveToFront() {
      appApi.setVisibility('ResidentApp', true);
      appApi.zorder('residentApp');
    }
    _init() {
      if (Storage.get("applicationType") !== "HDMI") {
        //to default to hdmi, if previous input was hdmi
        Storage.set('applicationType', ''); //to set the application type to none
      }

      appApi.enableDisplaySettings().then(res => {
        console.log("results : ".concat(JSON.stringify(res)));
      }).catch(err => {
        console.error("error while enabling displaysettings");
      });
      appApi.cobaltStateChangeEvent();
      this.xcastApi = new XcastApi();
      this.xcastApi.activate().then(result => {
        if (result) {
          this.registerXcastListeners();
        }
      });
      keyIntercept();
      if (!availableLanguages.includes(localStorage.getItem('Language'))) {
        localStorage.setItem('Language', 'English');
      }
      thunder.on('Controller.1', 'all', noti => {
        if (noti.data.url && noti.data.url.slice(-5) === "#boot") {
          // to exit metro apps by pressing back key
          appApi.exitApp(Storage.get('applicationType'));
        }
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationDisconnected', notification => {
        console.log("onApplicationDisconnectedNotification: ", JSON.stringify(notification));
      });
      thunder.on('Controller', 'statechange', notification => {
        // get plugin status
        console.log("Controller statechange Notification : " + JSON.stringify(notification));
        if (notification && (notification.callsign === 'Cobalt' || notification.callsign === 'Amazon' || notification.callsign === 'LightningApp' || notification.callsign === 'HtmlApp' || notification.callsign === 'Netflix') && (notification.state == 'Deactivation' || notification.state == 'Deactivated')) {
          console.log("".concat(notification.callsign, " status = ").concat(notification.state));
          console.log(">>notification.callsign: ", notification.callsign, " applicationType: ", Storage.get("applicationType"));
          if (Router.getActiveHash().startsWith("tv-overlay") || Router.getActiveHash().startsWith("overlay") || Router.getActiveHash().startsWith("applauncher")) {
            //navigate to homescreen if route is tv-overlay when exiting from any app
            console.log("navigating to homescreen");
            Router.navigate("menu");
          }
          if (notification.callsign === Storage.get("applicationType")) {
            //only launch residentApp iff notification is from currentApp
            console.log(notification.callsign + " is in: " + notification.state + " state, and application type in Storage is still: " + Storage.get("applicationType") + " calling launchResidentApp");
            appApi.launchResidentApp();
          }
        }
        if (notification && notification.callsign === 'org.rdk.HdmiCec_2' && notification.state === 'Activated') {
          this.advanceScreen = Router.activePage();
          if (typeof this.advanceScreen.performOTPAction === 'function') {
            console.log('otp action');
            this.advanceScreen.performOTPAction();
          }
        }
        if (notification && (notification.callsign === 'Cobalt' || notification.callsign === 'Amazon' || notification.callsign === 'LightningApp' || notification.callsign === 'HtmlApp' || notification.callsign === 'Netflix') && notification.state == 'Activated') {
          Storage.set('applicationType', notification.callsign); //required in case app launch happens using curl command.
          if (notification.callsign === 'Netflix') {
            appApi.getNetflixESN().then(res => {
              Storage.set('Netflix_ESN', res);
            });
            thunder.on('Netflix', 'notifyeventchange', notification => {
              console.log("NETFLIX : notifyEventChange notification = ", JSON.stringify(notification));
              if (notification.EventName === "rendered") {
                Router.navigate('menu');
                if (Storage.get("NFRStatus")) {
                  thunder.call("Netflix.1", "nfrstatus", {
                    "params": "enable"
                  }).then(nr => {
                    console.log("Netflix : nfr enable results in ".concat(nr));
                  }).catch(nerr => {
                    console.error("Netflix : error while updating nfrstatus ".concat(nerr));
                  });
                } else {
                  thunder.call("Netflix.1", "nfrstatus", {
                    "params": "disable"
                  }).then(nr => {
                    console.log("Netflix : nfr disable results in ".concat(nr));
                  }).catch(nerr => {
                    console.error("Netflix : error while updating nfrstatus ".concat(nerr));
                  });
                }
                appApi.visibile('ResidentApp', false);
              }
              if (notification.EventName === "requestsuspend") {
                this.deactivateChildApp('Netflix');
              }
              if (notification.EventName === "updated") {
                console.log("Netflix : xxxxxxxxxxxxxxxxxx Updated Event Trigger xxxxxxxxxxxxxxxxxxxx");
                appApi.getNetflixESN().then(res => {
                  Storage.set('Netflix_ESN', res);
                });
              }
            });
          } else {
            appApi.setFocus(notification.callsign); //required in case app launch happens using curl command.
          }
        }
      });
    }

    activateChildApp(plugin) {
      //#currentlyNotUsed #needToBeRemoved
      fetch('http://127.0.0.1:9998/Service/Controller/').then(res => res.json()).then(data => {
        data.plugins.forEach(element => {
          if (element.callsign === plugin) {
            Storage.set('applicationType', plugin);
            appApi.launchPremiumApp(plugin).catch(() => {});
            appApi.setVisibility('ResidentApp', false);
          }
        });
        console.log('launching app');
      }).catch(err => {
        console.log("".concat(plugin, " not available"), err);
      });
    }
    deactivateChildApp(plugin) {
      //#needToBeRemoved
      switch (plugin) {
        case 'WebApp':
          appApi.deactivateWeb();
          break;
        case 'Cobalt':
          appApi.suspendPremiumApp("Cobalt").then(res => {
            if (res) {
              let params = {
                applicationName: "YouTube",
                state: 'suspended'
              };
              this.xcastApi.onApplicationStateChanged(params).catch(err => {
                console.error(err);
              });
            }
            console.log("Cobalt : suspend cobalt request");
          }).catch(err => {
            console.error(err);
          });
          break;
        case 'Lightning':
          appApi.deactivateLightning();
          break;
        case 'Native':
          appApi.killNative();
          break;
        case 'Amazon':
          appApi.suspendPremiumApp('Amazon').then(res => {
            if (res) {
              let params = {
                applicationName: "AmazonInstantVideo",
                state: 'suspended'
              };
              this.xcastApi.onApplicationStateChanged(params);
            }
          });
          break;
        case 'Netflix':
          appApi.suspendPremiumApp('Netflix').then(res => {
            thunder.call('org.rdk.RDKShell', 'setFocus', {
              client: "ResidentApp"
            });
            if (res) {
              let params = {
                applicationName: "NetflixApp",
                state: 'suspended'
              };
              this.xcastApi.onApplicationStateChanged(params);
            }
          });
          break;
        case 'HDMI':
          new HDMIApi().stopHDMIInput();
          Storage.set("_currentInputMode", {});
          break;
      }
    }
    $initLaunchPad(url) {
      return new Promise((resolve, reject) => {
        appApi.getPluginStatus('Netflix').then(result => {
          console.log("netflix plugin status is :", JSON.stringify(result));
          console.log("netflix plugin status is :", result);
          if (result[0].state === 'deactivated' || result[0].state === 'deactivation') {
            Router.navigate('image', {
              src: Utils.asset('images/apps/App_Netflix_Splash.png')
            });
            if (url) {
              appApi.configureApplication('Netflix', url).then(() => {
                appApi.launchPremiumApp("Netflix").then(res => {
                  appApi.setVisibility('ResidentApp', false);
                  resolve(true);
                }).catch(err => {
                  reject(false);
                }); // ie. org.rdk.RDKShell.launch
              }).catch(err => {
                console.error("Netflix : error while fetching configuration data : ", JSON.stringify(err));
                reject(err);
              }); // gets configuration object and sets configuration
            } else {
              appApi.launchPremiumApp("Netflix").then(res => {
                appApi.setVisibility('ResidentApp', false);
                resolve(true);
              }).catch(err => {
                reject(false);
              }); // ie. org.rdk.RDKShell.launch
            }
          } else {
            /* Not in deactivated; could be suspended */
            if (url) {
              appApi.launchPremiumApp("Netflix").then(res => {
                thunder.call("Netflix", "systemcommand", {
                  "command": url
                }).then(res => {}).catch(err => {
                  console.error("Netflix : error while sending systemcommand : ", JSON.stringify(err));
                  reject(false);
                });
                appApi.setVisibility('ResidentApp', false);
                resolve(true);
              }).catch(err => {
                reject(false);
              }); // ie. org.rdk.RDKShell.launch
            } else {
              appApi.launchPremiumApp("Netflix").then(res => {
                console.log("Netflix : launch premium app resulted in ", JSON.stringify(res));
                appApi.setVisibility('ResidentApp', false);
                resolve(true);
              });
            }
          }
        }).catch(err => {
          console.log('Netflix plugin error', err);
          Storage.set('applicationType', '');
          reject(false);
        });
      });
    }

    /**
     * Function to register event listeners for Xcast plugin.
     */
    registerXcastListeners() {
      this.xcastApi.registerEvent('onApplicationLaunchRequest', notification => {
        console.log('Received a launch request ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          let url = applicationName === "Cobalt" ? notification.parameters.url + '&inApp=true' : notification.parameters.url;
          let params = {
            url: url,
            launchLocation: "dial"
          };
          appApi.launchApp(applicationName, params).then(res => {
            console.log("App launched on xcast event: ", res);
            let params = {
              applicationName: notification.applicationName,
              state: 'running'
            };
            this.xcastApi.onApplicationStateChanged(params);
          }).catch(err => {
            console.log("Applaunch error on xcast notification: ", err);
          });
        }
      });
      this.xcastApi.registerEvent('onApplicationHideRequest', notification => {
        console.log('Received a hide request ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          console.log('Hide ' + this.xcastApps(notification.applicationName));
          //second argument true means resident app won't be launched the required app will be exited in the background.
          //only bring up the resident app when the notification is from the current app(ie app in focus)
          console.log("exitApp is getting called depending upon " + applicationName + "!==" + Storage.get("applicationType"));
          appApi.exitApp(applicationName, applicationName !== Storage.get("applicationType"));
          let params = {
            applicationName: notification.applicationName,
            state: 'suspended'
          };
          console.log("Event : On hide request, updating application Status to ", params);
          this.xcastApi.onApplicationStateChanged(params);
        }
      });
      this.xcastApi.registerEvent('onApplicationResumeRequest', notification => {
        console.log('Received a resume request ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          let params = {
            url: notification.parameters.url,
            launchLocation: "dial"
          };
          console.log('Resume ', applicationName, " with params: ", params);
          appApi.launchApp(applicationName, params).then(res => {
            console.log("launched ", applicationName, " on casting resume request: ", res);
            let params = {
              applicationName: notification.applicationName,
              state: 'running'
            };
            this.xcastApi.onApplicationStateChanged(params);
          }).catch(err => {
            console.log("Error in launching ", applicationName, " on casting resume request: ", err);
          });
        }
      });
      this.xcastApi.registerEvent('onApplicationStopRequest', notification => {
        console.log('Received an xcast stop request ' + JSON.stringify(notification));
        console.log('Received a stop request ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          console.log('Stop ' + this.xcastApps(notification.applicationName));
          let applicationName = this.xcastApps(notification.applicationName);
          //second argument true means resident app won't be launched the required app will be exited in the background.
          //only bring up the resident app when the notification is from the current app(ie app in focus)
          console.log("exitApp is getting called depending upon " + applicationName + "!==" + Storage.get("applicationType"));
          appApi.exitApp(applicationName, applicationName !== Storage.get("applicationType"));
          let params = {
            applicationName: notification.applicationName,
            state: 'stopped'
          };
          this.xcastApi.onApplicationStateChanged(params);
        }
      });
      this.xcastApi.registerEvent('onApplicationStateRequest', notification => {
        // console.log('onApplicationStateRequest : ');
        // console.log(JSON.stringify(notification))
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          let params = {
            applicationName: notification.applicationName,
            state: 'stopped'
          };
          appApi.registerEvent('statechange', results => {
            if (results.callsign === applicationName && results.state === 'Activated') {
              params.state = 'running';
              Storage.set("applicationType", results.callsign); //required in case app launch happens using curl command.
            } else if (results.state === 'Deactivation') {
              params.state = "stopped";
            } else if (results.state = "Activation") ; else if (results.state = "Resumed") {
              params.state = "running";
            } else if (results.state == 'suspended') {
              params.state = 'suspended';
            }
            console.log("STATE CHANGED : ");
            console.log(results);
            this.xcastApi.onApplicationStateChanged(params);
            console.log('State of ' + this.xcastApps(notification.applicationName));
          });
        }
      });
    }

    /**
     * Function to get the plugin name for the application name.
     * @param {string} app App instance.
     */
    xcastApps(app) {
      if (Object.keys(XcastApi.supportedApps()).includes(app)) {
        return XcastApi.supportedApps()[app];
      } else return false;
    }
    $mountEventConstructor(fun) {
      this.ListenerConstructor = fun;
      console.log("MountEventConstructor was initialized");
      // console.log(`listener constructor was set t0 = ${this.ListenerConstructor}`);
    }

    $registerUsbMount() {
      this.disposableListener = this.ListenerConstructor();
      console.log("Successfully registered the usb Mount");
    }
    $deRegisterUsbMount() {
      console.log("the current usbListener = ".concat(this.disposableListener));
      this.disposableListener.dispose();
      console.log("successfully deregistered usb listener");
    }
    standby(value) {
      console.log("standby call");
      if (value == 'Back') ; else {
        if (powerState == 'ON') {
          console.log("Power state was on trying to set it to standby");
          appApi.standby(value).then(res => {
            if (res.success) {
              console.log("successfully set to standby");
              powerState = 'STANDBY';
              if (Storage.get('applicationType') !== "") {
                appApi.exitApp(Storage.get('applicationType'), false, true); //setting to forceDestroy since standby is supposed to deactivate the app.
              } else {
                if (!Router.isNavigating()) {
                  Router.navigate('menu');
                }
              }
            }
          });
          return true;
        }
      }
    }
    $registerInactivityMonitoringEvents() {
      return new Promise((resolve, reject) => {
        console.log("registered inactivity listener");
        appApi.standby('ON').then(res => {
          if (res.success) {
            powerState = 'ON';
          }
        });
        const systemcCallsign = "org.rdk.RDKShell.1";
        thunder.Controller.activate({
          callsign: systemcCallsign
        }).then(res => {
          console.log("activated the rdk shell plugin trying to set the inactivity listener; res = ".concat(JSON.stringify(res)));
          thunder.on("org.rdk.RDKShell.1", "onUserInactivity", notification => {
            console.log("user was inactive");
            if (powerState === "ON" && Storage.get('applicationType') == '') {
              this.standby("STANDBY");
            }
          }, err => {
            console.error("error while inactivity monitoring , ".concat(err));
          });
          resolve(res);
        }).catch(err => {
          reject(err);
          console.error("error while activating the displaysettings plugin; err = ".concat(err));
        });
      });
    }
    $resetSleepTimer(t) {
      console.log("reset sleep timer call ".concat(t));
      var arr = t.split(" ");
      function setTimer() {
        console.log('Timer ', arr);
        var temp = arr[1].substring(0, 1);
        if (temp === 'H') {
          let temp1 = parseFloat(arr[0]) * 60;
          appApi.setInactivityInterval(temp1).then(res => {
            Storage.set('TimeoutInterval', t);
            console.log("successfully set the timer to ".concat(t, " hours"));
          }).catch(err => {
            console.error("error while setting the timer");
          });
        } else if (temp === 'M') {
          console.log("minutes");
          let temp1 = parseFloat(arr[0]);
          appApi.setInactivityInterval(temp1).then(res => {
            Storage.set('TimeoutInterval', t);
            console.log("successfully set the timer to ".concat(t, " minutes"));
          }).catch(err => {
            console.error("error while setting the timer");
          });
        }
      }
      if (arr.length < 2) {
        appApi.enabledisableinactivityReporting(false).then(res => {
          if (res.success === true) {
            Storage.set('TimeoutInterval', false);
            console.log("Disabled inactivity reporting");
            // this.timerIsOff = true;
          }
        }).catch(err => {
          console.error("error : unable to set the reset; error = ".concat(err));
        });
      } else {
        appApi.enabledisableinactivityReporting(true).then(res => {
          if (res.success === true) {
            console.log("Enabled inactivity reporting; trying to set the timer to ".concat(t));
            // this.timerIsOff = false;
            setTimer();
          }
        }).catch(err => {
          console.error("error while enabling inactivity reporting");
        });
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  function index () {
    console.time('PerformanceTest');
    console.log('Timer Start - ', new Date().toUTCString());
    return Launch(App, ...arguments);
  }

  return index;

})();
